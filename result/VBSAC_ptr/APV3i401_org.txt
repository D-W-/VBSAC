/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=32807:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.AP_ITC_401_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0010_bad]
 +memory_leak_0010_bad
SCC(1): [memory_leak_0010_good]
 +memory_leak_0010_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_0010_bad, memory_leak_0010_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0010_bad::call), H(memory_leak_0010_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0010_bad
P+ = [] 
P- = [H(memory_leak_0010_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_0010_good
P+ = [] 
P- = [H(memory_leak_0010_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.332s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0010_bad to main}-> N6
Message  : the heap object @H(memory_leak_0010_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0010_good, On N4 -> N43 (call memory_leak_0010_good)
> takes the false branch, At N57 of Function memory_leak_0010_good
> Leaving function: memory_leak_0010_good, On N42 -> N5 (Return edge from memory_leak_0010_good to main)
> Entering function: memory_leak_0010_bad, On N5 -> N9 (call memory_leak_0010_bad)
> takes the false branch, At N19 of Function memory_leak_0010_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0010_bad to main]
N8 -> N6: [Return edge from memory_leak_0010_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_10.c 58] memory_leak_0010_bad 		[N8 -{Return edge from memory_leak_0010_bad to main}-> N6]	(the heap object @H(memory_leak_0010_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0011_good]
 +memory_leak_0011_good
SCC(1): [memory_leak_0011_bad]
 +memory_leak_0011_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_0011_good, main, memory_leak_0011_bad]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0011_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0011_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_0011_good
P+ = [] 
P- = [H(memory_leak_0011_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.029s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N74): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N81
On edge  : N81 -{Return edge from memory_leak_0011_bad to main}-> N79
Message  : the heap object @H(memory_leak_0011_bad::call) is not referenced any more
> Start from entry function: main, At N74 of Function main
> Entering function: memory_leak_0011_good, On N77 -> N104 (call memory_leak_0011_good)
> takes the false branch, At N115 of Function memory_leak_0011_good
> Leaving function: memory_leak_0011_good, On N103 -> N78 (Return edge from memory_leak_0011_good to main)
> Entering function: memory_leak_0011_bad, On N78 -> N82 (call memory_leak_0011_bad)
> takes the true branch, At N92 of Function memory_leak_0011_bad
<Defect> : N81 -> N79: [Return edge from memory_leak_0011_bad to main]
N81 -> N79: [Return edge from memory_leak_0011_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_11.c 64] memory_leak_0011_bad 		[N81 -{Return edge from memory_leak_0011_bad to main}-> N79]	(the heap object @H(memory_leak_0011_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0012_good]
 +memory_leak_0012_good
SCC(1): [memory_leak_0012_bad]
 +memory_leak_0012_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_0012_bad, memory_leak_0012_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0012_bad::call), H(memory_leak_0012_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0012_bad
P+ = [] 
P- = [H(memory_leak_0012_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_0012_good
P+ = [] 
P- = [H(memory_leak_0012_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.03s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N141): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N148
On edge  : N148 -{Return edge from memory_leak_0012_bad to main}-> N146
Message  : the heap object @H(memory_leak_0012_bad::call1) is not referenced any more
> Start from entry function: main, At N141 of Function main
> Entering function: memory_leak_0012_good, On N144 -> N179 (call memory_leak_0012_good)
> takes the false branch, At N192 of Function memory_leak_0012_good
> Leaving function: memory_leak_0012_good, On N178 -> N145 (Return edge from memory_leak_0012_good to main)
> Entering function: memory_leak_0012_bad, On N145 -> N149 (call memory_leak_0012_bad)
> takes the false branch, At N158 of Function memory_leak_0012_bad
<Defect> : N148 -> N146: [Return edge from memory_leak_0012_bad to main]
N148 -> N146: [Return edge from memory_leak_0012_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_12.c 77] memory_leak_0012_bad 		[N148 -{Return edge from memory_leak_0012_bad to main}-> N146]	(the heap object @H(memory_leak_0012_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0013_good]
 +memory_leak_0013_good
SCC(1): [memory_leak_0013_bad]
 +memory_leak_0013_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_0013_good, main, memory_leak_0013_bad]
Loops     []
----
function: main
P+ = [H(memory_leak_0013_bad::call1), H(memory_leak_0013_good::call1)] 
P- = [H(memory_leak_0013_bad::call), H(memory_leak_0013_bad::call1), H(memory_leak_0013_good::call), H(memory_leak_0013_good::call1)] 
Point-To:
H(memory_leak_0013_bad::call) -> [H(memory_leak_0013_bad::call1)]
H(memory_leak_0013_good::call) -> [N, H(memory_leak_0013_good::call1)]
Ret-Value: R
----
function: memory_leak_0013_bad
P+ = [H(memory_leak_0013_bad::call1)] 
P- = [H(memory_leak_0013_bad::call), H(memory_leak_0013_bad::call1)] 
Point-To:
H(memory_leak_0013_bad::call) -> [H(memory_leak_0013_bad::call1)]
Ret-Value: 
----
function: memory_leak_0013_good
P+ = [H(memory_leak_0013_good::call1)] 
P- = [H(memory_leak_0013_good::call), H(memory_leak_0013_good::call1)] 
Point-To:
H(memory_leak_0013_good::call) -> [N, H(memory_leak_0013_good::call1)]
Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.061s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N206): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N286
On edge  : N286 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N287
Message  : null pointer dereference
> Start from entry function: main, At N206 of Function main
> Entering function: memory_leak_0013_good, On N209 -> N260 (call memory_leak_0013_good)
> takes the true branch, At N269 of Function memory_leak_0013_good
> takes the true branch, At N280 of Function memory_leak_0013_good
<Defect> : N286 -> N287: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0]
N286 -> N287: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N242
On edge  : N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243
Message  : null pointer dereference
> Start from entry function: main, At N206 of Function main
> Entering function: memory_leak_0013_good, On N209 -> N260 (call memory_leak_0013_good)
> takes the false branch, At N269 of Function memory_leak_0013_good
> takes the false branch, At N280 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N259 -> N210 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N210 -> N214 (call memory_leak_0013_bad)
> takes the true branch, At N223 of Function memory_leak_0013_bad
> takes the true branch, At N236 of Function memory_leak_0013_bad
<Defect> : N242 -> N243: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0]
N242 -> N243: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N213
On edge  : N213 -{Return edge from memory_leak_0013_bad to main}-> N211
Message  : the heap object @H(memory_leak_0013_bad::call2) is not referenced any more
> Start from entry function: main, At N206 of Function main
> Entering function: memory_leak_0013_good, On N209 -> N260 (call memory_leak_0013_good)
> takes the false branch, At N269 of Function memory_leak_0013_good
> takes the false branch, At N280 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N259 -> N210 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N210 -> N214 (call memory_leak_0013_bad)
> takes the false branch, At N223 of Function memory_leak_0013_bad
> takes the false branch, At N236 of Function memory_leak_0013_bad
<Defect> : N213 -> N211: [Return edge from memory_leak_0013_bad to main]
N213 -> N211: [Return edge from memory_leak_0013_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_13.c 74] memory_leak_0013_good 		[N286 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N287]	(null pointer dereference)
	[./401_memory_leak_13.c 51] memory_leak_0013_bad 		[N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_13.c 89] memory_leak_0013_bad 		[N213 -{Return edge from memory_leak_0013_bad to main}-> N211]	(the heap object @H(memory_leak_0013_bad::call2) is not referenced any more)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0014_bad]
 +memory_leak_0014_bad
SCC(1): [memory_leak_0014_good]
 +memory_leak_0014_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_0014_good, main, memory_leak_0014_bad]
Loops     []
----
function: main
P+ = [] 
P- = [N, H(memory_leak_0014_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0014_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_0014_good
P+ = [] 
P- = [N, H(memory_leak_0014_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.051s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N307): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N388
On edge  : N388 -{call void @free(i8* %10, i8* @free)}-> N389
Message  : null pointer dereference
> Start from entry function: main, At N307 of Function main
> Entering function: memory_leak_0014_good, On N310 -> N353 (call memory_leak_0014_good)
> takes the false branch, At N374 of Function memory_leak_0014_good
<Defect> : N388 -> N389: [call void @free(i8* %10, i8* @free)]
N388 -> N389: [call void @free(i8* %10, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N314
On edge  : N314 -{Return edge from memory_leak_0014_bad to main}-> N312
Message  : the heap object @H(memory_leak_0014_bad::call) is not referenced any more
> Start from entry function: main, At N307 of Function main
> Entering function: memory_leak_0014_good, On N310 -> N353 (call memory_leak_0014_good)
> takes the false branch, At N374 of Function memory_leak_0014_good
> Leaving function: memory_leak_0014_good, On N352 -> N311 (Return edge from memory_leak_0014_good to main)
> Entering function: memory_leak_0014_bad, On N311 -> N315 (call memory_leak_0014_bad)
> takes the true branch, At N336 of Function memory_leak_0014_bad
<Defect> : N314 -> N312: [Return edge from memory_leak_0014_bad to main]
N314 -> N312: [Return edge from memory_leak_0014_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_14.c 59] memory_leak_0014_good 		[N388 -{call void @free(i8* %10, i8* @free)}-> N389]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_14.c 71] memory_leak_0014_bad 		[N314 -{Return edge from memory_leak_0014_bad to main}-> N312]	(the heap object @H(memory_leak_0014_bad::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_0015_func_001_good]
 +memory_leak_0015_func_001_good
SCC(1): [memory_leak_0015_good]
 +memory_leak_0015_good
SCC(1): [memory_leak_0015_func_001_bad]
 +memory_leak_0015_func_001_bad
SCC(1): [memory_leak_0015_bad]
 +memory_leak_0015_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_0015_bad, memory_leak_0015_func_001_bad, memory_leak_0015_func_001_good, memory_leak_0015_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0015_func_001_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0015_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_0015_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: H(memory_leak_0015_func_001_bad::call)
----
function: memory_leak_0015_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: H(memory_leak_0015_func_001_good::call)
----
function: memory_leak_0015_good
P+ = [] 
P- = [H(memory_leak_0015_func_001_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.061s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N394): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N401
On edge  : N401 -{Return edge from memory_leak_0015_bad to main}-> N399
Message  : the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N394 of Function main
> Entering function: memory_leak_0015_good, On N397 -> N457 (call memory_leak_0015_good)
> Entering function: memory_leak_0015_func_001_good, On N466 -> N441 (call memory_leak_0015_func_001_good)
> Leaving function: memory_leak_0015_func_001_good, On N440 -> N467 (Return edge from memory_leak_0015_func_001_good to memory_leak_0015_good)
> takes the false branch, At N470 of Function memory_leak_0015_good
> Leaving function: memory_leak_0015_good, On N456 -> N398 (Return edge from memory_leak_0015_good to main)
> Entering function: memory_leak_0015_bad, On N398 -> N402 (call memory_leak_0015_bad)
> Entering function: memory_leak_0015_func_001_bad, On N411 -> N425 (call memory_leak_0015_func_001_bad)
> Leaving function: memory_leak_0015_func_001_bad, On N424 -> N412 (Return edge from memory_leak_0015_func_001_bad to memory_leak_0015_bad)
> takes the true branch, At N415 of Function memory_leak_0015_bad
<Defect> : N401 -> N399: [Return edge from memory_leak_0015_bad to main]
N401 -> N399: [Return edge from memory_leak_0015_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_15.c 63] memory_leak_0015_bad 		[N401 -{Return edge from memory_leak_0015_bad to main}-> N399]	(the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_001_good]
 +memory_leak_001_good
SCC(1): [memory_leak_001_bad]
 +memory_leak_001_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_001_bad, memory_leak_001_good]
Loops     [N498, N529]
----
function: main
P+ = [] 
P- = [H(memory_leak_001_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_001_good
P+ = [] 
P- = [H(memory_leak_001_good::call)] 
Point-To:

Ret-Value: 
----
loop N498 in memory_leak_001_bad: 
N498 -> P+ = [H(memory_leak_001_bad::call)], P- = [] Point-To: L(memory_leak_001_bad::buf) -> [H(memory_leak_001_bad::call)]
N500 -> P+ = [H(memory_leak_001_bad::call)], P- = [] Point-To: L(memory_leak_001_bad::buf) -> [H(memory_leak_001_bad::call)]
----
loop N529 in memory_leak_001_good: 
N529 -> P+ = [H(memory_leak_001_good::call)], P- = [H(memory_leak_001_good::call)] Point-To: L(memory_leak_001_good::buf) -> [H(memory_leak_001_good::call)]
N531 -> P+ = [H(memory_leak_001_good::call)], P- = [H(memory_leak_001_good::call)] Point-To: L(memory_leak_001_good::buf) -> [H(memory_leak_001_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.082s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N483): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N507
On edge  : N507 -{%arrayidx = getelementptr inbounds i8, i8* %2, i64 0}-> N508
Message  : null pointer dereference
> Start from entry function: main, At N483 of Function main
> Entering function: memory_leak_001_good, On N486 -> N522 (call memory_leak_001_good)
> takes the false branch, At N531 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N521 -> N487 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N487 -> N491 (call memory_leak_001_bad)
> takes the true branch, At N500 of Function memory_leak_001_bad
> takes the false branch, At N505 of Function memory_leak_001_bad
> takes the true branch, At N500 of Function memory_leak_001_bad
> takes the true branch, At N505 of Function memory_leak_001_bad
<Defect> : N507 -> N508: [%arrayidx = getelementptr inbounds i8, i8* %2, i64 0]
N507 -> N508: [%arrayidx = getelementptr inbounds i8, i8* %2, i64 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N508
On edge  : N508 -{store i8 1, i8* %arrayidx, align 1}-> N511
Message  : null pointer dereference
> Start from entry function: main, At N483 of Function main
> Entering function: memory_leak_001_good, On N486 -> N522 (call memory_leak_001_good)
> takes the false branch, At N531 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N521 -> N487 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N487 -> N491 (call memory_leak_001_bad)
> takes the true branch, At N500 of Function memory_leak_001_bad
> takes the false branch, At N505 of Function memory_leak_001_bad
> takes the true branch, At N500 of Function memory_leak_001_bad
> takes the true branch, At N505 of Function memory_leak_001_bad
<Defect> : N508 -> N511: [store i8 1, i8* %arrayidx, align 1]
N508 -> N511: [store i8 1, i8* %arrayidx, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N490
On edge  : N490 -{Return edge from memory_leak_001_bad to main}-> N488
Message  : the heap object @H(memory_leak_001_bad::call) is not referenced any more
> Start from entry function: main, At N483 of Function main
> Entering function: memory_leak_001_good, On N486 -> N522 (call memory_leak_001_good)
> takes the false branch, At N531 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N521 -> N487 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N487 -> N491 (call memory_leak_001_bad)
> takes the true branch, At N500 of Function memory_leak_001_bad
> takes the true branch, At N505 of Function memory_leak_001_bad
> takes the false branch, At N500 of Function memory_leak_001_bad
<Defect> : N490 -> N488: [Return edge from memory_leak_001_bad to main]
N490 -> N488: [Return edge from memory_leak_001_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_1.c 26] memory_leak_001_bad 		[N507 -{%arrayidx = getelementptr inbounds i8, i8* %2, i64 0}-> N508]	(null pointer dereference)
	[./401_memory_leak_1.c 26] memory_leak_001_bad 		[N508 -{store i8 1, i8* %arrayidx, align 1}-> N511]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_1.c 58] memory_leak_001_bad 		[N490 -{Return edge from memory_leak_001_bad to main}-> N488]	(the heap object @H(memory_leak_001_bad::call) is not referenced any more)

Found 3 defects in all (38 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_002_good]
 +memory_leak_002_good
SCC(1): [memory_leak_002_bad]
 +memory_leak_002_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_002_bad, memory_leak_002_good]
Loops     [N621, N699, N728, N580, N680]
----
function: main
P+ = [H(memory_leak_002_bad::call2), H(memory_leak_002_good::call2)] 
P- = [H(memory_leak_002_bad::call), H(memory_leak_002_good::call), H(memory_leak_002_good::call2)] 
Point-To:
H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]
H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]
Ret-Value: R
----
function: memory_leak_002_bad
P+ = [H(memory_leak_002_bad::call2)] 
P- = [H(memory_leak_002_bad::call)] 
Point-To:
H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]
Ret-Value: 
----
function: memory_leak_002_good
P+ = [H(memory_leak_002_good::call2)] 
P- = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)] 
Point-To:
H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]
Ret-Value: 
----
loop N580 in memory_leak_002_bad: 
N580 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
N596 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
N582 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
----
loop N621 in memory_leak_002_bad: 
N607 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
N610 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
----
loop N680 in memory_leak_002_good: 
N680 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N696 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N682 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
----
loop N699 in memory_leak_002_good: 
N699 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N702 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
----
loop N728 in memory_leak_002_good: 
N728 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N731 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.037s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N555): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N758
On edge  : N758 -{call void @free(i8* %31, i8* @free)}-> N760
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
<Defect> : N758 -> N760: [call void @free(i8* %31, i8* @free)]
N758 -> N760: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N709
On edge  : N709 -{call void @free(i8* %14, i8* @free)}-> N711
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N702 of Function memory_leak_002_good
<Defect> : N709 -> N711: [call void @free(i8* %14, i8* @free)]
N709 -> N711: [call void @free(i8* %14, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N709
On edge  : N709 -{call void @free(i8* %14, i8* @free)}-> N711
Message  : null pointer dereference
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N702 of Function memory_leak_002_good
<Defect> : N709 -> N711: [call void @free(i8* %14, i8* @free)]
N709 -> N711: [call void @free(i8* %14, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N746
On edge  : N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
<Defect> : N746 -> N748: [store i32 %22, i32* %add.ptr23, align 4]
N746 -> N748: [store i32 %22, i32* %add.ptr23, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N758
On edge  : N758 -{call void @free(i8* %31, i8* @free)}-> N760
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
<Defect> : N758 -> N760: [call void @free(i8* %31, i8* @free)]
N758 -> N760: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N709
On edge  : N709 -{call void @free(i8* %14, i8* @free)}-> N711
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N702 of Function memory_leak_002_good
<Defect> : N709 -> N711: [call void @free(i8* %14, i8* @free)]
N709 -> N711: [call void @free(i8* %14, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N633
On edge  : N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the false branch, At N582 of Function memory_leak_002_bad
> takes the true branch, At N610 of Function memory_leak_002_bad
> takes the false branch, At N617 of Function memory_leak_002_bad
> takes the true branch, At N623 of Function memory_leak_002_bad
<Defect> : N633 -> N635: [store i32 %16, i32* %add.ptr20, align 4]
N633 -> N635: [store i32 %16, i32* %add.ptr20, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N562
On edge  : N562 -{Return edge from memory_leak_002_bad to main}-> N560
Message  : the heap object @H(memory_leak_002_bad::call) is not referenced any more
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the true branch, At N596 of Function memory_leak_002_bad
<Defect> : N562 -> N560: [Return edge from memory_leak_002_bad to main]
N562 -> N560: [Return edge from memory_leak_002_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N560
On edge  : N560 -{ret i32 0}-> N554
Message  : the heap object @H(memory_leak_002_good::call2) is not referenced any more
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the true branch, At N596 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N562 -> N560 (Return edge from memory_leak_002_bad to main)
<Defect> : N560 -> N554: [ret i32 0]
N560 -> N554: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N560
On edge  : N560 -{ret i32 0}-> N554
Message  : the heap object @H(memory_leak_002_bad::call2) is not referenced any more
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the false branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N610 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N562 -> N560 (Return edge from memory_leak_002_bad to main)
<Defect> : N560 -> N554: [ret i32 0]
N560 -> N554: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 2
	[401_memory_leak_2.c 70] memory_leak_002_good 		[N758 -{call void @free(i8* %31, i8* @free)}-> N760]	(the memory is already freed)
	[401_memory_leak_2.c 57] memory_leak_002_good 		[N709 -{call void @free(i8* %14, i8* @free)}-> N711]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[401_memory_leak_2.c 57] memory_leak_002_good 		[N709 -{call void @free(i8* %14, i8* @free)}-> N711]	(null pointer dereference)

CWE_416(Use After Free): 4
	[401_memory_leak_2.c 68] memory_leak_002_good 		[N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748]	(the memory is already freed)
	[401_memory_leak_2.c 70] memory_leak_002_good 		[N758 -{call void @free(i8* %31, i8* @free)}-> N760]	(the memory is already freed)
	[401_memory_leak_2.c 57] memory_leak_002_good 		[N709 -{call void @free(i8* %14, i8* @free)}-> N711]	(the memory is already freed)
	[401_memory_leak_2.c 36] memory_leak_002_bad 		[N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635]	(the memory is already freed)

CWE_401(Memory Leak): 3
	[401_memory_leak_2.c 83] memory_leak_002_bad 		[N562 -{Return edge from memory_leak_002_bad to main}-> N560]	(the heap object @H(memory_leak_002_bad::call) is not referenced any more)
	[401_memory_leak_2.c 84] main 		[N560 -{ret i32 0}-> N554]	(the heap object @H(memory_leak_002_good::call2) is not referenced any more)
	[401_memory_leak_2.c 84] main 		[N560 -{ret i32 0}-> N554]	(the heap object @H(memory_leak_002_bad::call2) is not referenced any more)

Found 10 defects in all (405 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :3
Actual   :2
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_401_Test.lambda$itc_401_bit_2$1(AP_ITC_401_Test.java:58)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_401_Test.itc_401_bit_2(AP_ITC_401_Test.java:57)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_003_func_001_good]
 +memory_leak_003_func_001_good
SCC(1): [memory_leak_003_good]
 +memory_leak_003_good
SCC(1): [memory_leak_003_func_001_bad]
 +memory_leak_003_func_001_bad
SCC(1): [memory_leak_003_bad]
 +memory_leak_003_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_003_bad, memory_leak_003_func_001_bad, memory_leak_003_func_001_good, memory_leak_003_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_003_func_001_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_003_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_003_func_001_bad
P+ = [H(memory_leak_003_func_001_bad::call)] 
P- = [] 
Point-To:
P(memory_leak_003_func_001_bad::stringPtr) -> [H(memory_leak_003_func_001_bad::call)]
Ret-Value: 
----
function: memory_leak_003_func_001_good
P+ = [H(memory_leak_003_func_001_good::call)] 
P- = [] 
Point-To:
P(memory_leak_003_func_001_good::stringPtr) -> [H(memory_leak_003_func_001_good::call)]
Ret-Value: 
----
function: memory_leak_003_good
P+ = [] 
P- = [H(memory_leak_003_func_001_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N783): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N873
On edge  : N873 -{%1 = load i8*, i8** %str1, align 8}-> N874
Message  : use of uninitialized variable
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N873 -> N874: [%1 = load i8*, i8** %str1, align 8]
N873 -> N874: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N876
On edge  : N876 -{%3 = load i8*, i8** %str1, align 8}-> N877
Message  : use of uninitialized variable
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N876 -> N877: [%3 = load i8*, i8** %str1, align 8]
N876 -> N877: [%3 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N801
On edge  : N801 -{%1 = load i8*, i8** %str1, align 8}-> N802
Message  : use of uninitialized variable
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N862 -> N787 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N787 -> N791 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N800 -> N807 (call memory_leak_003_func_001_bad)
> takes the true branch, At N824 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N806 -> N801 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N801 -> N802: [%1 = load i8*, i8** %str1, align 8]
N801 -> N802: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N790
On edge  : N790 -{Return edge from memory_leak_003_bad to main}-> N788
Message  : the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N862 -> N787 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N787 -> N791 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N800 -> N807 (call memory_leak_003_func_001_bad)
> takes the false branch, At N824 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N806 -> N801 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N790 -> N788: [Return edge from memory_leak_003_bad to main]
N790 -> N788: [Return edge from memory_leak_003_bad to main] <--
-- end of trace --
=====================================================
CWE_457(Use of Uninitialized Variable): 3
	[./401_memory_leak_3.c 55] memory_leak_003_good 		[N873 -{%1 = load i8*, i8** %str1, align 8}-> N874]	(use of uninitialized variable)
	[./401_memory_leak_3.c 56] memory_leak_003_good 		[N876 -{%3 = load i8*, i8** %str1, align 8}-> N877]	(use of uninitialized variable)
	[./401_memory_leak_3.c 33] memory_leak_003_bad 		[N801 -{%1 = load i8*, i8** %str1, align 8}-> N802]	(use of uninitialized variable)

CWE_401(Memory Leak): 1
	[./401_memory_leak_3.c 67] memory_leak_003_bad 		[N790 -{Return edge from memory_leak_003_bad to main}-> N788]	(the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more)

Found 4 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_004_bad]
 +memory_leak_004_bad
SCC(1): [memory_leak_004_good]
 +memory_leak_004_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_004_bad, memory_leak_004_good]
Loops     [N910, N1044, N943, N989, N1010]
----
function: main
P+ = [H(memory_leak_004_bad::call4), H(memory_leak_004_good::call4)] 
P- = [H(memory_leak_004_bad::call), H(memory_leak_004_good::call), H(memory_leak_004_good::call4)] 
Point-To:
H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]
H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]
Ret-Value: R
----
function: memory_leak_004_bad
P+ = [H(memory_leak_004_bad::call4)] 
P- = [H(memory_leak_004_bad::call)] 
Point-To:
H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]
Ret-Value: 
----
function: memory_leak_004_good
P+ = [H(memory_leak_004_good::call4)] 
P- = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)] 
Point-To:
H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]
Ret-Value: 
----
loop N910 in memory_leak_004_bad: 
N910 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
N927 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
N912 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
----
loop N943 in memory_leak_004_bad: 
N943 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
N945 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
----
loop N989 in memory_leak_004_good: 
N989 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N1006 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N991 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
----
loop N1010 in memory_leak_004_good: 
N1010 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N1013 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
----
loop N1044 in memory_leak_004_good: 
N1044 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N1046 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.021s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N882): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1053
On edge  : N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
Message  : the memory is already freed
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
<Defect> : N1053 -> N1055: [call void @free(i8* %24, i8* @free)]
N1053 -> N1055: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N1020
On edge  : N1020 -{call void @free(i8* %13, i8* @free)}-> N1022
Message  : the memory is already freed
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N1013 of Function memory_leak_004_good
<Defect> : N1020 -> N1022: [call void @free(i8* %13, i8* @free)]
N1020 -> N1022: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1053
On edge  : N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
Message  : null pointer dereference
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
<Defect> : N1053 -> N1055: [call void @free(i8* %24, i8* @free)]
N1053 -> N1055: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1020
On edge  : N1020 -{call void @free(i8* %13, i8* @free)}-> N1022
Message  : null pointer dereference
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N1013 of Function memory_leak_004_good
<Defect> : N1020 -> N1022: [call void @free(i8* %13, i8* @free)]
N1020 -> N1022: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1039
On edge  : N1039 -{%19 = load i8*, i8** %buf22, align 8}-> N1040
Message  : use of uninitialized variable
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
<Defect> : N1039 -> N1040: [%19 = load i8*, i8** %buf22, align 8]
N1039 -> N1040: [%19 = load i8*, i8** %buf22, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N938
On edge  : N938 -{%11 = load i8*, i8** %buf13, align 8}-> N939
Message  : use of uninitialized variable
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1046 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N967 -> N886 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N886 -> N890 (call memory_leak_004_bad)
> takes the false branch, At N900 of Function memory_leak_004_bad
> takes the true branch, At N907 of Function memory_leak_004_bad
> takes the false branch, At N912 of Function memory_leak_004_bad
<Defect> : N938 -> N939: [%11 = load i8*, i8** %buf13, align 8]
N938 -> N939: [%11 = load i8*, i8** %buf13, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1053
On edge  : N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
Message  : the memory is already freed
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
<Defect> : N1053 -> N1055: [call void @free(i8* %24, i8* @free)]
N1053 -> N1055: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1020
On edge  : N1020 -{call void @free(i8* %13, i8* @free)}-> N1022
Message  : the memory is already freed
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N1013 of Function memory_leak_004_good
<Defect> : N1020 -> N1022: [call void @free(i8* %13, i8* @free)]
N1020 -> N1022: [call void @free(i8* %13, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N889
On edge  : N889 -{Return edge from memory_leak_004_bad to main}-> N887
Message  : the heap object @H(memory_leak_004_bad::call) is not referenced any more
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1046 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N967 -> N886 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N886 -> N890 (call memory_leak_004_bad)
> takes the false branch, At N900 of Function memory_leak_004_bad
> takes the true branch, At N907 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the true branch, At N927 of Function memory_leak_004_bad
<Defect> : N889 -> N887: [Return edge from memory_leak_004_bad to main]
N889 -> N887: [Return edge from memory_leak_004_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N887
On edge  : N887 -{ret i32 0}-> N881
Message  : the heap object @H(memory_leak_004_good::call4) is not referenced any more
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1046 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N967 -> N886 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N886 -> N890 (call memory_leak_004_bad)
> takes the false branch, At N900 of Function memory_leak_004_bad
> takes the true branch, At N907 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the true branch, At N927 of Function memory_leak_004_bad
> Leaving function: memory_leak_004_bad, On N889 -> N887 (Return edge from memory_leak_004_bad to main)
<Defect> : N887 -> N881: [ret i32 0]
N887 -> N881: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N887
On edge  : N887 -{ret i32 0}-> N881
Message  : the heap object @H(memory_leak_004_bad::call4) is not referenced any more
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1046 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N967 -> N886 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N886 -> N890 (call memory_leak_004_bad)
> takes the false branch, At N900 of Function memory_leak_004_bad
> takes the true branch, At N907 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N927 of Function memory_leak_004_bad
> takes the false branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N945 of Function memory_leak_004_bad
> Leaving function: memory_leak_004_bad, On N889 -> N887 (Return edge from memory_leak_004_bad to main)
<Defect> : N887 -> N881: [ret i32 0]
N887 -> N881: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 2
	[401_memory_leak_4.c 78] memory_leak_004_good 		[N1053 -{call void @free(i8* %24, i8* @free)}-> N1055]	(the memory is already freed)
	[401_memory_leak_4.c 70] memory_leak_004_good 		[N1020 -{call void @free(i8* %13, i8* @free)}-> N1022]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 2
	[401_memory_leak_4.c 78] memory_leak_004_good 		[N1053 -{call void @free(i8* %24, i8* @free)}-> N1055]	(null pointer dereference)
	[401_memory_leak_4.c 70] memory_leak_004_good 		[N1020 -{call void @free(i8* %13, i8* @free)}-> N1022]	(null pointer dereference)

CWE_457(Use of Uninitialized Variable): 2
	[401_memory_leak_4.c 76] memory_leak_004_good 		[N1039 -{%19 = load i8*, i8** %buf22, align 8}-> N1040]	(use of uninitialized variable)
	[401_memory_leak_4.c 44] memory_leak_004_bad 		[N938 -{%11 = load i8*, i8** %buf13, align 8}-> N939]	(use of uninitialized variable)

CWE_416(Use After Free): 2
	[401_memory_leak_4.c 78] memory_leak_004_good 		[N1053 -{call void @free(i8* %24, i8* @free)}-> N1055]	(the memory is already freed)
	[401_memory_leak_4.c 70] memory_leak_004_good 		[N1020 -{call void @free(i8* %13, i8* @free)}-> N1022]	(the memory is already freed)

CWE_401(Memory Leak): 3
	[401_memory_leak_4.c 90] memory_leak_004_bad 		[N889 -{Return edge from memory_leak_004_bad to main}-> N887]	(the heap object @H(memory_leak_004_bad::call) is not referenced any more)
	[401_memory_leak_4.c 91] main 		[N887 -{ret i32 0}-> N881]	(the heap object @H(memory_leak_004_good::call4) is not referenced any more)
	[401_memory_leak_4.c 91] main 		[N887 -{ret i32 0}-> N881]	(the heap object @H(memory_leak_004_bad::call4) is not referenced any more)

Found 11 defects in all (128 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :3
Actual   :2
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_401_Test.lambda$itc_401_bit_4$3(AP_ITC_401_Test.java:82)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_401_Test.itc_401_bit_4(AP_ITC_401_Test.java:81)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_005_good]
 +memory_leak_005_good
SCC(1): [memory_leak_005_bad]
 +memory_leak_005_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_005_good, main, memory_leak_005_bad]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_005_bad::call), H(memory_leak_005_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_005_bad
P+ = [] 
P- = [H(memory_leak_005_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_005_good
P+ = [] 
P- = [H(memory_leak_005_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1079): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1112
On edge  : N1112 -{call void @free(i8* %6, i8* @free)}-> N1114
Message  : null pointer dereference
> Start from entry function: main, At N1079 of Function main
> Entering function: memory_leak_005_good, On N1082 -> N1123 (call memory_leak_005_good)
> takes the false branch, At N1131 of Function memory_leak_005_good
> Leaving function: memory_leak_005_good, On N1122 -> N1083 (Return edge from memory_leak_005_good to main)
> Entering function: memory_leak_005_bad, On N1083 -> N1087 (call memory_leak_005_bad)
> takes the false branch, At N1095 of Function memory_leak_005_bad
> takes the true branch, At N1109 of Function memory_leak_005_bad
<Defect> : N1112 -> N1114: [call void @free(i8* %6, i8* @free)]
N1112 -> N1114: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N1086
On edge  : N1086 -{Return edge from memory_leak_005_bad to main}-> N1084
Message  : the heap object @H(memory_leak_005_bad::call) is not referenced any more
> Start from entry function: main, At N1079 of Function main
> Entering function: memory_leak_005_good, On N1082 -> N1123 (call memory_leak_005_good)
> takes the false branch, At N1131 of Function memory_leak_005_good
> Leaving function: memory_leak_005_good, On N1122 -> N1083 (Return edge from memory_leak_005_good to main)
> Entering function: memory_leak_005_bad, On N1083 -> N1087 (call memory_leak_005_bad)
> takes the true branch, At N1095 of Function memory_leak_005_bad
> takes the true branch, At N1101 of Function memory_leak_005_bad
> takes the false branch, At N1109 of Function memory_leak_005_bad
<Defect> : N1086 -> N1084: [Return edge from memory_leak_005_bad to main]
N1086 -> N1084: [Return edge from memory_leak_005_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_5.c 31] memory_leak_005_bad 		[N1112 -{call void @free(i8* %6, i8* @free)}-> N1114]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_5.c 62] memory_leak_005_bad 		[N1086 -{Return edge from memory_leak_005_bad to main}-> N1084]	(the heap object @H(memory_leak_005_bad::call) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_006_func_001_good]
 +memory_leak_006_func_001_good
SCC(1): [memory_leak_006_good]
 +memory_leak_006_good
SCC(1): [memory_leak_006_func_001_bad]
 +memory_leak_006_func_001_bad
SCC(1): [memory_leak_006_bad]
 +memory_leak_006_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_006_bad, memory_leak_006_func_001_bad, memory_leak_006_func_001_good, memory_leak_006_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_006_bad::call1), H(memory_leak_006_good::call1)] 
Point-To:

Ret-Value: R
----
function: memory_leak_006_bad
P+ = [] 
P- = [H(memory_leak_006_bad::call1)] 
Point-To:

Ret-Value: 
----
function: memory_leak_006_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: memory_leak_006_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: memory_leak_006_good
P+ = [] 
P- = [H(memory_leak_006_good::call1)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1153): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1188
On edge  : N1188 -{call void @free(i8* %6, i8* @free)}-> N1190
Message  : null pointer dereference
> Start from entry function: main, At N1153 of Function main
> Entering function: memory_leak_006_good, On N1156 -> N1237 (call memory_leak_006_good)
> Entering function: memory_leak_006_func_001_good, On N1244 -> N1218 (call memory_leak_006_func_001_good)
> takes the false branch, At N1226 of Function memory_leak_006_func_001_good
> Leaving function: memory_leak_006_func_001_good, On N1217 -> N1245 (Return edge from memory_leak_006_func_001_good to memory_leak_006_good)
> takes the false branch, At N1246 of Function memory_leak_006_good
> Leaving function: memory_leak_006_good, On N1236 -> N1157 (Return edge from memory_leak_006_good to main)
> Entering function: memory_leak_006_bad, On N1157 -> N1161 (call memory_leak_006_bad)
> Entering function: memory_leak_006_func_001_bad, On N1168 -> N1199 (call memory_leak_006_func_001_bad)
> takes the false branch, At N1207 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N1198 -> N1169 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the false branch, At N1170 of Function memory_leak_006_bad
> Entering function: memory_leak_006_func_001_bad, On N1183 -> N1199 (call memory_leak_006_func_001_bad)
> takes the false branch, At N1207 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N1198 -> N1184 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the true branch, At N1185 of Function memory_leak_006_bad
<Defect> : N1188 -> N1190: [call void @free(i8* %6, i8* @free)]
N1188 -> N1190: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N1160
On edge  : N1160 -{Return edge from memory_leak_006_bad to main}-> N1158
Message  : the heap object @H(memory_leak_006_bad::call1) is not referenced any more
> Start from entry function: main, At N1153 of Function main
> Entering function: memory_leak_006_good, On N1156 -> N1237 (call memory_leak_006_good)
> Entering function: memory_leak_006_func_001_good, On N1244 -> N1218 (call memory_leak_006_func_001_good)
> takes the false branch, At N1226 of Function memory_leak_006_func_001_good
> Leaving function: memory_leak_006_func_001_good, On N1217 -> N1245 (Return edge from memory_leak_006_func_001_good to memory_leak_006_good)
> takes the false branch, At N1246 of Function memory_leak_006_good
> Leaving function: memory_leak_006_good, On N1236 -> N1157 (Return edge from memory_leak_006_good to main)
> Entering function: memory_leak_006_bad, On N1157 -> N1161 (call memory_leak_006_bad)
> Entering function: memory_leak_006_func_001_bad, On N1168 -> N1199 (call memory_leak_006_func_001_bad)
> takes the false branch, At N1207 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N1198 -> N1169 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the true branch, At N1170 of Function memory_leak_006_bad
> takes the true branch, At N1176 of Function memory_leak_006_bad
> Entering function: memory_leak_006_func_001_bad, On N1183 -> N1199 (call memory_leak_006_func_001_bad)
> takes the false branch, At N1207 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N1198 -> N1184 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the false branch, At N1185 of Function memory_leak_006_bad
<Defect> : N1160 -> N1158: [Return edge from memory_leak_006_bad to main]
N1160 -> N1158: [Return edge from memory_leak_006_bad to main] <--
-- end of trace --
=====================================================
CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_6.c 41] memory_leak_006_bad 		[N1188 -{call void @free(i8* %6, i8* @free)}-> N1190]	(null pointer dereference)

CWE_401(Memory Leak): 1
	[./401_memory_leak_6.c 82] memory_leak_006_bad 		[N1160 -{Return edge from memory_leak_006_bad to main}-> N1158]	(the heap object @H(memory_leak_006_bad::call1) is not referenced any more)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_007_func_001_bad]
 +memory_leak_007_func_001_bad
SCC(1): [memory_leak_007_bad]
 +memory_leak_007_bad
SCC(1): [memory_leak_007_func_001_good]
 +memory_leak_007_func_001_good
SCC(1): [memory_leak_007_good]
 +memory_leak_007_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_007_bad, memory_leak_007_func_001_bad, memory_leak_007_func_001_good, memory_leak_007_good]
Loops     []
----
function: main
P+ = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
P- = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
Point-To:
G(vptr_bad) -> [H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call8)]
G(vptr_good) -> [H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call8)]
Ret-Value: R
----
function: memory_leak_007_bad
P+ = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)] 
P- = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)] 
Point-To:
G(vptr_bad) -> [H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call8)]
Ret-Value: 
----
function: memory_leak_007_func_001_bad
P+ = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)] 
P- = [] 
Point-To:
G(vptr_bad) -> [H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call8)]
Ret-Value: R
----
function: memory_leak_007_func_001_good
P+ = [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
P- = [] 
Point-To:
G(vptr_good) -> [H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call8)]
Ret-Value: R
----
function: memory_leak_007_good
P+ = [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
P- = [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
Point-To:
G(vptr_good) -> [H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call8)]
Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.019s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1268): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1273
On edge  : N1273 -{ret i32 0}-> N1267
Message  : the heap object @H(memory_leak_007_func_001_bad::call2) is not referenced any more
> Start from entry function: main, At N1268 of Function main
> Entering function: memory_leak_007_good, On N1271 -> N1427 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N1431 -> N1363 (call memory_leak_007_func_001_good)
> matches the value of 1, At N1369 of Function memory_leak_007_func_001_good
> matches the value of 2, At N1415 of Function memory_leak_007_func_001_good
> takes the true branch, At N1388 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N1362 -> N1432 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N1435 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N1426 -> N1272 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N1272 -> N1276 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N1280 -> N1299 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N1305 of Function memory_leak_007_func_001_bad
> matches the value of 2, At N1351 of Function memory_leak_007_func_001_bad
> takes the true branch, At N1324 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N1298 -> N1281 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N1284 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N1275 -> N1273 (Return edge from memory_leak_007_bad to main)
<Defect> : N1273 -> N1267: [ret i32 0]
N1273 -> N1267: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N1273
On edge  : N1273 -{ret i32 0}-> N1267
Message  : the heap object @H(memory_leak_007_func_001_good::call2) is not referenced any more
> Start from entry function: main, At N1268 of Function main
> Entering function: memory_leak_007_good, On N1271 -> N1427 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N1431 -> N1363 (call memory_leak_007_func_001_good)
> matches the value of 1, At N1369 of Function memory_leak_007_func_001_good
> matches the value of 2, At N1415 of Function memory_leak_007_func_001_good
> takes the true branch, At N1388 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N1362 -> N1432 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N1435 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N1426 -> N1272 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N1272 -> N1276 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N1280 -> N1299 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N1305 of Function memory_leak_007_func_001_bad
> matches the value of 2, At N1351 of Function memory_leak_007_func_001_bad
> takes the true branch, At N1324 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N1298 -> N1281 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N1284 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N1275 -> N1273 (Return edge from memory_leak_007_bad to main)
<Defect> : N1273 -> N1267: [ret i32 0]
N1273 -> N1267: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N1273
On edge  : N1273 -{ret i32 0}-> N1267
Message  : the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1268 of Function main
> Entering function: memory_leak_007_good, On N1271 -> N1427 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N1431 -> N1363 (call memory_leak_007_func_001_good)
> matches the value of 1, At N1369 of Function memory_leak_007_func_001_good
> matches the value of 2, At N1415 of Function memory_leak_007_func_001_good
> takes the true branch, At N1388 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N1362 -> N1432 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N1435 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N1426 -> N1272 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N1272 -> N1276 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N1280 -> N1299 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N1305 of Function memory_leak_007_func_001_bad
> takes the true branch, At N1312 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N1298 -> N1281 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N1284 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N1275 -> N1273 (Return edge from memory_leak_007_bad to main)
<Defect> : N1273 -> N1267: [ret i32 0]
N1273 -> N1267: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N1273
On edge  : N1273 -{ret i32 0}-> N1267
Message  : the heap object @H(memory_leak_007_func_001_good::call) is not referenced any more
> Start from entry function: main, At N1268 of Function main
> Entering function: memory_leak_007_good, On N1271 -> N1427 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N1431 -> N1363 (call memory_leak_007_func_001_good)
> matches the value of 1, At N1369 of Function memory_leak_007_func_001_good
> takes the true branch, At N1376 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N1362 -> N1432 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the false branch, At N1435 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N1426 -> N1272 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N1272 -> N1276 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N1280 -> N1299 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N1305 of Function memory_leak_007_func_001_bad
> matches the value of 2, At N1351 of Function memory_leak_007_func_001_bad
> takes the true branch, At N1324 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N1298 -> N1281 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N1284 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N1275 -> N1273 (Return edge from memory_leak_007_bad to main)
<Defect> : N1273 -> N1267: [ret i32 0]
N1273 -> N1267: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 4
	[./401_memory_leak_7.c 129] main 		[N1273 -{ret i32 0}-> N1267]	(the heap object @H(memory_leak_007_func_001_bad::call2) is not referenced any more)
	[./401_memory_leak_7.c 129] main 		[N1273 -{ret i32 0}-> N1267]	(the heap object @H(memory_leak_007_func_001_good::call2) is not referenced any more)
	[./401_memory_leak_7.c 129] main 		[N1273 -{ret i32 0}-> N1267]	(the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more)
	[./401_memory_leak_7.c 129] main 		[N1273 -{ret i32 0}-> N1267]	(the heap object @H(memory_leak_007_func_001_good::call) is not referenced any more)

Found 4 defects in all (8 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :4
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_401_Test.lambda$itc_401_bit_7$6(AP_ITC_401_Test.java:118)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_401_Test.itc_401_bit_7(AP_ITC_401_Test.java:117)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_008_good]
 +memory_leak_008_good
SCC(1): [memory_leak_008_bad]
 +memory_leak_008_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_008_bad, memory_leak_008_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_008_bad::call), H(memory_leak_008_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_008_bad
P+ = [] 
P- = [H(memory_leak_008_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_008_good
P+ = [] 
P- = [H(memory_leak_008_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.022s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1452): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1459
On edge  : N1459 -{Return edge from memory_leak_008_bad to main}-> N1457
Message  : the heap object @H(memory_leak_008_bad::call1) is not referenced any more
> Start from entry function: main, At N1452 of Function main
> Entering function: memory_leak_008_good, On N1455 -> N1488 (call memory_leak_008_good)
> takes the false branch, At N1499 of Function memory_leak_008_good
> Leaving function: memory_leak_008_good, On N1487 -> N1456 (Return edge from memory_leak_008_good to main)
> Entering function: memory_leak_008_bad, On N1456 -> N1460 (call memory_leak_008_bad)
> takes the false branch, At N1473 of Function memory_leak_008_bad
<Defect> : N1459 -> N1457: [Return edge from memory_leak_008_bad to main]
N1459 -> N1457: [Return edge from memory_leak_008_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_8.c 54] memory_leak_008_bad 		[N1459 -{Return edge from memory_leak_008_bad to main}-> N1457]	(the heap object @H(memory_leak_008_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_009_good]
 +memory_leak_009_good
SCC(1): [memory_leak_009_bad]
 +memory_leak_009_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_009_bad, memory_leak_009_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_009_bad::call), H(memory_leak_009_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_009_bad
P+ = [] 
P- = [H(memory_leak_009_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_009_good
P+ = [] 
P- = [H(memory_leak_009_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1515): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1522
On edge  : N1522 -{Return edge from memory_leak_009_bad to main}-> N1520
Message  : the heap object @H(memory_leak_009_bad::call1) is not referenced any more
> Start from entry function: main, At N1515 of Function main
> Entering function: memory_leak_009_good, On N1518 -> N1552 (call memory_leak_009_good)
> takes the false branch, At N1563 of Function memory_leak_009_good
> Leaving function: memory_leak_009_good, On N1551 -> N1519 (Return edge from memory_leak_009_good to main)
> Entering function: memory_leak_009_bad, On N1519 -> N1523 (call memory_leak_009_bad)
> takes the false branch, At N1536 of Function memory_leak_009_bad
<Defect> : N1522 -> N1520: [Return edge from memory_leak_009_bad to main]
N1522 -> N1520: [Return edge from memory_leak_009_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_9.c 55] memory_leak_009_bad 		[N1522 -{Return edge from memory_leak_009_bad to main}-> N1520]	(the heap object @H(memory_leak_009_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 255
