/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=38812:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.AP_Juliet_415_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad1, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good1, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad1
P+ = [] 
P- = [H(bad1::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good1
P+ = [] 
P- = [H(good1::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad1::call), H(good1::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.303s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N53): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good1, On N101 -> N35 (call good1)
> takes the true branch, At N43 of Function good1
> Leaving function: good1, On N34 -> N55 (Return edge from good1 to main)
> Entering function: bad1, On N55 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N14
On edge  : N14 -{call void @free(i8* %2, i8* @free)}-> N16
Message  : the memory is already freed
> Start from entry function: main, At N53 of Function main
> Entering function: good1, On N101 -> N35 (call good1)
> takes the true branch, At N43 of Function good1
> Leaving function: good1, On N34 -> N55 (Return edge from good1 to main)
> Entering function: bad1, On N55 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N14 -> N16: [call void @free(i8* %2, i8* @free)]
N14 -> N16: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_1.c 62] bad1 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_1.c 62] bad1 		[N14 -{call void @free(i8* %2, i8* @free)}-> N16]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad2, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good2, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad2
P+ = [] 
P- = [H(bad2::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good2
P+ = [] 
P- = [H(good2::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad2::call), H(good2::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.094s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N163): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N124
On edge  : N124 -{call void @free(i8* %2, i8* @free)}-> N126
Message  : the memory is already freed
> Start from entry function: main, At N163 of Function main
> Entering function: good2, On N211 -> N145 (call good2)
> takes the true branch, At N153 of Function good2
> Leaving function: good2, On N144 -> N165 (Return edge from good2 to main)
> Entering function: bad2, On N165 -> N111 (call bad2)
> takes the false branch, At N119 of Function bad2
<Defect> : N124 -> N126: [call void @free(i8* %2, i8* @free)]
N124 -> N126: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N124
On edge  : N124 -{call void @free(i8* %2, i8* @free)}-> N126
Message  : the memory is already freed
> Start from entry function: main, At N163 of Function main
> Entering function: good2, On N211 -> N145 (call good2)
> takes the true branch, At N153 of Function good2
> Leaving function: good2, On N144 -> N165 (Return edge from good2 to main)
> Entering function: bad2, On N165 -> N111 (call bad2)
> takes the false branch, At N119 of Function bad2
<Defect> : N124 -> N126: [call void @free(i8* %2, i8* @free)]
N124 -> N126: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_2.c 67] bad2 		[N124 -{call void @free(i8* %2, i8* @free)}-> N126]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_2.c 67] bad2 		[N124 -{call void @free(i8* %2, i8* @free)}-> N126]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good3, main, printHexCharLine, printIntLine, printLine, printLongLine, bad3]
Loops     []
----
function: bad3
P+ = [] 
P- = [H(bad3::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good3
P+ = [] 
P- = [H(good3::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad3::call), H(good3::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.026s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N273): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N234
On edge  : N234 -{call void @free(i8* %2, i8* @free)}-> N236
Message  : the memory is already freed
> Start from entry function: main, At N273 of Function main
> Entering function: good3, On N321 -> N255 (call good3)
> takes the true branch, At N263 of Function good3
> Leaving function: good3, On N254 -> N275 (Return edge from good3 to main)
> Entering function: bad3, On N275 -> N221 (call bad3)
> takes the false branch, At N229 of Function bad3
<Defect> : N234 -> N236: [call void @free(i8* %2, i8* @free)]
N234 -> N236: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N234
On edge  : N234 -{call void @free(i8* %2, i8* @free)}-> N236
Message  : the memory is already freed
> Start from entry function: main, At N273 of Function main
> Entering function: good3, On N321 -> N255 (call good3)
> takes the true branch, At N263 of Function good3
> Leaving function: good3, On N254 -> N275 (Return edge from good3 to main)
> Entering function: bad3, On N275 -> N221 (call bad3)
> takes the false branch, At N229 of Function bad3
<Defect> : N234 -> N236: [call void @free(i8* %2, i8* @free)]
N234 -> N236: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_3.c 67] bad3 		[N234 -{call void @free(i8* %2, i8* @free)}-> N236]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_3.c 67] bad3 		[N234 -{call void @free(i8* %2, i8* @free)}-> N236]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsTrue, globalReturnsTrueOrFalse, good4, main, printHexCharLine, printIntLine, printLine, printLongLine, bad4, globalReturnsFalse]
Loops     []
----
function: bad4
P+ = [] 
P- = [H(bad4::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good4
P+ = [] 
P- = [H(good4::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad4::call), H(good4::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.052s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N383): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N344
On edge  : N344 -{call void @free(i8* %2, i8* @free)}-> N346
Message  : the memory is already freed
> Start from entry function: main, At N383 of Function main
> Entering function: good4, On N431 -> N365 (call good4)
> takes the true branch, At N373 of Function good4
> Leaving function: good4, On N364 -> N385 (Return edge from good4 to main)
> Entering function: bad4, On N385 -> N331 (call bad4)
> takes the false branch, At N339 of Function bad4
<Defect> : N344 -> N346: [call void @free(i8* %2, i8* @free)]
N344 -> N346: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N344
On edge  : N344 -{call void @free(i8* %2, i8* @free)}-> N346
Message  : the memory is already freed
> Start from entry function: main, At N383 of Function main
> Entering function: good4, On N431 -> N365 (call good4)
> takes the true branch, At N373 of Function good4
> Leaving function: good4, On N364 -> N385 (Return edge from good4 to main)
> Entering function: bad4, On N385 -> N331 (call bad4)
> takes the false branch, At N339 of Function bad4
<Defect> : N344 -> N346: [call void @free(i8* %2, i8* @free)]
N344 -> N346: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_4.c 70] bad4 		[N344 -{call void @free(i8* %2, i8* @free)}-> N346]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_4.c 70] bad4 		[N344 -{call void @free(i8* %2, i8* @free)}-> N346]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good5, main, printHexCharLine, printIntLine, printLine, printLongLine, bad5, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse]
Loops     []
----
function: bad5
P+ = [] 
P- = [N, H(bad5::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good5
P+ = [] 
P- = [H(good5::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad5::call), H(good5::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.051s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N517): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N461
On edge  : N461 -{call void @free(i8* %4, i8* @free)}-> N463
Message  : the memory is already freed
> Start from entry function: main, At N517 of Function main
> Entering function: good5, On N565 -> N486 (call good5)
> takes the true branch, At N492 of Function good5
> takes the true branch, At N497 of Function good5
> Leaving function: good5, On N485 -> N519 (Return edge from good5 to main)
> Entering function: bad5, On N519 -> N441 (call bad5)
> takes the false branch, At N447 of Function bad5
> takes the true branch, At N459 of Function bad5
<Defect> : N461 -> N463: [call void @free(i8* %4, i8* @free)]
N461 -> N463: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N461
On edge  : N461 -{call void @free(i8* %4, i8* @free)}-> N463
Message  : null pointer dereference
> Start from entry function: main, At N517 of Function main
> Entering function: good5, On N565 -> N486 (call good5)
> takes the true branch, At N492 of Function good5
> takes the true branch, At N497 of Function good5
> Leaving function: good5, On N485 -> N519 (Return edge from good5 to main)
> Entering function: bad5, On N519 -> N441 (call bad5)
> takes the false branch, At N447 of Function bad5
> takes the true branch, At N459 of Function bad5
<Defect> : N461 -> N463: [call void @free(i8* %4, i8* @free)]
N461 -> N463: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N461
On edge  : N461 -{call void @free(i8* %4, i8* @free)}-> N463
Message  : the memory is already freed
> Start from entry function: main, At N517 of Function main
> Entering function: good5, On N565 -> N486 (call good5)
> takes the true branch, At N492 of Function good5
> takes the true branch, At N497 of Function good5
> Leaving function: good5, On N485 -> N519 (Return edge from good5 to main)
> Entering function: bad5, On N519 -> N441 (call bad5)
> takes the false branch, At N447 of Function bad5
> takes the true branch, At N459 of Function bad5
<Defect> : N461 -> N463: [call void @free(i8* %4, i8* @free)]
N461 -> N463: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_5.c 70] bad5 		[N461 -{call void @free(i8* %4, i8* @free)}-> N463]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_5.c 70] bad5 		[N461 -{call void @free(i8* %4, i8* @free)}-> N463]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_5.c 70] bad5 		[N461 -{call void @free(i8* %4, i8* @free)}-> N463]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good6, main, printHexCharLine, printIntLine, printLine, printLongLine, bad6, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse]
Loops     []
----
function: bad6
P+ = [] 
P- = [H(bad6::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good6
P+ = [] 
P- = [H(good6::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad6::call), H(good6::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N630): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N591
On edge  : N591 -{call void @free(i8* %2, i8* @free)}-> N593
Message  : the memory is already freed
> Start from entry function: main, At N630 of Function main
> Entering function: good6, On N678 -> N612 (call good6)
> takes the true branch, At N620 of Function good6
> Leaving function: good6, On N611 -> N632 (Return edge from good6 to main)
> Entering function: bad6, On N632 -> N578 (call bad6)
> takes the false branch, At N586 of Function bad6
<Defect> : N591 -> N593: [call void @free(i8* %2, i8* @free)]
N591 -> N593: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N591
On edge  : N591 -{call void @free(i8* %2, i8* @free)}-> N593
Message  : the memory is already freed
> Start from entry function: main, At N630 of Function main
> Entering function: good6, On N678 -> N612 (call good6)
> takes the true branch, At N620 of Function good6
> Leaving function: good6, On N611 -> N632 (Return edge from good6 to main)
> Entering function: bad6, On N632 -> N578 (call bad6)
> takes the false branch, At N586 of Function bad6
<Defect> : N591 -> N593: [call void @free(i8* %2, i8* @free)]
N591 -> N593: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_6.c 69] bad6 		[N591 -{call void @free(i8* %2, i8* @free)}-> N593]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_6.c 69] bad6 		[N591 -{call void @free(i8* %2, i8* @free)}-> N593]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad7, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good7]
Loops     []
----
function: bad7
P+ = [] 
P- = [N, H(bad7::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good7
P+ = [] 
P- = [H(good7::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad7::call), H(good7::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.039s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N764): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N708
On edge  : N708 -{call void @free(i8* %4, i8* @free)}-> N710
Message  : the memory is already freed
> Start from entry function: main, At N764 of Function main
> Entering function: good7, On N812 -> N733 (call good7)
> takes the true branch, At N739 of Function good7
> takes the true branch, At N744 of Function good7
> Leaving function: good7, On N732 -> N766 (Return edge from good7 to main)
> Entering function: bad7, On N766 -> N688 (call bad7)
> takes the false branch, At N694 of Function bad7
> takes the true branch, At N706 of Function bad7
<Defect> : N708 -> N710: [call void @free(i8* %4, i8* @free)]
N708 -> N710: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N708
On edge  : N708 -{call void @free(i8* %4, i8* @free)}-> N710
Message  : null pointer dereference
> Start from entry function: main, At N764 of Function main
> Entering function: good7, On N812 -> N733 (call good7)
> takes the true branch, At N739 of Function good7
> takes the true branch, At N744 of Function good7
> Leaving function: good7, On N732 -> N766 (Return edge from good7 to main)
> Entering function: bad7, On N766 -> N688 (call bad7)
> takes the false branch, At N694 of Function bad7
> takes the true branch, At N706 of Function bad7
<Defect> : N708 -> N710: [call void @free(i8* %4, i8* @free)]
N708 -> N710: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N708
On edge  : N708 -{call void @free(i8* %4, i8* @free)}-> N710
Message  : the memory is already freed
> Start from entry function: main, At N764 of Function main
> Entering function: good7, On N812 -> N733 (call good7)
> takes the true branch, At N739 of Function good7
> takes the true branch, At N744 of Function good7
> Leaving function: good7, On N732 -> N766 (Return edge from good7 to main)
> Entering function: bad7, On N766 -> N688 (call bad7)
> takes the false branch, At N694 of Function bad7
> takes the true branch, At N706 of Function bad7
<Defect> : N708 -> N710: [call void @free(i8* %4, i8* @free)]
N708 -> N710: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_7.c 69] bad7 		[N708 -{call void @free(i8* %4, i8* @free)}-> N710]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_7.c 69] bad7 		[N708 -{call void @free(i8* %4, i8* @free)}-> N710]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_7.c 69] bad7 		[N708 -{call void @free(i8* %4, i8* @free)}-> N710]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad8, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good8, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue]
Loops     []
----
function: bad8
P+ = [] 
P- = [N, H(bad8::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good8
P+ = [] 
P- = [H(good8::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad8::call1), H(good8::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N900): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N844
On edge  : N844 -{call void @free(i8* %2, i8* @free)}-> N846
Message  : the memory is already freed
> Start from entry function: main, At N900 of Function main
> Entering function: good8, On N956 -> N869 (call good8)
> Entering function: staticReturnsTrue, On N873 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N874 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N875 of Function good8
> takes the true branch, At N880 of Function good8
> Leaving function: good8, On N868 -> N902 (Return edge from good8 to main)
> Entering function: bad8, On N902 -> N824 (call bad8)
> Entering function: staticReturnsTrue, On N828 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N829 (Return edge from staticReturnsTrue to bad8)
> takes the false branch, At N830 of Function bad8
> Entering function: staticReturnsTrue, On N840 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N841 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N842 of Function bad8
<Defect> : N844 -> N846: [call void @free(i8* %2, i8* @free)]
N844 -> N846: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N844
On edge  : N844 -{call void @free(i8* %2, i8* @free)}-> N846
Message  : null pointer dereference
> Start from entry function: main, At N900 of Function main
> Entering function: good8, On N956 -> N869 (call good8)
> Entering function: staticReturnsTrue, On N873 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N874 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N875 of Function good8
> takes the true branch, At N880 of Function good8
> Leaving function: good8, On N868 -> N902 (Return edge from good8 to main)
> Entering function: bad8, On N902 -> N824 (call bad8)
> Entering function: staticReturnsTrue, On N828 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N829 (Return edge from staticReturnsTrue to bad8)
> takes the false branch, At N830 of Function bad8
> Entering function: staticReturnsTrue, On N840 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N841 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N842 of Function bad8
<Defect> : N844 -> N846: [call void @free(i8* %2, i8* @free)]
N844 -> N846: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N844
On edge  : N844 -{call void @free(i8* %2, i8* @free)}-> N846
Message  : the memory is already freed
> Start from entry function: main, At N900 of Function main
> Entering function: good8, On N956 -> N869 (call good8)
> Entering function: staticReturnsTrue, On N873 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N874 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N875 of Function good8
> takes the true branch, At N880 of Function good8
> Leaving function: good8, On N868 -> N902 (Return edge from good8 to main)
> Entering function: bad8, On N902 -> N824 (call bad8)
> Entering function: staticReturnsTrue, On N828 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N829 (Return edge from staticReturnsTrue to bad8)
> takes the false branch, At N830 of Function bad8
> Entering function: staticReturnsTrue, On N840 -> N953 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N952 -> N841 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N842 of Function bad8
<Defect> : N844 -> N846: [call void @free(i8* %2, i8* @free)]
N844 -> N846: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_8.c 77] bad8 		[N844 -{call void @free(i8* %2, i8* @free)}-> N846]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_8.c 77] bad8 		[N844 -{call void @free(i8* %2, i8* @free)}-> N846]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_8.c 77] bad8 		[N844 -{call void @free(i8* %2, i8* @free)}-> N846]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsTrueOrFalse, good9, main, printHexCharLine, printIntLine, printLine, printLongLine, bad9, globalReturnsFalse, globalReturnsTrue]
Loops     []
----
function: bad9
P+ = [] 
P- = [H(bad9::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good9
P+ = [] 
P- = [H(good9::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad9::call), H(good9::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.015s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1019): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N980
On edge  : N980 -{call void @free(i8* %2, i8* @free)}-> N982
Message  : the memory is already freed
> Start from entry function: main, At N1019 of Function main
> Entering function: good9, On N1067 -> N1001 (call good9)
> takes the true branch, At N1009 of Function good9
> Leaving function: good9, On N1000 -> N1021 (Return edge from good9 to main)
> Entering function: bad9, On N1021 -> N967 (call bad9)
> takes the false branch, At N975 of Function bad9
<Defect> : N980 -> N982: [call void @free(i8* %2, i8* @free)]
N980 -> N982: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N980
On edge  : N980 -{call void @free(i8* %2, i8* @free)}-> N982
Message  : the memory is already freed
> Start from entry function: main, At N1019 of Function main
> Entering function: good9, On N1067 -> N1001 (call good9)
> takes the true branch, At N1009 of Function good9
> Leaving function: good9, On N1000 -> N1021 (Return edge from good9 to main)
> Entering function: bad9, On N1021 -> N967 (call bad9)
> takes the false branch, At N975 of Function bad9
<Defect> : N980 -> N982: [call void @free(i8* %2, i8* @free)]
N980 -> N982: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_9.c 67] bad9 		[N980 -{call void @free(i8* %2, i8* @free)}-> N982]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_9.c 67] bad9 		[N980 -{call void @free(i8* %2, i8* @free)}-> N982]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad10, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good10, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad10
P+ = [] 
P- = [N, H(bad10::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good10
P+ = [] 
P- = [H(good10::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad10::call), H(good10::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1153): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1097
On edge  : N1097 -{call void @free(i8* %4, i8* @free)}-> N1099
Message  : the memory is already freed
> Start from entry function: main, At N1153 of Function main
> Entering function: good10, On N1201 -> N1122 (call good10)
> takes the true branch, At N1128 of Function good10
> takes the true branch, At N1133 of Function good10
> Leaving function: good10, On N1121 -> N1155 (Return edge from good10 to main)
> Entering function: bad10, On N1155 -> N1077 (call bad10)
> takes the false branch, At N1083 of Function bad10
> takes the true branch, At N1095 of Function bad10
<Defect> : N1097 -> N1099: [call void @free(i8* %4, i8* @free)]
N1097 -> N1099: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1097
On edge  : N1097 -{call void @free(i8* %4, i8* @free)}-> N1099
Message  : null pointer dereference
> Start from entry function: main, At N1153 of Function main
> Entering function: good10, On N1201 -> N1122 (call good10)
> takes the true branch, At N1128 of Function good10
> takes the true branch, At N1133 of Function good10
> Leaving function: good10, On N1121 -> N1155 (Return edge from good10 to main)
> Entering function: bad10, On N1155 -> N1077 (call bad10)
> takes the false branch, At N1083 of Function bad10
> takes the true branch, At N1095 of Function bad10
<Defect> : N1097 -> N1099: [call void @free(i8* %4, i8* @free)]
N1097 -> N1099: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1097
On edge  : N1097 -{call void @free(i8* %4, i8* @free)}-> N1099
Message  : the memory is already freed
> Start from entry function: main, At N1153 of Function main
> Entering function: good10, On N1201 -> N1122 (call good10)
> takes the true branch, At N1128 of Function good10
> takes the true branch, At N1133 of Function good10
> Leaving function: good10, On N1121 -> N1155 (Return edge from good10 to main)
> Entering function: bad10, On N1155 -> N1077 (call bad10)
> takes the false branch, At N1083 of Function bad10
> takes the true branch, At N1095 of Function bad10
<Defect> : N1097 -> N1099: [call void @free(i8* %4, i8* @free)]
N1097 -> N1099: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_10.c 67] bad10 		[N1097 -{call void @free(i8* %4, i8* @free)}-> N1099]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_10.c 67] bad10 		[N1097 -{call void @free(i8* %4, i8* @free)}-> N1099]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_10.c 67] bad10 		[N1097 -{call void @free(i8* %4, i8* @free)}-> N1099]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good11, main, printHexCharLine, printIntLine, printLine, printLongLine, bad11, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse]
Loops     []
----
function: bad11
P+ = [] 
P- = [H(bad11::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good11
P+ = [] 
P- = [H(good11::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad11::call), H(good11::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.041s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1269): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1228
On edge  : N1228 -{call void @free(i8* %5, i8* @free)}-> N1230
Message  : the memory is already freed
> Start from entry function: main, At N1269 of Function main
> Entering function: good11, On N1317 -> N1249 (call good11)
> takes the true branch, At N1258 of Function good11
> Leaving function: good11, On N1248 -> N1271 (Return edge from good11 to main)
> Entering function: bad11, On N1271 -> N1212 (call bad11)
> takes the false branch, At N1221 of Function bad11
<Defect> : N1228 -> N1230: [call void @free(i8* %5, i8* @free)]
N1228 -> N1230: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1228
On edge  : N1228 -{call void @free(i8* %5, i8* @free)}-> N1230
Message  : the memory is already freed
> Start from entry function: main, At N1269 of Function main
> Entering function: good11, On N1317 -> N1249 (call good11)
> takes the true branch, At N1258 of Function good11
> Leaving function: good11, On N1248 -> N1271 (Return edge from good11 to main)
> Entering function: bad11, On N1271 -> N1212 (call bad11)
> takes the false branch, At N1221 of Function bad11
<Defect> : N1228 -> N1230: [call void @free(i8* %5, i8* @free)]
N1228 -> N1230: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_11.c 62] bad11 		[N1228 -{call void @free(i8* %5, i8* @free)}-> N1230]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_11.c 62] bad11 		[N1228 -{call void @free(i8* %5, i8* @free)}-> N1230]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad12, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good12]
Loops     []
----
function: bad12
P+ = [] 
P- = [H(bad12::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good12
P+ = [] 
P- = [H(good12::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad12::call), H(good12::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1384): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1343
On edge  : N1343 -{call void @free(i8* %5, i8* @free)}-> N1345
Message  : the memory is already freed
> Start from entry function: main, At N1384 of Function main
> Entering function: good12, On N1432 -> N1364 (call good12)
> takes the true branch, At N1373 of Function good12
> Leaving function: good12, On N1363 -> N1386 (Return edge from good12 to main)
> Entering function: bad12, On N1386 -> N1327 (call bad12)
> takes the false branch, At N1336 of Function bad12
<Defect> : N1343 -> N1345: [call void @free(i8* %5, i8* @free)]
N1343 -> N1345: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1343
On edge  : N1343 -{call void @free(i8* %5, i8* @free)}-> N1345
Message  : the memory is already freed
> Start from entry function: main, At N1384 of Function main
> Entering function: good12, On N1432 -> N1364 (call good12)
> takes the true branch, At N1373 of Function good12
> Leaving function: good12, On N1363 -> N1386 (Return edge from good12 to main)
> Entering function: bad12, On N1386 -> N1327 (call bad12)
> takes the false branch, At N1336 of Function bad12
<Defect> : N1343 -> N1345: [call void @free(i8* %5, i8* @free)]
N1343 -> N1345: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_12.c 67] bad12 		[N1343 -{call void @free(i8* %5, i8* @free)}-> N1345]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_12.c 67] bad12 		[N1343 -{call void @free(i8* %5, i8* @free)}-> N1345]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printHexCharLine, printIntLine, printLine, printLongLine, bad13, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good13, main]
Loops     []
----
function: bad13
P+ = [] 
P- = [H(bad13::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good13
P+ = [] 
P- = [H(good13::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad13::call), H(good13::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1499): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1458
On edge  : N1458 -{call void @free(i8* %5, i8* @free)}-> N1460
Message  : the memory is already freed
> Start from entry function: main, At N1499 of Function main
> Entering function: good13, On N1547 -> N1479 (call good13)
> takes the true branch, At N1488 of Function good13
> Leaving function: good13, On N1478 -> N1501 (Return edge from good13 to main)
> Entering function: bad13, On N1501 -> N1442 (call bad13)
> takes the false branch, At N1451 of Function bad13
<Defect> : N1458 -> N1460: [call void @free(i8* %5, i8* @free)]
N1458 -> N1460: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1458
On edge  : N1458 -{call void @free(i8* %5, i8* @free)}-> N1460
Message  : the memory is already freed
> Start from entry function: main, At N1499 of Function main
> Entering function: good13, On N1547 -> N1479 (call good13)
> takes the true branch, At N1488 of Function good13
> Leaving function: good13, On N1478 -> N1501 (Return edge from good13 to main)
> Entering function: bad13, On N1501 -> N1442 (call bad13)
> takes the false branch, At N1451 of Function bad13
<Defect> : N1458 -> N1460: [call void @free(i8* %5, i8* @free)]
N1458 -> N1460: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_13.c 67] bad13 		[N1458 -{call void @free(i8* %5, i8* @free)}-> N1460]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_13.c 67] bad13 		[N1458 -{call void @free(i8* %5, i8* @free)}-> N1460]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad14, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good14, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad14
P+ = [] 
P- = [H(bad14::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good14
P+ = [] 
P- = [H(good14::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad14::call), H(good14::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.028s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1614): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1573
On edge  : N1573 -{call void @free(i8* %5, i8* @free)}-> N1575
Message  : the memory is already freed
> Start from entry function: main, At N1614 of Function main
> Entering function: good14, On N1662 -> N1594 (call good14)
> takes the true branch, At N1603 of Function good14
> Leaving function: good14, On N1593 -> N1616 (Return edge from good14 to main)
> Entering function: bad14, On N1616 -> N1557 (call bad14)
> takes the false branch, At N1566 of Function bad14
<Defect> : N1573 -> N1575: [call void @free(i8* %5, i8* @free)]
N1573 -> N1575: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1573
On edge  : N1573 -{call void @free(i8* %5, i8* @free)}-> N1575
Message  : the memory is already freed
> Start from entry function: main, At N1614 of Function main
> Entering function: good14, On N1662 -> N1594 (call good14)
> takes the true branch, At N1603 of Function good14
> Leaving function: good14, On N1593 -> N1616 (Return edge from good14 to main)
> Entering function: bad14, On N1616 -> N1557 (call bad14)
> takes the false branch, At N1566 of Function bad14
<Defect> : N1573 -> N1575: [call void @free(i8* %5, i8* @free)]
N1573 -> N1575: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_14.c 70] bad14 		[N1573 -{call void @free(i8* %5, i8* @free)}-> N1575]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_14.c 70] bad14 		[N1573 -{call void @free(i8* %5, i8* @free)}-> N1575]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad15, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good15, main, printHexCharLine]
Loops     []
----
function: bad15
P+ = [] 
P- = [N, H(bad15::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good15
P+ = [] 
P- = [H(good15::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad15::call), H(good15::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1753): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1695
On edge  : N1695 -{call void @free(i8* %7, i8* @free)}-> N1697
Message  : the memory is already freed
> Start from entry function: main, At N1753 of Function main
> Entering function: good15, On N1801 -> N1720 (call good15)
> takes the true branch, At N1726 of Function good15
> takes the true branch, At N1732 of Function good15
> Leaving function: good15, On N1719 -> N1755 (Return edge from good15 to main)
> Entering function: bad15, On N1755 -> N1672 (call bad15)
> takes the false branch, At N1678 of Function bad15
> takes the true branch, At N1692 of Function bad15
<Defect> : N1695 -> N1697: [call void @free(i8* %7, i8* @free)]
N1695 -> N1697: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1695
On edge  : N1695 -{call void @free(i8* %7, i8* @free)}-> N1697
Message  : null pointer dereference
> Start from entry function: main, At N1753 of Function main
> Entering function: good15, On N1801 -> N1720 (call good15)
> takes the true branch, At N1726 of Function good15
> takes the true branch, At N1732 of Function good15
> Leaving function: good15, On N1719 -> N1755 (Return edge from good15 to main)
> Entering function: bad15, On N1755 -> N1672 (call bad15)
> takes the false branch, At N1678 of Function bad15
> takes the true branch, At N1692 of Function bad15
<Defect> : N1695 -> N1697: [call void @free(i8* %7, i8* @free)]
N1695 -> N1697: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1695
On edge  : N1695 -{call void @free(i8* %7, i8* @free)}-> N1697
Message  : the memory is already freed
> Start from entry function: main, At N1753 of Function main
> Entering function: good15, On N1801 -> N1720 (call good15)
> takes the true branch, At N1726 of Function good15
> takes the true branch, At N1732 of Function good15
> Leaving function: good15, On N1719 -> N1755 (Return edge from good15 to main)
> Entering function: bad15, On N1755 -> N1672 (call bad15)
> takes the false branch, At N1678 of Function bad15
> takes the true branch, At N1692 of Function bad15
<Defect> : N1695 -> N1697: [call void @free(i8* %7, i8* @free)]
N1695 -> N1697: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_15.c 70] bad15 		[N1695 -{call void @free(i8* %7, i8* @free)}-> N1697]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_15.c 70] bad15 		[N1695 -{call void @free(i8* %7, i8* @free)}-> N1697]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_15.c 70] bad15 		[N1695 -{call void @free(i8* %7, i8* @free)}-> N1697]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_16.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad16, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good16, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad16
P+ = [] 
P- = [H(bad16::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good16
P+ = [] 
P- = [H(good16::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad16::call), H(good16::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.022s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1871): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1830
On edge  : N1830 -{call void @free(i8* %5, i8* @free)}-> N1832
Message  : the memory is already freed
> Start from entry function: main, At N1871 of Function main
> Entering function: good16, On N1919 -> N1851 (call good16)
> takes the true branch, At N1860 of Function good16
> Leaving function: good16, On N1850 -> N1873 (Return edge from good16 to main)
> Entering function: bad16, On N1873 -> N1814 (call bad16)
> takes the false branch, At N1823 of Function bad16
<Defect> : N1830 -> N1832: [call void @free(i8* %5, i8* @free)]
N1830 -> N1832: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1830
On edge  : N1830 -{call void @free(i8* %5, i8* @free)}-> N1832
Message  : the memory is already freed
> Start from entry function: main, At N1871 of Function main
> Entering function: good16, On N1919 -> N1851 (call good16)
> takes the true branch, At N1860 of Function good16
> Leaving function: good16, On N1850 -> N1873 (Return edge from good16 to main)
> Entering function: bad16, On N1873 -> N1814 (call bad16)
> takes the false branch, At N1823 of Function bad16
<Defect> : N1830 -> N1832: [call void @free(i8* %5, i8* @free)]
N1830 -> N1832: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_16.c 69] bad16 		[N1830 -{call void @free(i8* %5, i8* @free)}-> N1832]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_16.c 69] bad16 		[N1830 -{call void @free(i8* %5, i8* @free)}-> N1832]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_17.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad17, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good17, main, printHexCharLine]
Loops     []
----
function: bad17
P+ = [] 
P- = [N, H(bad17::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good17
P+ = [] 
P- = [H(good17::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad17::call), H(good17::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2010): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N1952
On edge  : N1952 -{call void @free(i8* %7, i8* @free)}-> N1954
Message  : the memory is already freed
> Start from entry function: main, At N2010 of Function main
> Entering function: good17, On N2058 -> N1977 (call good17)
> takes the true branch, At N1983 of Function good17
> takes the true branch, At N1989 of Function good17
> Leaving function: good17, On N1976 -> N2012 (Return edge from good17 to main)
> Entering function: bad17, On N2012 -> N1929 (call bad17)
> takes the false branch, At N1935 of Function bad17
> takes the true branch, At N1949 of Function bad17
<Defect> : N1952 -> N1954: [call void @free(i8* %7, i8* @free)]
N1952 -> N1954: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1952
On edge  : N1952 -{call void @free(i8* %7, i8* @free)}-> N1954
Message  : null pointer dereference
> Start from entry function: main, At N2010 of Function main
> Entering function: good17, On N2058 -> N1977 (call good17)
> takes the true branch, At N1983 of Function good17
> takes the true branch, At N1989 of Function good17
> Leaving function: good17, On N1976 -> N2012 (Return edge from good17 to main)
> Entering function: bad17, On N2012 -> N1929 (call bad17)
> takes the false branch, At N1935 of Function bad17
> takes the true branch, At N1949 of Function bad17
<Defect> : N1952 -> N1954: [call void @free(i8* %7, i8* @free)]
N1952 -> N1954: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1952
On edge  : N1952 -{call void @free(i8* %7, i8* @free)}-> N1954
Message  : the memory is already freed
> Start from entry function: main, At N2010 of Function main
> Entering function: good17, On N2058 -> N1977 (call good17)
> takes the true branch, At N1983 of Function good17
> takes the true branch, At N1989 of Function good17
> Leaving function: good17, On N1976 -> N2012 (Return edge from good17 to main)
> Entering function: bad17, On N2012 -> N1929 (call bad17)
> takes the false branch, At N1935 of Function bad17
> takes the true branch, At N1949 of Function bad17
<Defect> : N1952 -> N1954: [call void @free(i8* %7, i8* @free)]
N1952 -> N1954: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_17.c 69] bad17 		[N1952 -{call void @free(i8* %7, i8* @free)}-> N1954]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_17.c 69] bad17 		[N1952 -{call void @free(i8* %7, i8* @free)}-> N1954]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_17.c 69] bad17 		[N1952 -{call void @free(i8* %7, i8* @free)}-> N1954]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_18.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad18, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good18, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue]
Loops     []
----
function: bad18
P+ = [] 
P- = [N, H(bad18::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good18
P+ = [] 
P- = [H(good18::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad18::call1), H(good18::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2151): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2093
On edge  : N2093 -{call void @free(i8* %5, i8* @free)}-> N2095
Message  : the memory is already freed
> Start from entry function: main, At N2151 of Function main
> Entering function: good18, On N2207 -> N2118 (call good18)
> Entering function: staticReturnsTrue, On N2122 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2123 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N2124 of Function good18
> takes the true branch, At N2130 of Function good18
> Leaving function: good18, On N2117 -> N2153 (Return edge from good18 to main)
> Entering function: bad18, On N2153 -> N2070 (call bad18)
> Entering function: staticReturnsTrue, On N2074 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2075 (Return edge from staticReturnsTrue to bad18)
> takes the false branch, At N2076 of Function bad18
> Entering function: staticReturnsTrue, On N2088 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2089 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N2090 of Function bad18
<Defect> : N2093 -> N2095: [call void @free(i8* %5, i8* @free)]
N2093 -> N2095: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N2093
On edge  : N2093 -{call void @free(i8* %5, i8* @free)}-> N2095
Message  : null pointer dereference
> Start from entry function: main, At N2151 of Function main
> Entering function: good18, On N2207 -> N2118 (call good18)
> Entering function: staticReturnsTrue, On N2122 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2123 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N2124 of Function good18
> takes the true branch, At N2130 of Function good18
> Leaving function: good18, On N2117 -> N2153 (Return edge from good18 to main)
> Entering function: bad18, On N2153 -> N2070 (call bad18)
> Entering function: staticReturnsTrue, On N2074 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2075 (Return edge from staticReturnsTrue to bad18)
> takes the false branch, At N2076 of Function bad18
> Entering function: staticReturnsTrue, On N2088 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2089 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N2090 of Function bad18
<Defect> : N2093 -> N2095: [call void @free(i8* %5, i8* @free)]
N2093 -> N2095: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2093
On edge  : N2093 -{call void @free(i8* %5, i8* @free)}-> N2095
Message  : the memory is already freed
> Start from entry function: main, At N2151 of Function main
> Entering function: good18, On N2207 -> N2118 (call good18)
> Entering function: staticReturnsTrue, On N2122 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2123 (Return edge from staticReturnsTrue to good18)
> takes the true branch, At N2124 of Function good18
> takes the true branch, At N2130 of Function good18
> Leaving function: good18, On N2117 -> N2153 (Return edge from good18 to main)
> Entering function: bad18, On N2153 -> N2070 (call bad18)
> Entering function: staticReturnsTrue, On N2074 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2075 (Return edge from staticReturnsTrue to bad18)
> takes the false branch, At N2076 of Function bad18
> Entering function: staticReturnsTrue, On N2088 -> N2204 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2203 -> N2089 (Return edge from staticReturnsTrue to bad18)
> takes the true branch, At N2090 of Function bad18
<Defect> : N2093 -> N2095: [call void @free(i8* %5, i8* @free)]
N2093 -> N2095: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_18.c 77] bad18 		[N2093 -{call void @free(i8* %5, i8* @free)}-> N2095]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_18.c 77] bad18 		[N2093 -{call void @free(i8* %5, i8* @free)}-> N2095]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_18.c 77] bad18 		[N2093 -{call void @free(i8* %5, i8* @free)}-> N2095]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_19.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad19, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good19]
Loops     []
----
function: bad19
P+ = [] 
P- = [H(bad19::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good19
P+ = [] 
P- = [H(good19::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad19::call), H(good19::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2275): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2234
On edge  : N2234 -{call void @free(i8* %5, i8* @free)}-> N2236
Message  : the memory is already freed
> Start from entry function: main, At N2275 of Function main
> Entering function: good19, On N2323 -> N2255 (call good19)
> takes the true branch, At N2264 of Function good19
> Leaving function: good19, On N2254 -> N2277 (Return edge from good19 to main)
> Entering function: bad19, On N2277 -> N2218 (call bad19)
> takes the false branch, At N2227 of Function bad19
<Defect> : N2234 -> N2236: [call void @free(i8* %5, i8* @free)]
N2234 -> N2236: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2234
On edge  : N2234 -{call void @free(i8* %5, i8* @free)}-> N2236
Message  : the memory is already freed
> Start from entry function: main, At N2275 of Function main
> Entering function: good19, On N2323 -> N2255 (call good19)
> takes the true branch, At N2264 of Function good19
> Leaving function: good19, On N2254 -> N2277 (Return edge from good19 to main)
> Entering function: bad19, On N2277 -> N2218 (call bad19)
> takes the false branch, At N2227 of Function bad19
<Defect> : N2234 -> N2236: [call void @free(i8* %5, i8* @free)]
N2234 -> N2236: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_19.c 67] bad19 		[N2234 -{call void @free(i8* %5, i8* @free)}-> N2236]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_19.c 67] bad19 		[N2234 -{call void @free(i8* %5, i8* @free)}-> N2236]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_20.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad20, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good20, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad20
P+ = [] 
P- = [N, H(bad20::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good20
P+ = [] 
P- = [H(good20::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad20::call), H(good20::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2414): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2356
On edge  : N2356 -{call void @free(i8* %7, i8* @free)}-> N2358
Message  : the memory is already freed
> Start from entry function: main, At N2414 of Function main
> Entering function: good20, On N2462 -> N2381 (call good20)
> takes the true branch, At N2387 of Function good20
> takes the true branch, At N2393 of Function good20
> Leaving function: good20, On N2380 -> N2416 (Return edge from good20 to main)
> Entering function: bad20, On N2416 -> N2333 (call bad20)
> takes the false branch, At N2339 of Function bad20
> takes the true branch, At N2353 of Function bad20
<Defect> : N2356 -> N2358: [call void @free(i8* %7, i8* @free)]
N2356 -> N2358: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N2356
On edge  : N2356 -{call void @free(i8* %7, i8* @free)}-> N2358
Message  : null pointer dereference
> Start from entry function: main, At N2414 of Function main
> Entering function: good20, On N2462 -> N2381 (call good20)
> takes the true branch, At N2387 of Function good20
> takes the true branch, At N2393 of Function good20
> Leaving function: good20, On N2380 -> N2416 (Return edge from good20 to main)
> Entering function: bad20, On N2416 -> N2333 (call bad20)
> takes the false branch, At N2339 of Function bad20
> takes the true branch, At N2353 of Function bad20
<Defect> : N2356 -> N2358: [call void @free(i8* %7, i8* @free)]
N2356 -> N2358: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2356
On edge  : N2356 -{call void @free(i8* %7, i8* @free)}-> N2358
Message  : the memory is already freed
> Start from entry function: main, At N2414 of Function main
> Entering function: good20, On N2462 -> N2381 (call good20)
> takes the true branch, At N2387 of Function good20
> takes the true branch, At N2393 of Function good20
> Leaving function: good20, On N2380 -> N2416 (Return edge from good20 to main)
> Entering function: bad20, On N2416 -> N2333 (call bad20)
> takes the false branch, At N2339 of Function bad20
> takes the true branch, At N2353 of Function bad20
<Defect> : N2356 -> N2358: [call void @free(i8* %7, i8* @free)]
N2356 -> N2358: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_20.c 67] bad20 		[N2356 -{call void @free(i8* %7, i8* @free)}-> N2358]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_20.c 67] bad20 		[N2356 -{call void @free(i8* %7, i8* @free)}-> N2358]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_20.c 67] bad20 		[N2356 -{call void @free(i8* %7, i8* @free)}-> N2358]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_21.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad21, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good21]
Loops     []
----
function: bad21
P+ = [] 
P- = [H(bad21::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good21
P+ = [] 
P- = [H(good21::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad21::call), H(good21::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.031s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2530): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2489
On edge  : N2489 -{call void @free(i8* %5, i8* @free)}-> N2491
Message  : the memory is already freed
> Start from entry function: main, At N2530 of Function main
> Entering function: good21, On N2578 -> N2510 (call good21)
> takes the true branch, At N2519 of Function good21
> Leaving function: good21, On N2509 -> N2532 (Return edge from good21 to main)
> Entering function: bad21, On N2532 -> N2473 (call bad21)
> takes the false branch, At N2482 of Function bad21
<Defect> : N2489 -> N2491: [call void @free(i8* %5, i8* @free)]
N2489 -> N2491: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2489
On edge  : N2489 -{call void @free(i8* %5, i8* @free)}-> N2491
Message  : the memory is already freed
> Start from entry function: main, At N2530 of Function main
> Entering function: good21, On N2578 -> N2510 (call good21)
> takes the true branch, At N2519 of Function good21
> Leaving function: good21, On N2509 -> N2532 (Return edge from good21 to main)
> Entering function: bad21, On N2532 -> N2473 (call bad21)
> takes the false branch, At N2482 of Function bad21
<Defect> : N2489 -> N2491: [call void @free(i8* %5, i8* @free)]
N2489 -> N2491: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_21.c 62] bad21 		[N2489 -{call void @free(i8* %5, i8* @free)}-> N2491]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_21.c 62] bad21 		[N2489 -{call void @free(i8* %5, i8* @free)}-> N2491]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_22.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad22, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good22, main, printHexCharLine]
Loops     []
----
function: bad22
P+ = [] 
P- = [H(bad22::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good22
P+ = [] 
P- = [H(good22::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad22::call), H(good22::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2645): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2604
On edge  : N2604 -{call void @free(i8* %5, i8* @free)}-> N2606
Message  : the memory is already freed
> Start from entry function: main, At N2645 of Function main
> Entering function: good22, On N2693 -> N2625 (call good22)
> takes the true branch, At N2634 of Function good22
> Leaving function: good22, On N2624 -> N2647 (Return edge from good22 to main)
> Entering function: bad22, On N2647 -> N2588 (call bad22)
> takes the false branch, At N2597 of Function bad22
<Defect> : N2604 -> N2606: [call void @free(i8* %5, i8* @free)]
N2604 -> N2606: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2604
On edge  : N2604 -{call void @free(i8* %5, i8* @free)}-> N2606
Message  : the memory is already freed
> Start from entry function: main, At N2645 of Function main
> Entering function: good22, On N2693 -> N2625 (call good22)
> takes the true branch, At N2634 of Function good22
> Leaving function: good22, On N2624 -> N2647 (Return edge from good22 to main)
> Entering function: bad22, On N2647 -> N2588 (call bad22)
> takes the false branch, At N2597 of Function bad22
<Defect> : N2604 -> N2606: [call void @free(i8* %5, i8* @free)]
N2604 -> N2606: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_22.c 67] bad22 		[N2604 -{call void @free(i8* %5, i8* @free)}-> N2606]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_22.c 67] bad22 		[N2604 -{call void @free(i8* %5, i8* @free)}-> N2606]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_23.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad23, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good23, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad23
P+ = [] 
P- = [H(bad23::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good23
P+ = [] 
P- = [H(good23::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad23::call), H(good23::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2760): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2719
On edge  : N2719 -{call void @free(i8* %5, i8* @free)}-> N2721
Message  : the memory is already freed
> Start from entry function: main, At N2760 of Function main
> Entering function: good23, On N2808 -> N2740 (call good23)
> takes the true branch, At N2749 of Function good23
> Leaving function: good23, On N2739 -> N2762 (Return edge from good23 to main)
> Entering function: bad23, On N2762 -> N2703 (call bad23)
> takes the false branch, At N2712 of Function bad23
<Defect> : N2719 -> N2721: [call void @free(i8* %5, i8* @free)]
N2719 -> N2721: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2719
On edge  : N2719 -{call void @free(i8* %5, i8* @free)}-> N2721
Message  : the memory is already freed
> Start from entry function: main, At N2760 of Function main
> Entering function: good23, On N2808 -> N2740 (call good23)
> takes the true branch, At N2749 of Function good23
> Leaving function: good23, On N2739 -> N2762 (Return edge from good23 to main)
> Entering function: bad23, On N2762 -> N2703 (call bad23)
> takes the false branch, At N2712 of Function bad23
<Defect> : N2719 -> N2721: [call void @free(i8* %5, i8* @free)]
N2719 -> N2721: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_23.c 67] bad23 		[N2719 -{call void @free(i8* %5, i8* @free)}-> N2721]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_23.c 67] bad23 		[N2719 -{call void @free(i8* %5, i8* @free)}-> N2721]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_24.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad24, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good24, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad24
P+ = [] 
P- = [H(bad24::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good24
P+ = [] 
P- = [H(good24::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad24::call), H(good24::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.031s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2875): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2834
On edge  : N2834 -{call void @free(i8* %5, i8* @free)}-> N2836
Message  : the memory is already freed
> Start from entry function: main, At N2875 of Function main
> Entering function: good24, On N2923 -> N2855 (call good24)
> takes the true branch, At N2864 of Function good24
> Leaving function: good24, On N2854 -> N2877 (Return edge from good24 to main)
> Entering function: bad24, On N2877 -> N2818 (call bad24)
> takes the false branch, At N2827 of Function bad24
<Defect> : N2834 -> N2836: [call void @free(i8* %5, i8* @free)]
N2834 -> N2836: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2834
On edge  : N2834 -{call void @free(i8* %5, i8* @free)}-> N2836
Message  : the memory is already freed
> Start from entry function: main, At N2875 of Function main
> Entering function: good24, On N2923 -> N2855 (call good24)
> takes the true branch, At N2864 of Function good24
> Leaving function: good24, On N2854 -> N2877 (Return edge from good24 to main)
> Entering function: bad24, On N2877 -> N2818 (call bad24)
> takes the false branch, At N2827 of Function bad24
<Defect> : N2834 -> N2836: [call void @free(i8* %5, i8* @free)]
N2834 -> N2836: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_24.c 70] bad24 		[N2834 -{call void @free(i8* %5, i8* @free)}-> N2836]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_24.c 70] bad24 		[N2834 -{call void @free(i8* %5, i8* @free)}-> N2836]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_25.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad25, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good25, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad25
P+ = [] 
P- = [N, H(bad25::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good25
P+ = [] 
P- = [H(good25::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad25::call), H(good25::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3014): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N2956
On edge  : N2956 -{call void @free(i8* %7, i8* @free)}-> N2958
Message  : the memory is already freed
> Start from entry function: main, At N3014 of Function main
> Entering function: good25, On N3062 -> N2981 (call good25)
> takes the true branch, At N2987 of Function good25
> takes the true branch, At N2993 of Function good25
> Leaving function: good25, On N2980 -> N3016 (Return edge from good25 to main)
> Entering function: bad25, On N3016 -> N2933 (call bad25)
> takes the false branch, At N2939 of Function bad25
> takes the true branch, At N2953 of Function bad25
<Defect> : N2956 -> N2958: [call void @free(i8* %7, i8* @free)]
N2956 -> N2958: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N2956
On edge  : N2956 -{call void @free(i8* %7, i8* @free)}-> N2958
Message  : null pointer dereference
> Start from entry function: main, At N3014 of Function main
> Entering function: good25, On N3062 -> N2981 (call good25)
> takes the true branch, At N2987 of Function good25
> takes the true branch, At N2993 of Function good25
> Leaving function: good25, On N2980 -> N3016 (Return edge from good25 to main)
> Entering function: bad25, On N3016 -> N2933 (call bad25)
> takes the false branch, At N2939 of Function bad25
> takes the true branch, At N2953 of Function bad25
<Defect> : N2956 -> N2958: [call void @free(i8* %7, i8* @free)]
N2956 -> N2958: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N2956
On edge  : N2956 -{call void @free(i8* %7, i8* @free)}-> N2958
Message  : the memory is already freed
> Start from entry function: main, At N3014 of Function main
> Entering function: good25, On N3062 -> N2981 (call good25)
> takes the true branch, At N2987 of Function good25
> takes the true branch, At N2993 of Function good25
> Leaving function: good25, On N2980 -> N3016 (Return edge from good25 to main)
> Entering function: bad25, On N3016 -> N2933 (call bad25)
> takes the false branch, At N2939 of Function bad25
> takes the true branch, At N2953 of Function bad25
<Defect> : N2956 -> N2958: [call void @free(i8* %7, i8* @free)]
N2956 -> N2958: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_25.c 70] bad25 		[N2956 -{call void @free(i8* %7, i8* @free)}-> N2958]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_25.c 70] bad25 		[N2956 -{call void @free(i8* %7, i8* @free)}-> N2958]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_25.c 70] bad25 		[N2956 -{call void @free(i8* %7, i8* @free)}-> N2958]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_26.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad26, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good26, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad26
P+ = [] 
P- = [H(bad26::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good26
P+ = [] 
P- = [H(good26::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad26::call), H(good26::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.029s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3132): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3091
On edge  : N3091 -{call void @free(i8* %5, i8* @free)}-> N3093
Message  : the memory is already freed
> Start from entry function: main, At N3132 of Function main
> Entering function: good26, On N3180 -> N3112 (call good26)
> takes the true branch, At N3121 of Function good26
> Leaving function: good26, On N3111 -> N3134 (Return edge from good26 to main)
> Entering function: bad26, On N3134 -> N3075 (call bad26)
> takes the false branch, At N3084 of Function bad26
<Defect> : N3091 -> N3093: [call void @free(i8* %5, i8* @free)]
N3091 -> N3093: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3091
On edge  : N3091 -{call void @free(i8* %5, i8* @free)}-> N3093
Message  : the memory is already freed
> Start from entry function: main, At N3132 of Function main
> Entering function: good26, On N3180 -> N3112 (call good26)
> takes the true branch, At N3121 of Function good26
> Leaving function: good26, On N3111 -> N3134 (Return edge from good26 to main)
> Entering function: bad26, On N3134 -> N3075 (call bad26)
> takes the false branch, At N3084 of Function bad26
<Defect> : N3091 -> N3093: [call void @free(i8* %5, i8* @free)]
N3091 -> N3093: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_26.c 69] bad26 		[N3091 -{call void @free(i8* %5, i8* @free)}-> N3093]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_26.c 69] bad26 		[N3091 -{call void @free(i8* %5, i8* @free)}-> N3093]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_27.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad27, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good27, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad27
P+ = [] 
P- = [N, H(bad27::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good27
P+ = [] 
P- = [H(good27::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad27::call), H(good27::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3271): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3213
On edge  : N3213 -{call void @free(i8* %7, i8* @free)}-> N3215
Message  : the memory is already freed
> Start from entry function: main, At N3271 of Function main
> Entering function: good27, On N3319 -> N3238 (call good27)
> takes the true branch, At N3244 of Function good27
> takes the true branch, At N3250 of Function good27
> Leaving function: good27, On N3237 -> N3273 (Return edge from good27 to main)
> Entering function: bad27, On N3273 -> N3190 (call bad27)
> takes the false branch, At N3196 of Function bad27
> takes the true branch, At N3210 of Function bad27
<Defect> : N3213 -> N3215: [call void @free(i8* %7, i8* @free)]
N3213 -> N3215: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N3213
On edge  : N3213 -{call void @free(i8* %7, i8* @free)}-> N3215
Message  : null pointer dereference
> Start from entry function: main, At N3271 of Function main
> Entering function: good27, On N3319 -> N3238 (call good27)
> takes the true branch, At N3244 of Function good27
> takes the true branch, At N3250 of Function good27
> Leaving function: good27, On N3237 -> N3273 (Return edge from good27 to main)
> Entering function: bad27, On N3273 -> N3190 (call bad27)
> takes the false branch, At N3196 of Function bad27
> takes the true branch, At N3210 of Function bad27
<Defect> : N3213 -> N3215: [call void @free(i8* %7, i8* @free)]
N3213 -> N3215: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3213
On edge  : N3213 -{call void @free(i8* %7, i8* @free)}-> N3215
Message  : the memory is already freed
> Start from entry function: main, At N3271 of Function main
> Entering function: good27, On N3319 -> N3238 (call good27)
> takes the true branch, At N3244 of Function good27
> takes the true branch, At N3250 of Function good27
> Leaving function: good27, On N3237 -> N3273 (Return edge from good27 to main)
> Entering function: bad27, On N3273 -> N3190 (call bad27)
> takes the false branch, At N3196 of Function bad27
> takes the true branch, At N3210 of Function bad27
<Defect> : N3213 -> N3215: [call void @free(i8* %7, i8* @free)]
N3213 -> N3215: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_27.c 69] bad27 		[N3213 -{call void @free(i8* %7, i8* @free)}-> N3215]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_27.c 69] bad27 		[N3213 -{call void @free(i8* %7, i8* @free)}-> N3215]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_27.c 69] bad27 		[N3213 -{call void @free(i8* %7, i8* @free)}-> N3215]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_28.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad28, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good28, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue]
Loops     []
----
function: bad28
P+ = [] 
P- = [N, H(bad28::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good28
P+ = [] 
P- = [H(good28::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad28::call1), H(good28::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.025s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3412): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3354
On edge  : N3354 -{call void @free(i8* %5, i8* @free)}-> N3356
Message  : the memory is already freed
> Start from entry function: main, At N3412 of Function main
> Entering function: good28, On N3468 -> N3379 (call good28)
> Entering function: staticReturnsTrue, On N3383 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3384 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N3385 of Function good28
> takes the true branch, At N3391 of Function good28
> Leaving function: good28, On N3378 -> N3414 (Return edge from good28 to main)
> Entering function: bad28, On N3414 -> N3331 (call bad28)
> Entering function: staticReturnsTrue, On N3335 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3336 (Return edge from staticReturnsTrue to bad28)
> takes the false branch, At N3337 of Function bad28
> Entering function: staticReturnsTrue, On N3349 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3350 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N3351 of Function bad28
<Defect> : N3354 -> N3356: [call void @free(i8* %5, i8* @free)]
N3354 -> N3356: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N3354
On edge  : N3354 -{call void @free(i8* %5, i8* @free)}-> N3356
Message  : null pointer dereference
> Start from entry function: main, At N3412 of Function main
> Entering function: good28, On N3468 -> N3379 (call good28)
> Entering function: staticReturnsTrue, On N3383 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3384 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N3385 of Function good28
> takes the true branch, At N3391 of Function good28
> Leaving function: good28, On N3378 -> N3414 (Return edge from good28 to main)
> Entering function: bad28, On N3414 -> N3331 (call bad28)
> Entering function: staticReturnsTrue, On N3335 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3336 (Return edge from staticReturnsTrue to bad28)
> takes the false branch, At N3337 of Function bad28
> Entering function: staticReturnsTrue, On N3349 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3350 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N3351 of Function bad28
<Defect> : N3354 -> N3356: [call void @free(i8* %5, i8* @free)]
N3354 -> N3356: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3354
On edge  : N3354 -{call void @free(i8* %5, i8* @free)}-> N3356
Message  : the memory is already freed
> Start from entry function: main, At N3412 of Function main
> Entering function: good28, On N3468 -> N3379 (call good28)
> Entering function: staticReturnsTrue, On N3383 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3384 (Return edge from staticReturnsTrue to good28)
> takes the true branch, At N3385 of Function good28
> takes the true branch, At N3391 of Function good28
> Leaving function: good28, On N3378 -> N3414 (Return edge from good28 to main)
> Entering function: bad28, On N3414 -> N3331 (call bad28)
> Entering function: staticReturnsTrue, On N3335 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3336 (Return edge from staticReturnsTrue to bad28)
> takes the false branch, At N3337 of Function bad28
> Entering function: staticReturnsTrue, On N3349 -> N3465 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N3464 -> N3350 (Return edge from staticReturnsTrue to bad28)
> takes the true branch, At N3351 of Function bad28
<Defect> : N3354 -> N3356: [call void @free(i8* %5, i8* @free)]
N3354 -> N3356: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_28.c 77] bad28 		[N3354 -{call void @free(i8* %5, i8* @free)}-> N3356]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_28.c 77] bad28 		[N3354 -{call void @free(i8* %5, i8* @free)}-> N3356]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_28.c 77] bad28 		[N3354 -{call void @free(i8* %5, i8* @free)}-> N3356]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_29.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad29, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good29, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad29
P+ = [] 
P- = [H(bad29::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good29
P+ = [] 
P- = [H(good29::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad29::call), H(good29::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3536): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3495
On edge  : N3495 -{call void @free(i8* %5, i8* @free)}-> N3497
Message  : the memory is already freed
> Start from entry function: main, At N3536 of Function main
> Entering function: good29, On N3584 -> N3516 (call good29)
> takes the true branch, At N3525 of Function good29
> Leaving function: good29, On N3515 -> N3538 (Return edge from good29 to main)
> Entering function: bad29, On N3538 -> N3479 (call bad29)
> takes the false branch, At N3488 of Function bad29
<Defect> : N3495 -> N3497: [call void @free(i8* %5, i8* @free)]
N3495 -> N3497: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3495
On edge  : N3495 -{call void @free(i8* %5, i8* @free)}-> N3497
Message  : the memory is already freed
> Start from entry function: main, At N3536 of Function main
> Entering function: good29, On N3584 -> N3516 (call good29)
> takes the true branch, At N3525 of Function good29
> Leaving function: good29, On N3515 -> N3538 (Return edge from good29 to main)
> Entering function: bad29, On N3538 -> N3479 (call bad29)
> takes the false branch, At N3488 of Function bad29
<Defect> : N3495 -> N3497: [call void @free(i8* %5, i8* @free)]
N3495 -> N3497: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_29.c 67] bad29 		[N3495 -{call void @free(i8* %5, i8* @free)}-> N3497]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_29.c 67] bad29 		[N3495 -{call void @free(i8* %5, i8* @free)}-> N3497]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_30.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad30, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good30, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad30
P+ = [] 
P- = [N, H(bad30::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good30
P+ = [] 
P- = [H(good30::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad30::call), H(good30::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.026s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3675): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3617
On edge  : N3617 -{call void @free(i8* %7, i8* @free)}-> N3619
Message  : the memory is already freed
> Start from entry function: main, At N3675 of Function main
> Entering function: good30, On N3723 -> N3642 (call good30)
> takes the true branch, At N3648 of Function good30
> takes the true branch, At N3654 of Function good30
> Leaving function: good30, On N3641 -> N3677 (Return edge from good30 to main)
> Entering function: bad30, On N3677 -> N3594 (call bad30)
> takes the false branch, At N3600 of Function bad30
> takes the true branch, At N3614 of Function bad30
<Defect> : N3617 -> N3619: [call void @free(i8* %7, i8* @free)]
N3617 -> N3619: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N3617
On edge  : N3617 -{call void @free(i8* %7, i8* @free)}-> N3619
Message  : null pointer dereference
> Start from entry function: main, At N3675 of Function main
> Entering function: good30, On N3723 -> N3642 (call good30)
> takes the true branch, At N3648 of Function good30
> takes the true branch, At N3654 of Function good30
> Leaving function: good30, On N3641 -> N3677 (Return edge from good30 to main)
> Entering function: bad30, On N3677 -> N3594 (call bad30)
> takes the false branch, At N3600 of Function bad30
> takes the true branch, At N3614 of Function bad30
<Defect> : N3617 -> N3619: [call void @free(i8* %7, i8* @free)]
N3617 -> N3619: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3617
On edge  : N3617 -{call void @free(i8* %7, i8* @free)}-> N3619
Message  : the memory is already freed
> Start from entry function: main, At N3675 of Function main
> Entering function: good30, On N3723 -> N3642 (call good30)
> takes the true branch, At N3648 of Function good30
> takes the true branch, At N3654 of Function good30
> Leaving function: good30, On N3641 -> N3677 (Return edge from good30 to main)
> Entering function: bad30, On N3677 -> N3594 (call bad30)
> takes the false branch, At N3600 of Function bad30
> takes the true branch, At N3614 of Function bad30
<Defect> : N3617 -> N3619: [call void @free(i8* %7, i8* @free)]
N3617 -> N3619: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_30.c 67] bad30 		[N3617 -{call void @free(i8* %7, i8* @free)}-> N3619]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_30.c 67] bad30 		[N3617 -{call void @free(i8* %7, i8* @free)}-> N3619]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_30.c 67] bad30 		[N3617 -{call void @free(i8* %7, i8* @free)}-> N3619]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_31.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad32, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good32, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad32
P+ = [] 
P- = [H(bad32::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good32
P+ = [] 
P- = [H(good32::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad32::call), H(good32::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3791): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3750
On edge  : N3750 -{call void @free(i8* %5, i8* @free)}-> N3752
Message  : the memory is already freed
> Start from entry function: main, At N3791 of Function main
> Entering function: good32, On N3839 -> N3771 (call good32)
> takes the true branch, At N3780 of Function good32
> Leaving function: good32, On N3770 -> N3793 (Return edge from good32 to main)
> Entering function: bad32, On N3793 -> N3734 (call bad32)
> takes the false branch, At N3743 of Function bad32
<Defect> : N3750 -> N3752: [call void @free(i8* %5, i8* @free)]
N3750 -> N3752: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3750
On edge  : N3750 -{call void @free(i8* %5, i8* @free)}-> N3752
Message  : the memory is already freed
> Start from entry function: main, At N3791 of Function main
> Entering function: good32, On N3839 -> N3771 (call good32)
> takes the true branch, At N3780 of Function good32
> Leaving function: good32, On N3770 -> N3793 (Return edge from good32 to main)
> Entering function: bad32, On N3793 -> N3734 (call bad32)
> takes the false branch, At N3743 of Function bad32
<Defect> : N3750 -> N3752: [call void @free(i8* %5, i8* @free)]
N3750 -> N3752: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_31.c 67] bad32 		[N3750 -{call void @free(i8* %5, i8* @free)}-> N3752]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_31.c 67] bad32 		[N3750 -{call void @free(i8* %5, i8* @free)}-> N3752]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_32.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad32, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good32, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad32
P+ = [] 
P- = [H(bad32::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good32
P+ = [] 
P- = [H(good32::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad32::call), H(good32::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3906): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3865
On edge  : N3865 -{call void @free(i8* %5, i8* @free)}-> N3867
Message  : the memory is already freed
> Start from entry function: main, At N3906 of Function main
> Entering function: good32, On N3954 -> N3886 (call good32)
> takes the true branch, At N3895 of Function good32
> Leaving function: good32, On N3885 -> N3908 (Return edge from good32 to main)
> Entering function: bad32, On N3908 -> N3849 (call bad32)
> takes the false branch, At N3858 of Function bad32
<Defect> : N3865 -> N3867: [call void @free(i8* %5, i8* @free)]
N3865 -> N3867: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3865
On edge  : N3865 -{call void @free(i8* %5, i8* @free)}-> N3867
Message  : the memory is already freed
> Start from entry function: main, At N3906 of Function main
> Entering function: good32, On N3954 -> N3886 (call good32)
> takes the true branch, At N3895 of Function good32
> Leaving function: good32, On N3885 -> N3908 (Return edge from good32 to main)
> Entering function: bad32, On N3908 -> N3849 (call bad32)
> takes the false branch, At N3858 of Function bad32
<Defect> : N3865 -> N3867: [call void @free(i8* %5, i8* @free)]
N3865 -> N3867: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_32.c 67] bad32 		[N3865 -{call void @free(i8* %5, i8* @free)}-> N3867]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_32.c 67] bad32 		[N3865 -{call void @free(i8* %5, i8* @free)}-> N3867]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_33.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad33, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good33, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad33
P+ = [] 
P- = [H(bad33::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good33
P+ = [] 
P- = [H(good33::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad33::call), H(good33::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4021): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N3980
On edge  : N3980 -{call void @free(i8* %5, i8* @free)}-> N3982
Message  : the memory is already freed
> Start from entry function: main, At N4021 of Function main
> Entering function: good33, On N4069 -> N4001 (call good33)
> takes the true branch, At N4010 of Function good33
> Leaving function: good33, On N4000 -> N4023 (Return edge from good33 to main)
> Entering function: bad33, On N4023 -> N3964 (call bad33)
> takes the false branch, At N3973 of Function bad33
<Defect> : N3980 -> N3982: [call void @free(i8* %5, i8* @free)]
N3980 -> N3982: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N3980
On edge  : N3980 -{call void @free(i8* %5, i8* @free)}-> N3982
Message  : the memory is already freed
> Start from entry function: main, At N4021 of Function main
> Entering function: good33, On N4069 -> N4001 (call good33)
> takes the true branch, At N4010 of Function good33
> Leaving function: good33, On N4000 -> N4023 (Return edge from good33 to main)
> Entering function: bad33, On N4023 -> N3964 (call bad33)
> takes the false branch, At N3973 of Function bad33
<Defect> : N3980 -> N3982: [call void @free(i8* %5, i8* @free)]
N3980 -> N3982: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_33.c 67] bad33 		[N3980 -{call void @free(i8* %5, i8* @free)}-> N3982]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_33.c 67] bad33 		[N3980 -{call void @free(i8* %5, i8* @free)}-> N3982]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_34.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad34, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good34, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad34
P+ = [] 
P- = [H(bad34::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good34
P+ = [] 
P- = [H(good34::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad34::call), H(good34::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4136): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4095
On edge  : N4095 -{call void @free(i8* %5, i8* @free)}-> N4097
Message  : the memory is already freed
> Start from entry function: main, At N4136 of Function main
> Entering function: good34, On N4184 -> N4116 (call good34)
> takes the true branch, At N4125 of Function good34
> Leaving function: good34, On N4115 -> N4138 (Return edge from good34 to main)
> Entering function: bad34, On N4138 -> N4079 (call bad34)
> takes the false branch, At N4088 of Function bad34
<Defect> : N4095 -> N4097: [call void @free(i8* %5, i8* @free)]
N4095 -> N4097: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4095
On edge  : N4095 -{call void @free(i8* %5, i8* @free)}-> N4097
Message  : the memory is already freed
> Start from entry function: main, At N4136 of Function main
> Entering function: good34, On N4184 -> N4116 (call good34)
> takes the true branch, At N4125 of Function good34
> Leaving function: good34, On N4115 -> N4138 (Return edge from good34 to main)
> Entering function: bad34, On N4138 -> N4079 (call bad34)
> takes the false branch, At N4088 of Function bad34
<Defect> : N4095 -> N4097: [call void @free(i8* %5, i8* @free)]
N4095 -> N4097: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_34.c 70] bad34 		[N4095 -{call void @free(i8* %5, i8* @free)}-> N4097]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_34.c 70] bad34 		[N4095 -{call void @free(i8* %5, i8* @free)}-> N4097]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_35.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad35, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good35, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad35
P+ = [] 
P- = [N, H(bad35::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good35
P+ = [] 
P- = [H(good35::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad35::call), H(good35::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.026s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4275): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4217
On edge  : N4217 -{call void @free(i8* %7, i8* @free)}-> N4219
Message  : the memory is already freed
> Start from entry function: main, At N4275 of Function main
> Entering function: good35, On N4323 -> N4242 (call good35)
> takes the true branch, At N4248 of Function good35
> takes the true branch, At N4254 of Function good35
> Leaving function: good35, On N4241 -> N4277 (Return edge from good35 to main)
> Entering function: bad35, On N4277 -> N4194 (call bad35)
> takes the false branch, At N4200 of Function bad35
> takes the true branch, At N4214 of Function bad35
<Defect> : N4217 -> N4219: [call void @free(i8* %7, i8* @free)]
N4217 -> N4219: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N4217
On edge  : N4217 -{call void @free(i8* %7, i8* @free)}-> N4219
Message  : null pointer dereference
> Start from entry function: main, At N4275 of Function main
> Entering function: good35, On N4323 -> N4242 (call good35)
> takes the true branch, At N4248 of Function good35
> takes the true branch, At N4254 of Function good35
> Leaving function: good35, On N4241 -> N4277 (Return edge from good35 to main)
> Entering function: bad35, On N4277 -> N4194 (call bad35)
> takes the false branch, At N4200 of Function bad35
> takes the true branch, At N4214 of Function bad35
<Defect> : N4217 -> N4219: [call void @free(i8* %7, i8* @free)]
N4217 -> N4219: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4217
On edge  : N4217 -{call void @free(i8* %7, i8* @free)}-> N4219
Message  : the memory is already freed
> Start from entry function: main, At N4275 of Function main
> Entering function: good35, On N4323 -> N4242 (call good35)
> takes the true branch, At N4248 of Function good35
> takes the true branch, At N4254 of Function good35
> Leaving function: good35, On N4241 -> N4277 (Return edge from good35 to main)
> Entering function: bad35, On N4277 -> N4194 (call bad35)
> takes the false branch, At N4200 of Function bad35
> takes the true branch, At N4214 of Function bad35
<Defect> : N4217 -> N4219: [call void @free(i8* %7, i8* @free)]
N4217 -> N4219: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_35.c 70] bad35 		[N4217 -{call void @free(i8* %7, i8* @free)}-> N4219]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_35.c 70] bad35 		[N4217 -{call void @free(i8* %7, i8* @free)}-> N4219]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_35.c 70] bad35 		[N4217 -{call void @free(i8* %7, i8* @free)}-> N4219]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_36.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad36, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good36, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad36
P+ = [] 
P- = [H(bad36::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good36
P+ = [] 
P- = [H(good36::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad36::call), H(good36::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4393): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4352
On edge  : N4352 -{call void @free(i8* %5, i8* @free)}-> N4354
Message  : the memory is already freed
> Start from entry function: main, At N4393 of Function main
> Entering function: good36, On N4441 -> N4373 (call good36)
> takes the true branch, At N4382 of Function good36
> Leaving function: good36, On N4372 -> N4395 (Return edge from good36 to main)
> Entering function: bad36, On N4395 -> N4336 (call bad36)
> takes the false branch, At N4345 of Function bad36
<Defect> : N4352 -> N4354: [call void @free(i8* %5, i8* @free)]
N4352 -> N4354: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4352
On edge  : N4352 -{call void @free(i8* %5, i8* @free)}-> N4354
Message  : the memory is already freed
> Start from entry function: main, At N4393 of Function main
> Entering function: good36, On N4441 -> N4373 (call good36)
> takes the true branch, At N4382 of Function good36
> Leaving function: good36, On N4372 -> N4395 (Return edge from good36 to main)
> Entering function: bad36, On N4395 -> N4336 (call bad36)
> takes the false branch, At N4345 of Function bad36
<Defect> : N4352 -> N4354: [call void @free(i8* %5, i8* @free)]
N4352 -> N4354: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_36.c 69] bad36 		[N4352 -{call void @free(i8* %5, i8* @free)}-> N4354]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_36.c 69] bad36 		[N4352 -{call void @free(i8* %5, i8* @free)}-> N4354]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_37.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad37, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good37, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad37
P+ = [] 
P- = [N, H(bad37::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good37
P+ = [] 
P- = [H(good37::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad37::call), H(good37::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4532): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4474
On edge  : N4474 -{call void @free(i8* %7, i8* @free)}-> N4476
Message  : the memory is already freed
> Start from entry function: main, At N4532 of Function main
> Entering function: good37, On N4580 -> N4499 (call good37)
> takes the true branch, At N4505 of Function good37
> takes the true branch, At N4511 of Function good37
> Leaving function: good37, On N4498 -> N4534 (Return edge from good37 to main)
> Entering function: bad37, On N4534 -> N4451 (call bad37)
> takes the false branch, At N4457 of Function bad37
> takes the true branch, At N4471 of Function bad37
<Defect> : N4474 -> N4476: [call void @free(i8* %7, i8* @free)]
N4474 -> N4476: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N4474
On edge  : N4474 -{call void @free(i8* %7, i8* @free)}-> N4476
Message  : null pointer dereference
> Start from entry function: main, At N4532 of Function main
> Entering function: good37, On N4580 -> N4499 (call good37)
> takes the true branch, At N4505 of Function good37
> takes the true branch, At N4511 of Function good37
> Leaving function: good37, On N4498 -> N4534 (Return edge from good37 to main)
> Entering function: bad37, On N4534 -> N4451 (call bad37)
> takes the false branch, At N4457 of Function bad37
> takes the true branch, At N4471 of Function bad37
<Defect> : N4474 -> N4476: [call void @free(i8* %7, i8* @free)]
N4474 -> N4476: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4474
On edge  : N4474 -{call void @free(i8* %7, i8* @free)}-> N4476
Message  : the memory is already freed
> Start from entry function: main, At N4532 of Function main
> Entering function: good37, On N4580 -> N4499 (call good37)
> takes the true branch, At N4505 of Function good37
> takes the true branch, At N4511 of Function good37
> Leaving function: good37, On N4498 -> N4534 (Return edge from good37 to main)
> Entering function: bad37, On N4534 -> N4451 (call bad37)
> takes the false branch, At N4457 of Function bad37
> takes the true branch, At N4471 of Function bad37
<Defect> : N4474 -> N4476: [call void @free(i8* %7, i8* @free)]
N4474 -> N4476: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_37.c 69] bad37 		[N4474 -{call void @free(i8* %7, i8* @free)}-> N4476]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_37.c 69] bad37 		[N4474 -{call void @free(i8* %7, i8* @free)}-> N4476]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_37.c 69] bad37 		[N4474 -{call void @free(i8* %7, i8* @free)}-> N4476]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_38.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad38, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good38, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue]
Loops     []
----
function: bad38
P+ = [] 
P- = [N, H(bad38::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good38
P+ = [] 
P- = [H(good38::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad38::call1), H(good38::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4673): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4615
On edge  : N4615 -{call void @free(i8* %5, i8* @free)}-> N4617
Message  : the memory is already freed
> Start from entry function: main, At N4673 of Function main
> Entering function: good38, On N4729 -> N4640 (call good38)
> Entering function: staticReturnsTrue, On N4644 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4645 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N4646 of Function good38
> takes the true branch, At N4652 of Function good38
> Leaving function: good38, On N4639 -> N4675 (Return edge from good38 to main)
> Entering function: bad38, On N4675 -> N4592 (call bad38)
> Entering function: staticReturnsTrue, On N4596 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4597 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N4598 of Function bad38
> Entering function: staticReturnsTrue, On N4610 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4611 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N4612 of Function bad38
<Defect> : N4615 -> N4617: [call void @free(i8* %5, i8* @free)]
N4615 -> N4617: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N4615
On edge  : N4615 -{call void @free(i8* %5, i8* @free)}-> N4617
Message  : null pointer dereference
> Start from entry function: main, At N4673 of Function main
> Entering function: good38, On N4729 -> N4640 (call good38)
> Entering function: staticReturnsTrue, On N4644 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4645 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N4646 of Function good38
> takes the true branch, At N4652 of Function good38
> Leaving function: good38, On N4639 -> N4675 (Return edge from good38 to main)
> Entering function: bad38, On N4675 -> N4592 (call bad38)
> Entering function: staticReturnsTrue, On N4596 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4597 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N4598 of Function bad38
> Entering function: staticReturnsTrue, On N4610 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4611 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N4612 of Function bad38
<Defect> : N4615 -> N4617: [call void @free(i8* %5, i8* @free)]
N4615 -> N4617: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4615
On edge  : N4615 -{call void @free(i8* %5, i8* @free)}-> N4617
Message  : the memory is already freed
> Start from entry function: main, At N4673 of Function main
> Entering function: good38, On N4729 -> N4640 (call good38)
> Entering function: staticReturnsTrue, On N4644 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4645 (Return edge from staticReturnsTrue to good38)
> takes the true branch, At N4646 of Function good38
> takes the true branch, At N4652 of Function good38
> Leaving function: good38, On N4639 -> N4675 (Return edge from good38 to main)
> Entering function: bad38, On N4675 -> N4592 (call bad38)
> Entering function: staticReturnsTrue, On N4596 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4597 (Return edge from staticReturnsTrue to bad38)
> takes the false branch, At N4598 of Function bad38
> Entering function: staticReturnsTrue, On N4610 -> N4726 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4725 -> N4611 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N4612 of Function bad38
<Defect> : N4615 -> N4617: [call void @free(i8* %5, i8* @free)]
N4615 -> N4617: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_38.c 77] bad38 		[N4615 -{call void @free(i8* %5, i8* @free)}-> N4617]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_38.c 77] bad38 		[N4615 -{call void @free(i8* %5, i8* @free)}-> N4617]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_38.c 77] bad38 		[N4615 -{call void @free(i8* %5, i8* @free)}-> N4617]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_39.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad39, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good39, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad39
P+ = [] 
P- = [H(bad39::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good39
P+ = [] 
P- = [H(good39::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad39::call), H(good39::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4797): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4756
On edge  : N4756 -{call void @free(i8* %5, i8* @free)}-> N4758
Message  : the memory is already freed
> Start from entry function: main, At N4797 of Function main
> Entering function: good39, On N4845 -> N4777 (call good39)
> takes the true branch, At N4786 of Function good39
> Leaving function: good39, On N4776 -> N4799 (Return edge from good39 to main)
> Entering function: bad39, On N4799 -> N4740 (call bad39)
> takes the false branch, At N4749 of Function bad39
<Defect> : N4756 -> N4758: [call void @free(i8* %5, i8* @free)]
N4756 -> N4758: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4756
On edge  : N4756 -{call void @free(i8* %5, i8* @free)}-> N4758
Message  : the memory is already freed
> Start from entry function: main, At N4797 of Function main
> Entering function: good39, On N4845 -> N4777 (call good39)
> takes the true branch, At N4786 of Function good39
> Leaving function: good39, On N4776 -> N4799 (Return edge from good39 to main)
> Entering function: bad39, On N4799 -> N4740 (call bad39)
> takes the false branch, At N4749 of Function bad39
<Defect> : N4756 -> N4758: [call void @free(i8* %5, i8* @free)]
N4756 -> N4758: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_39.c 67] bad39 		[N4756 -{call void @free(i8* %5, i8* @free)}-> N4758]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_39.c 67] bad39 		[N4756 -{call void @free(i8* %5, i8* @free)}-> N4758]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_40.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad40, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good40, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad40
P+ = [] 
P- = [N, H(bad40::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good40
P+ = [] 
P- = [H(good40::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad40::call), H(good40::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4936): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N4878
On edge  : N4878 -{call void @free(i8* %7, i8* @free)}-> N4880
Message  : the memory is already freed
> Start from entry function: main, At N4936 of Function main
> Entering function: good40, On N4984 -> N4903 (call good40)
> takes the true branch, At N4909 of Function good40
> takes the true branch, At N4915 of Function good40
> Leaving function: good40, On N4902 -> N4938 (Return edge from good40 to main)
> Entering function: bad40, On N4938 -> N4855 (call bad40)
> takes the false branch, At N4861 of Function bad40
> takes the true branch, At N4875 of Function bad40
<Defect> : N4878 -> N4880: [call void @free(i8* %7, i8* @free)]
N4878 -> N4880: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N4878
On edge  : N4878 -{call void @free(i8* %7, i8* @free)}-> N4880
Message  : null pointer dereference
> Start from entry function: main, At N4936 of Function main
> Entering function: good40, On N4984 -> N4903 (call good40)
> takes the true branch, At N4909 of Function good40
> takes the true branch, At N4915 of Function good40
> Leaving function: good40, On N4902 -> N4938 (Return edge from good40 to main)
> Entering function: bad40, On N4938 -> N4855 (call bad40)
> takes the false branch, At N4861 of Function bad40
> takes the true branch, At N4875 of Function bad40
<Defect> : N4878 -> N4880: [call void @free(i8* %7, i8* @free)]
N4878 -> N4880: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N4878
On edge  : N4878 -{call void @free(i8* %7, i8* @free)}-> N4880
Message  : the memory is already freed
> Start from entry function: main, At N4936 of Function main
> Entering function: good40, On N4984 -> N4903 (call good40)
> takes the true branch, At N4909 of Function good40
> takes the true branch, At N4915 of Function good40
> Leaving function: good40, On N4902 -> N4938 (Return edge from good40 to main)
> Entering function: bad40, On N4938 -> N4855 (call bad40)
> takes the false branch, At N4861 of Function bad40
> takes the true branch, At N4875 of Function bad40
<Defect> : N4878 -> N4880: [call void @free(i8* %7, i8* @free)]
N4878 -> N4880: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_40.c 67] bad40 		[N4878 -{call void @free(i8* %7, i8* @free)}-> N4880]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_40.c 67] bad40 		[N4878 -{call void @free(i8* %7, i8* @free)}-> N4880]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_40.c 67] bad40 		[N4878 -{call void @free(i8* %7, i8* @free)}-> N4880]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_41.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad41, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good41, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad41
P+ = [] 
P- = [H(bad41::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good41
P+ = [] 
P- = [H(good41::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad41::call), H(good41::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5052): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5011
On edge  : N5011 -{call void @free(i8* %5, i8* @free)}-> N5013
Message  : the memory is already freed
> Start from entry function: main, At N5052 of Function main
> Entering function: good41, On N5100 -> N5032 (call good41)
> takes the true branch, At N5041 of Function good41
> Leaving function: good41, On N5031 -> N5054 (Return edge from good41 to main)
> Entering function: bad41, On N5054 -> N4995 (call bad41)
> takes the false branch, At N5004 of Function bad41
<Defect> : N5011 -> N5013: [call void @free(i8* %5, i8* @free)]
N5011 -> N5013: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5011
On edge  : N5011 -{call void @free(i8* %5, i8* @free)}-> N5013
Message  : the memory is already freed
> Start from entry function: main, At N5052 of Function main
> Entering function: good41, On N5100 -> N5032 (call good41)
> takes the true branch, At N5041 of Function good41
> Leaving function: good41, On N5031 -> N5054 (Return edge from good41 to main)
> Entering function: bad41, On N5054 -> N4995 (call bad41)
> takes the false branch, At N5004 of Function bad41
<Defect> : N5011 -> N5013: [call void @free(i8* %5, i8* @free)]
N5011 -> N5013: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_41.c 62] bad41 		[N5011 -{call void @free(i8* %5, i8* @free)}-> N5013]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_41.c 62] bad41 		[N5011 -{call void @free(i8* %5, i8* @free)}-> N5013]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_42.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad42, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good42, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad42
P+ = [] 
P- = [H(bad42::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good42
P+ = [] 
P- = [H(good42::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad42::call), H(good42::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5167): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5126
On edge  : N5126 -{call void @free(i8* %5, i8* @free)}-> N5128
Message  : the memory is already freed
> Start from entry function: main, At N5167 of Function main
> Entering function: good42, On N5215 -> N5147 (call good42)
> takes the true branch, At N5156 of Function good42
> Leaving function: good42, On N5146 -> N5169 (Return edge from good42 to main)
> Entering function: bad42, On N5169 -> N5110 (call bad42)
> takes the false branch, At N5119 of Function bad42
<Defect> : N5126 -> N5128: [call void @free(i8* %5, i8* @free)]
N5126 -> N5128: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5126
On edge  : N5126 -{call void @free(i8* %5, i8* @free)}-> N5128
Message  : the memory is already freed
> Start from entry function: main, At N5167 of Function main
> Entering function: good42, On N5215 -> N5147 (call good42)
> takes the true branch, At N5156 of Function good42
> Leaving function: good42, On N5146 -> N5169 (Return edge from good42 to main)
> Entering function: bad42, On N5169 -> N5110 (call bad42)
> takes the false branch, At N5119 of Function bad42
<Defect> : N5126 -> N5128: [call void @free(i8* %5, i8* @free)]
N5126 -> N5128: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_42.c 67] bad42 		[N5126 -{call void @free(i8* %5, i8* @free)}-> N5128]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_42.c 67] bad42 		[N5126 -{call void @free(i8* %5, i8* @free)}-> N5128]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_43.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad43, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good43, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad43
P+ = [] 
P- = [H(bad43::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good43
P+ = [] 
P- = [H(good43::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad43::call), H(good43::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5282): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5241
On edge  : N5241 -{call void @free(i8* %5, i8* @free)}-> N5243
Message  : the memory is already freed
> Start from entry function: main, At N5282 of Function main
> Entering function: good43, On N5330 -> N5262 (call good43)
> takes the true branch, At N5271 of Function good43
> Leaving function: good43, On N5261 -> N5284 (Return edge from good43 to main)
> Entering function: bad43, On N5284 -> N5225 (call bad43)
> takes the false branch, At N5234 of Function bad43
<Defect> : N5241 -> N5243: [call void @free(i8* %5, i8* @free)]
N5241 -> N5243: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5241
On edge  : N5241 -{call void @free(i8* %5, i8* @free)}-> N5243
Message  : the memory is already freed
> Start from entry function: main, At N5282 of Function main
> Entering function: good43, On N5330 -> N5262 (call good43)
> takes the true branch, At N5271 of Function good43
> Leaving function: good43, On N5261 -> N5284 (Return edge from good43 to main)
> Entering function: bad43, On N5284 -> N5225 (call bad43)
> takes the false branch, At N5234 of Function bad43
<Defect> : N5241 -> N5243: [call void @free(i8* %5, i8* @free)]
N5241 -> N5243: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_43.c 67] bad43 		[N5241 -{call void @free(i8* %5, i8* @free)}-> N5243]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_43.c 67] bad43 		[N5241 -{call void @free(i8* %5, i8* @free)}-> N5243]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_44.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good44, main, printHexCharLine, printIntLine, printLine, printLongLine, bad44]
Loops     []
----
function: bad44
P+ = [] 
P- = [H(bad44::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good44
P+ = [] 
P- = [H(good44::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad44::call), H(good44::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.016s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5397): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5356
On edge  : N5356 -{call void @free(i8* %5, i8* @free)}-> N5358
Message  : the memory is already freed
> Start from entry function: main, At N5397 of Function main
> Entering function: good44, On N5445 -> N5377 (call good44)
> takes the true branch, At N5386 of Function good44
> Leaving function: good44, On N5376 -> N5399 (Return edge from good44 to main)
> Entering function: bad44, On N5399 -> N5340 (call bad44)
> takes the false branch, At N5349 of Function bad44
<Defect> : N5356 -> N5358: [call void @free(i8* %5, i8* @free)]
N5356 -> N5358: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5356
On edge  : N5356 -{call void @free(i8* %5, i8* @free)}-> N5358
Message  : the memory is already freed
> Start from entry function: main, At N5397 of Function main
> Entering function: good44, On N5445 -> N5377 (call good44)
> takes the true branch, At N5386 of Function good44
> Leaving function: good44, On N5376 -> N5399 (Return edge from good44 to main)
> Entering function: bad44, On N5399 -> N5340 (call bad44)
> takes the false branch, At N5349 of Function bad44
<Defect> : N5356 -> N5358: [call void @free(i8* %5, i8* @free)]
N5356 -> N5358: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_44.c 70] bad44 		[N5356 -{call void @free(i8* %5, i8* @free)}-> N5358]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_44.c 70] bad44 		[N5356 -{call void @free(i8* %5, i8* @free)}-> N5358]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_45.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad45, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good45, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad45
P+ = [] 
P- = [N, H(bad45::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good45
P+ = [] 
P- = [H(good45::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad45::call), H(good45::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5536): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5478
On edge  : N5478 -{call void @free(i8* %7, i8* @free)}-> N5480
Message  : the memory is already freed
> Start from entry function: main, At N5536 of Function main
> Entering function: good45, On N5584 -> N5503 (call good45)
> takes the true branch, At N5509 of Function good45
> takes the true branch, At N5515 of Function good45
> Leaving function: good45, On N5502 -> N5538 (Return edge from good45 to main)
> Entering function: bad45, On N5538 -> N5455 (call bad45)
> takes the false branch, At N5461 of Function bad45
> takes the true branch, At N5475 of Function bad45
<Defect> : N5478 -> N5480: [call void @free(i8* %7, i8* @free)]
N5478 -> N5480: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N5478
On edge  : N5478 -{call void @free(i8* %7, i8* @free)}-> N5480
Message  : null pointer dereference
> Start from entry function: main, At N5536 of Function main
> Entering function: good45, On N5584 -> N5503 (call good45)
> takes the true branch, At N5509 of Function good45
> takes the true branch, At N5515 of Function good45
> Leaving function: good45, On N5502 -> N5538 (Return edge from good45 to main)
> Entering function: bad45, On N5538 -> N5455 (call bad45)
> takes the false branch, At N5461 of Function bad45
> takes the true branch, At N5475 of Function bad45
<Defect> : N5478 -> N5480: [call void @free(i8* %7, i8* @free)]
N5478 -> N5480: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5478
On edge  : N5478 -{call void @free(i8* %7, i8* @free)}-> N5480
Message  : the memory is already freed
> Start from entry function: main, At N5536 of Function main
> Entering function: good45, On N5584 -> N5503 (call good45)
> takes the true branch, At N5509 of Function good45
> takes the true branch, At N5515 of Function good45
> Leaving function: good45, On N5502 -> N5538 (Return edge from good45 to main)
> Entering function: bad45, On N5538 -> N5455 (call bad45)
> takes the false branch, At N5461 of Function bad45
> takes the true branch, At N5475 of Function bad45
<Defect> : N5478 -> N5480: [call void @free(i8* %7, i8* @free)]
N5478 -> N5480: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_45.c 70] bad45 		[N5478 -{call void @free(i8* %7, i8* @free)}-> N5480]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_45.c 70] bad45 		[N5478 -{call void @free(i8* %7, i8* @free)}-> N5480]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_45.c 70] bad45 		[N5478 -{call void @free(i8* %7, i8* @free)}-> N5480]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_46.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good46, main, printHexCharLine, printIntLine, printLine, printLongLine, bad46]
Loops     []
----
function: bad46
P+ = [] 
P- = [H(bad46::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good46
P+ = [] 
P- = [H(good46::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad46::call), H(good46::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.017s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5654): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5613
On edge  : N5613 -{call void @free(i8* %5, i8* @free)}-> N5615
Message  : the memory is already freed
> Start from entry function: main, At N5654 of Function main
> Entering function: good46, On N5702 -> N5634 (call good46)
> takes the true branch, At N5643 of Function good46
> Leaving function: good46, On N5633 -> N5656 (Return edge from good46 to main)
> Entering function: bad46, On N5656 -> N5597 (call bad46)
> takes the false branch, At N5606 of Function bad46
<Defect> : N5613 -> N5615: [call void @free(i8* %5, i8* @free)]
N5613 -> N5615: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5613
On edge  : N5613 -{call void @free(i8* %5, i8* @free)}-> N5615
Message  : the memory is already freed
> Start from entry function: main, At N5654 of Function main
> Entering function: good46, On N5702 -> N5634 (call good46)
> takes the true branch, At N5643 of Function good46
> Leaving function: good46, On N5633 -> N5656 (Return edge from good46 to main)
> Entering function: bad46, On N5656 -> N5597 (call bad46)
> takes the false branch, At N5606 of Function bad46
<Defect> : N5613 -> N5615: [call void @free(i8* %5, i8* @free)]
N5613 -> N5615: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_46.c 69] bad46 		[N5613 -{call void @free(i8* %5, i8* @free)}-> N5615]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_46.c 69] bad46 		[N5613 -{call void @free(i8* %5, i8* @free)}-> N5615]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_47.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad47, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good47, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad47
P+ = [] 
P- = [N, H(bad47::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good47
P+ = [] 
P- = [H(good47::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad47::call), H(good47::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5793): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5735
On edge  : N5735 -{call void @free(i8* %7, i8* @free)}-> N5737
Message  : the memory is already freed
> Start from entry function: main, At N5793 of Function main
> Entering function: good47, On N5841 -> N5760 (call good47)
> takes the true branch, At N5766 of Function good47
> takes the true branch, At N5772 of Function good47
> Leaving function: good47, On N5759 -> N5795 (Return edge from good47 to main)
> Entering function: bad47, On N5795 -> N5712 (call bad47)
> takes the false branch, At N5718 of Function bad47
> takes the true branch, At N5732 of Function bad47
<Defect> : N5735 -> N5737: [call void @free(i8* %7, i8* @free)]
N5735 -> N5737: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N5735
On edge  : N5735 -{call void @free(i8* %7, i8* @free)}-> N5737
Message  : null pointer dereference
> Start from entry function: main, At N5793 of Function main
> Entering function: good47, On N5841 -> N5760 (call good47)
> takes the true branch, At N5766 of Function good47
> takes the true branch, At N5772 of Function good47
> Leaving function: good47, On N5759 -> N5795 (Return edge from good47 to main)
> Entering function: bad47, On N5795 -> N5712 (call bad47)
> takes the false branch, At N5718 of Function bad47
> takes the true branch, At N5732 of Function bad47
<Defect> : N5735 -> N5737: [call void @free(i8* %7, i8* @free)]
N5735 -> N5737: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5735
On edge  : N5735 -{call void @free(i8* %7, i8* @free)}-> N5737
Message  : the memory is already freed
> Start from entry function: main, At N5793 of Function main
> Entering function: good47, On N5841 -> N5760 (call good47)
> takes the true branch, At N5766 of Function good47
> takes the true branch, At N5772 of Function good47
> Leaving function: good47, On N5759 -> N5795 (Return edge from good47 to main)
> Entering function: bad47, On N5795 -> N5712 (call bad47)
> takes the false branch, At N5718 of Function bad47
> takes the true branch, At N5732 of Function bad47
<Defect> : N5735 -> N5737: [call void @free(i8* %7, i8* @free)]
N5735 -> N5737: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_47.c 69] bad47 		[N5735 -{call void @free(i8* %7, i8* @free)}-> N5737]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_47.c 69] bad47 		[N5735 -{call void @free(i8* %7, i8* @free)}-> N5737]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_47.c 69] bad47 		[N5735 -{call void @free(i8* %7, i8* @free)}-> N5737]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_48.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good48, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue, bad48]
Loops     []
----
function: bad48
P+ = [] 
P- = [N, H(bad48::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good48
P+ = [] 
P- = [H(good48::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad48::call1), H(good48::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.018s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5934): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N5876
On edge  : N5876 -{call void @free(i8* %5, i8* @free)}-> N5878
Message  : the memory is already freed
> Start from entry function: main, At N5934 of Function main
> Entering function: good48, On N5990 -> N5901 (call good48)
> Entering function: staticReturnsTrue, On N5905 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5906 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N5907 of Function good48
> takes the true branch, At N5913 of Function good48
> Leaving function: good48, On N5900 -> N5936 (Return edge from good48 to main)
> Entering function: bad48, On N5936 -> N5853 (call bad48)
> Entering function: staticReturnsTrue, On N5857 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5858 (Return edge from staticReturnsTrue to bad48)
> takes the false branch, At N5859 of Function bad48
> Entering function: staticReturnsTrue, On N5871 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5872 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N5873 of Function bad48
<Defect> : N5876 -> N5878: [call void @free(i8* %5, i8* @free)]
N5876 -> N5878: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N5876
On edge  : N5876 -{call void @free(i8* %5, i8* @free)}-> N5878
Message  : null pointer dereference
> Start from entry function: main, At N5934 of Function main
> Entering function: good48, On N5990 -> N5901 (call good48)
> Entering function: staticReturnsTrue, On N5905 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5906 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N5907 of Function good48
> takes the true branch, At N5913 of Function good48
> Leaving function: good48, On N5900 -> N5936 (Return edge from good48 to main)
> Entering function: bad48, On N5936 -> N5853 (call bad48)
> Entering function: staticReturnsTrue, On N5857 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5858 (Return edge from staticReturnsTrue to bad48)
> takes the false branch, At N5859 of Function bad48
> Entering function: staticReturnsTrue, On N5871 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5872 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N5873 of Function bad48
<Defect> : N5876 -> N5878: [call void @free(i8* %5, i8* @free)]
N5876 -> N5878: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N5876
On edge  : N5876 -{call void @free(i8* %5, i8* @free)}-> N5878
Message  : the memory is already freed
> Start from entry function: main, At N5934 of Function main
> Entering function: good48, On N5990 -> N5901 (call good48)
> Entering function: staticReturnsTrue, On N5905 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5906 (Return edge from staticReturnsTrue to good48)
> takes the true branch, At N5907 of Function good48
> takes the true branch, At N5913 of Function good48
> Leaving function: good48, On N5900 -> N5936 (Return edge from good48 to main)
> Entering function: bad48, On N5936 -> N5853 (call bad48)
> Entering function: staticReturnsTrue, On N5857 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5858 (Return edge from staticReturnsTrue to bad48)
> takes the false branch, At N5859 of Function bad48
> Entering function: staticReturnsTrue, On N5871 -> N5987 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N5986 -> N5872 (Return edge from staticReturnsTrue to bad48)
> takes the true branch, At N5873 of Function bad48
<Defect> : N5876 -> N5878: [call void @free(i8* %5, i8* @free)]
N5876 -> N5878: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_48.c 77] bad48 		[N5876 -{call void @free(i8* %5, i8* @free)}-> N5878]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_48.c 77] bad48 		[N5876 -{call void @free(i8* %5, i8* @free)}-> N5878]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_48.c 77] bad48 		[N5876 -{call void @free(i8* %5, i8* @free)}-> N5878]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_49.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad49, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good49, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad49
P+ = [] 
P- = [H(bad49::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good49
P+ = [] 
P- = [H(good49::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad49::call), H(good49::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6058): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N6017
On edge  : N6017 -{call void @free(i8* %5, i8* @free)}-> N6019
Message  : the memory is already freed
> Start from entry function: main, At N6058 of Function main
> Entering function: good49, On N6106 -> N6038 (call good49)
> takes the true branch, At N6047 of Function good49
> Leaving function: good49, On N6037 -> N6060 (Return edge from good49 to main)
> Entering function: bad49, On N6060 -> N6001 (call bad49)
> takes the false branch, At N6010 of Function bad49
<Defect> : N6017 -> N6019: [call void @free(i8* %5, i8* @free)]
N6017 -> N6019: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N6017
On edge  : N6017 -{call void @free(i8* %5, i8* @free)}-> N6019
Message  : the memory is already freed
> Start from entry function: main, At N6058 of Function main
> Entering function: good49, On N6106 -> N6038 (call good49)
> takes the true branch, At N6047 of Function good49
> Leaving function: good49, On N6037 -> N6060 (Return edge from good49 to main)
> Entering function: bad49, On N6060 -> N6001 (call bad49)
> takes the false branch, At N6010 of Function bad49
<Defect> : N6017 -> N6019: [call void @free(i8* %5, i8* @free)]
N6017 -> N6019: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_49.c 67] bad49 		[N6017 -{call void @free(i8* %5, i8* @free)}-> N6019]	(the memory is already freed)

CWE_416(Use After Free): 1
	[./415_49.c 67] bad49 		[N6017 -{call void @free(i8* %5, i8* @free)}-> N6019]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/415/415_50.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad50, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good50, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad50
P+ = [] 
P- = [N, H(bad50::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good50
P+ = [] 
P- = [H(good50::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [N, H(bad50::call), H(good50::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6197): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Double Free
At node  : N6139
On edge  : N6139 -{call void @free(i8* %7, i8* @free)}-> N6141
Message  : the memory is already freed
> Start from entry function: main, At N6197 of Function main
> Entering function: good50, On N6245 -> N6164 (call good50)
> takes the true branch, At N6170 of Function good50
> takes the true branch, At N6176 of Function good50
> Leaving function: good50, On N6163 -> N6199 (Return edge from good50 to main)
> Entering function: bad50, On N6199 -> N6116 (call bad50)
> takes the false branch, At N6122 of Function bad50
> takes the true branch, At N6136 of Function bad50
<Defect> : N6139 -> N6141: [call void @free(i8* %7, i8* @free)]
N6139 -> N6141: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N6139
On edge  : N6139 -{call void @free(i8* %7, i8* @free)}-> N6141
Message  : null pointer dereference
> Start from entry function: main, At N6197 of Function main
> Entering function: good50, On N6245 -> N6164 (call good50)
> takes the true branch, At N6170 of Function good50
> takes the true branch, At N6176 of Function good50
> Leaving function: good50, On N6163 -> N6199 (Return edge from good50 to main)
> Entering function: bad50, On N6199 -> N6116 (call bad50)
> takes the false branch, At N6122 of Function bad50
> takes the true branch, At N6136 of Function bad50
<Defect> : N6139 -> N6141: [call void @free(i8* %7, i8* @free)]
N6139 -> N6141: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N6139
On edge  : N6139 -{call void @free(i8* %7, i8* @free)}-> N6141
Message  : the memory is already freed
> Start from entry function: main, At N6197 of Function main
> Entering function: good50, On N6245 -> N6164 (call good50)
> takes the true branch, At N6170 of Function good50
> takes the true branch, At N6176 of Function good50
> Leaving function: good50, On N6163 -> N6199 (Return edge from good50 to main)
> Entering function: bad50, On N6199 -> N6116 (call bad50)
> takes the false branch, At N6122 of Function bad50
> takes the true branch, At N6136 of Function bad50
<Defect> : N6139 -> N6141: [call void @free(i8* %7, i8* @free)]
N6139 -> N6141: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_415(Double Free): 1
	[./415_50.c 67] bad50 		[N6139 -{call void @free(i8* %7, i8* @free)}-> N6141]	(the memory is already freed)

CWE_476(Null Pointer Dereference): 1
	[./415_50.c 67] bad50 		[N6139 -{call void @free(i8* %7, i8* @free)}-> N6141]	(null pointer dereference)

CWE_416(Use After Free): 1
	[./415_50.c 67] bad50 		[N6139 -{call void @free(i8* %7, i8* @free)}-> N6141]	(the memory is already freed)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 0
