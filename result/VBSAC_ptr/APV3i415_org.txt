/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=42684:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.AP_ITC_415_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_010_bad]
 +double_free_010_bad
SCC(1): [double_free_010_good]
 +double_free_010_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_010_bad, double_free_010_good, main]
Loops     [N46, N14]
----
function: double_free_010_bad
P+ = [] 
P- = [H(double_free_010_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_010_good
P+ = [] 
P- = [H(double_free_010_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_010_bad::call), H(double_free_010_good::call)] 
Point-To:

Ret-Value: R
----
loop N14 in double_free_010_bad: 
N14 -> P+ = [H(double_free_010_bad::call)], P- = [H(double_free_010_bad::call)] Point-To: L(double_free_010_bad::ptr) -> [H(double_free_010_bad::call)]
N16 -> P+ = [H(double_free_010_bad::call)], P- = [H(double_free_010_bad::call)] Point-To: L(double_free_010_bad::ptr) -> [H(double_free_010_bad::call)]
----
loop N46 in double_free_010_good: 
N46 -> P+ = [H(double_free_010_good::call)], P- = [H(double_free_010_good::call)] Point-To: L(double_free_010_good::ptr) -> [H(double_free_010_good::call)]
N48 -> P+ = [H(double_free_010_good::call)], P- = [H(double_free_010_good::call)] Point-To: L(double_free_010_good::ptr) -> [H(double_free_010_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.359s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N62): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N51
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
<Defect> : N50 -> N51: [call void @free(i8* %2, i8* @free)]
N50 -> N51: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N18
On edge  : N18 -{call void @free(i8* %2, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
<Defect> : N18 -> N19: [call void @free(i8* %2, i8* @free)]
N18 -> N19: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the false branch, At N16 of Function double_free_010_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N50
On edge  : N50 -{call void @free(i8* %2, i8* @free)}-> N51
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
> takes the true branch, At N48 of Function double_free_010_good
<Defect> : N50 -> N51: [call void @free(i8* %2, i8* @free)]
N50 -> N51: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N18
On edge  : N18 -{call void @free(i8* %2, i8* @free)}-> N19
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
<Defect> : N18 -> N19: [call void @free(i8* %2, i8* @free)]
N18 -> N19: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N24
On edge  : N24 -{call void @free(i8* %4, i8* @free)}-> N26
Message  : the memory is already freed
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
> Leaving function: double_free_010_good, On N32 -> N66 (Return edge from double_free_010_good to main)
> Entering function: double_free_010_bad, On N66 -> N1 (call double_free_010_bad)
> takes the false branch, At N9 of Function double_free_010_bad
> takes the true branch, At N16 of Function double_free_010_bad
> takes the false branch, At N16 of Function double_free_010_bad
<Defect> : N24 -> N26: [call void @free(i8* %4, i8* @free)]
N24 -> N26: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N32
On edge  : N32 -{Return edge from double_free_010_good to main}-> N66
Message  : the heap object @H(double_free_010_good::call) is not referenced any more
> Start from entry function: main, At N62 of Function main
> Entering function: double_free_010_good, On N65 -> N33 (call double_free_010_good)
> takes the false branch, At N41 of Function double_free_010_good
> takes the false branch, At N48 of Function double_free_010_good
<Defect> : N32 -> N66: [Return edge from double_free_010_good to main]
N32 -> N66: [Return edge from double_free_010_good to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 3
	[./415_double_free_10.c 45] double_free_010_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N51]	(the memory is already freed)
	[./415_double_free_10.c 26] double_free_010_bad 		[N18 -{call void @free(i8* %2, i8* @free)}-> N19]	(the memory is already freed)
	[./415_double_free_10.c 29] double_free_010_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_415(Double Free): 3
	[./415_double_free_10.c 45] double_free_010_good 		[N50 -{call void @free(i8* %2, i8* @free)}-> N51]	(the memory is already freed)
	[./415_double_free_10.c 26] double_free_010_bad 		[N18 -{call void @free(i8* %2, i8* @free)}-> N19]	(the memory is already freed)
	[./415_double_free_10.c 29] double_free_010_bad 		[N24 -{call void @free(i8* %4, i8* @free)}-> N26]	(the memory is already freed)

CWE_401(Memory Leak): 1
	[./415_double_free_10.c 52] double_free_010_good 		[N32 -{Return edge from double_free_010_good to main}-> N66]	(the heap object @H(double_free_010_good::call) is not referenced any more)

Found 7 defects in all (115 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :3
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_10$9(AP_ITC_415_Test.java:154)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_10(AP_ITC_415_Test.java:153)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_011_bad]
 +double_free_011_bad
SCC(1): [double_free_011_good]
 +double_free_011_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_011_good, main, double_free_011_bad]
Loops     [N99, N131]
----
function: double_free_011_bad
P+ = [] 
P- = [H(double_free_011_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_011_good
P+ = [] 
P- = [H(double_free_011_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_011_bad::call), H(double_free_011_good::call)] 
Point-To:

Ret-Value: R
----
loop N99 in double_free_011_bad: 
N89 -> P+ = [H(double_free_011_bad::call)], P- = [H(double_free_011_bad::call)] Point-To: L(double_free_011_bad::ptr) -> [H(double_free_011_bad::call)]
N92 -> P+ = [H(double_free_011_bad::call)], P- = [H(double_free_011_bad::call)] Point-To: L(double_free_011_bad::ptr) -> [H(double_free_011_bad::call)]
----
loop N131 in double_free_011_good: 
N131 -> P+ = [H(double_free_011_good::call)], P- = [H(double_free_011_good::call)] Point-To: L(double_free_011_good::ptr) -> [H(double_free_011_good::call)]
N134 -> P+ = [H(double_free_011_good::call)], P- = [H(double_free_011_good::call)] Point-To: L(double_free_011_good::ptr) -> [H(double_free_011_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.035s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N154): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N139
On edge  : N139 -{call void @free(i8* %4, i8* @free)}-> N141
Message  : the memory is already freed
> Start from entry function: main, At N154 of Function main
> Entering function: double_free_011_good, On N157 -> N112 (call double_free_011_good)
> takes the false branch, At N122 of Function double_free_011_good
> takes the true branch, At N134 of Function double_free_011_good
> takes the true branch, At N137 of Function double_free_011_good
> takes the true branch, At N134 of Function double_free_011_good
> takes the true branch, At N137 of Function double_free_011_good
<Defect> : N139 -> N141: [call void @free(i8* %4, i8* @free)]
N139 -> N141: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N97
On edge  : N97 -{call void @free(i8* %4, i8* @free)}-> N99
Message  : the memory is already freed
> Start from entry function: main, At N154 of Function main
> Entering function: double_free_011_good, On N157 -> N112 (call double_free_011_good)
> takes the true branch, At N122 of Function double_free_011_good
> Leaving function: double_free_011_good, On N111 -> N158 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N158 -> N70 (call double_free_011_bad)
> takes the false branch, At N80 of Function double_free_011_bad
> takes the true branch, At N92 of Function double_free_011_bad
> takes the true branch, At N95 of Function double_free_011_bad
> takes the true branch, At N92 of Function double_free_011_bad
> takes the true branch, At N95 of Function double_free_011_bad
<Defect> : N97 -> N99: [call void @free(i8* %4, i8* @free)]
N97 -> N99: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N139
On edge  : N139 -{call void @free(i8* %4, i8* @free)}-> N141
Message  : the memory is already freed
> Start from entry function: main, At N154 of Function main
> Entering function: double_free_011_good, On N157 -> N112 (call double_free_011_good)
> takes the false branch, At N122 of Function double_free_011_good
> takes the true branch, At N134 of Function double_free_011_good
> takes the true branch, At N137 of Function double_free_011_good
> takes the true branch, At N134 of Function double_free_011_good
> takes the true branch, At N137 of Function double_free_011_good
<Defect> : N139 -> N141: [call void @free(i8* %4, i8* @free)]
N139 -> N141: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N97
On edge  : N97 -{call void @free(i8* %4, i8* @free)}-> N99
Message  : the memory is already freed
> Start from entry function: main, At N154 of Function main
> Entering function: double_free_011_good, On N157 -> N112 (call double_free_011_good)
> takes the true branch, At N122 of Function double_free_011_good
> Leaving function: double_free_011_good, On N111 -> N158 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N158 -> N70 (call double_free_011_bad)
> takes the false branch, At N80 of Function double_free_011_bad
> takes the true branch, At N92 of Function double_free_011_bad
> takes the true branch, At N95 of Function double_free_011_bad
> takes the true branch, At N92 of Function double_free_011_bad
> takes the true branch, At N95 of Function double_free_011_bad
<Defect> : N97 -> N99: [call void @free(i8* %4, i8* @free)]
N97 -> N99: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N111
On edge  : N111 -{Return edge from double_free_011_good to main}-> N158
Message  : the heap object @H(double_free_011_good::call) is not referenced any more
> Start from entry function: main, At N154 of Function main
> Entering function: double_free_011_good, On N157 -> N112 (call double_free_011_good)
> takes the false branch, At N122 of Function double_free_011_good
> takes the false branch, At N134 of Function double_free_011_good
<Defect> : N111 -> N158: [Return edge from double_free_011_good to main]
N111 -> N158: [Return edge from double_free_011_good to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N69
On edge  : N69 -{Return edge from double_free_011_bad to main}-> N159
Message  : the heap object @H(double_free_011_bad::call) is not referenced any more
> Start from entry function: main, At N154 of Function main
> Entering function: double_free_011_good, On N157 -> N112 (call double_free_011_good)
> takes the true branch, At N122 of Function double_free_011_good
> Leaving function: double_free_011_good, On N111 -> N158 (Return edge from double_free_011_good to main)
> Entering function: double_free_011_bad, On N158 -> N70 (call double_free_011_bad)
> takes the false branch, At N80 of Function double_free_011_bad
> takes the false branch, At N92 of Function double_free_011_bad
<Defect> : N69 -> N159: [Return edge from double_free_011_bad to main]
N69 -> N159: [Return edge from double_free_011_bad to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 2
	[./415_double_free_11.c 46] double_free_011_good 		[N139 -{call void @free(i8* %4, i8* @free)}-> N141]	(the memory is already freed)
	[./415_double_free_11.c 27] double_free_011_bad 		[N97 -{call void @free(i8* %4, i8* @free)}-> N99]	(the memory is already freed)

CWE_415(Double Free): 2
	[./415_double_free_11.c 46] double_free_011_good 		[N139 -{call void @free(i8* %4, i8* @free)}-> N141]	(the memory is already freed)
	[./415_double_free_11.c 27] double_free_011_bad 		[N97 -{call void @free(i8* %4, i8* @free)}-> N99]	(the memory is already freed)

CWE_401(Memory Leak): 2
	[./415_double_free_11.c 58] double_free_011_good 		[N111 -{Return edge from double_free_011_good to main}-> N158]	(the heap object @H(double_free_011_good::call) is not referenced any more)
	[./415_double_free_11.c 59] double_free_011_bad 		[N69 -{Return edge from double_free_011_bad to main}-> N159]	(the heap object @H(double_free_011_bad::call) is not referenced any more)

Found 6 defects in all (121 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_11$10(AP_ITC_415_Test.java:166)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_11(AP_ITC_415_Test.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_012_bad]
 +double_free_012_bad
SCC(1): [double_free_012_good]
 +double_free_012_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_012_bad, double_free_012_good, main]
Loops     [N176, N207]
----
function: double_free_012_bad
P+ = [] 
P- = [H(double_free_012_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_012_good
P+ = [] 
P- = [H(double_free_012_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_012_bad::call), H(double_free_012_good::call)] 
Point-To:

Ret-Value: R
----
loop N176 in double_free_012_bad: 
N176 -> P+ = [H(double_free_012_bad::call)], P- = [H(double_free_012_bad::call)] Point-To: L(double_free_012_bad::ptr) -> [H(double_free_012_bad::call)]
N178 -> P+ = [H(double_free_012_bad::call)], P- = [H(double_free_012_bad::call)] Point-To: L(double_free_012_bad::ptr) -> [H(double_free_012_bad::call)]
----
loop N207 in double_free_012_good: 
N207 -> P+ = [H(double_free_012_good::call)], P- = [H(double_free_012_good::call)] Point-To: L(double_free_012_good::ptr) -> [H(double_free_012_good::call)]
N209 -> P+ = [H(double_free_012_good::call)], P- = [H(double_free_012_good::call)] Point-To: L(double_free_012_good::ptr) -> [H(double_free_012_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N224): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N211
On edge  : N211 -{call void @free(i8* %2, i8* @free)}-> N213
Message  : the memory is already freed
> Start from entry function: main, At N224 of Function main
> Entering function: double_free_012_good, On N227 -> N193 (call double_free_012_good)
> takes the false branch, At N201 of Function double_free_012_good
> takes the true branch, At N209 of Function double_free_012_good
> takes the true branch, At N209 of Function double_free_012_good
<Defect> : N211 -> N213: [call void @free(i8* %2, i8* @free)]
N211 -> N213: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N180
On edge  : N180 -{call void @free(i8* %2, i8* @free)}-> N182
Message  : the memory is already freed
> Start from entry function: main, At N224 of Function main
> Entering function: double_free_012_good, On N227 -> N193 (call double_free_012_good)
> takes the false branch, At N201 of Function double_free_012_good
> takes the false branch, At N209 of Function double_free_012_good
> Leaving function: double_free_012_good, On N192 -> N228 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N228 -> N162 (call double_free_012_bad)
> takes the false branch, At N170 of Function double_free_012_bad
> takes the true branch, At N178 of Function double_free_012_bad
> takes the true branch, At N178 of Function double_free_012_bad
<Defect> : N180 -> N182: [call void @free(i8* %2, i8* @free)]
N180 -> N182: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N211
On edge  : N211 -{call void @free(i8* %2, i8* @free)}-> N213
Message  : the memory is already freed
> Start from entry function: main, At N224 of Function main
> Entering function: double_free_012_good, On N227 -> N193 (call double_free_012_good)
> takes the false branch, At N201 of Function double_free_012_good
> takes the true branch, At N209 of Function double_free_012_good
> takes the true branch, At N209 of Function double_free_012_good
<Defect> : N211 -> N213: [call void @free(i8* %2, i8* @free)]
N211 -> N213: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N180
On edge  : N180 -{call void @free(i8* %2, i8* @free)}-> N182
Message  : the memory is already freed
> Start from entry function: main, At N224 of Function main
> Entering function: double_free_012_good, On N227 -> N193 (call double_free_012_good)
> takes the false branch, At N201 of Function double_free_012_good
> takes the false branch, At N209 of Function double_free_012_good
> Leaving function: double_free_012_good, On N192 -> N228 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N228 -> N162 (call double_free_012_bad)
> takes the false branch, At N170 of Function double_free_012_bad
> takes the true branch, At N178 of Function double_free_012_bad
> takes the true branch, At N178 of Function double_free_012_bad
<Defect> : N180 -> N182: [call void @free(i8* %2, i8* @free)]
N180 -> N182: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N192
On edge  : N192 -{Return edge from double_free_012_good to main}-> N228
Message  : the heap object @H(double_free_012_good::call) is not referenced any more
> Start from entry function: main, At N224 of Function main
> Entering function: double_free_012_good, On N227 -> N193 (call double_free_012_good)
> takes the false branch, At N201 of Function double_free_012_good
> takes the false branch, At N209 of Function double_free_012_good
<Defect> : N192 -> N228: [Return edge from double_free_012_good to main]
N192 -> N228: [Return edge from double_free_012_good to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N161
On edge  : N161 -{Return edge from double_free_012_bad to main}-> N229
Message  : the heap object @H(double_free_012_bad::call) is not referenced any more
> Start from entry function: main, At N224 of Function main
> Entering function: double_free_012_good, On N227 -> N193 (call double_free_012_good)
> takes the false branch, At N201 of Function double_free_012_good
> takes the false branch, At N209 of Function double_free_012_good
> Leaving function: double_free_012_good, On N192 -> N228 (Return edge from double_free_012_good to main)
> Entering function: double_free_012_bad, On N228 -> N162 (call double_free_012_bad)
> takes the false branch, At N170 of Function double_free_012_bad
> takes the false branch, At N178 of Function double_free_012_bad
<Defect> : N161 -> N229: [Return edge from double_free_012_bad to main]
N161 -> N229: [Return edge from double_free_012_bad to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 2
	[./415_double_free_12.c 43] double_free_012_good 		[N211 -{call void @free(i8* %2, i8* @free)}-> N213]	(the memory is already freed)
	[./415_double_free_12.c 26] double_free_012_bad 		[N180 -{call void @free(i8* %2, i8* @free)}-> N182]	(the memory is already freed)

CWE_415(Double Free): 2
	[./415_double_free_12.c 43] double_free_012_good 		[N211 -{call void @free(i8* %2, i8* @free)}-> N213]	(the memory is already freed)
	[./415_double_free_12.c 26] double_free_012_bad 		[N180 -{call void @free(i8* %2, i8* @free)}-> N182]	(the memory is already freed)

CWE_401(Memory Leak): 2
	[./415_double_free_12.c 54] double_free_012_good 		[N192 -{Return edge from double_free_012_good to main}-> N228]	(the heap object @H(double_free_012_good::call) is not referenced any more)
	[./415_double_free_12.c 55] double_free_012_bad 		[N161 -{Return edge from double_free_012_bad to main}-> N229]	(the heap object @H(double_free_012_bad::call) is not referenced any more)

Found 6 defects in all (121 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_12$11(AP_ITC_415_Test.java:178)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_12(AP_ITC_415_Test.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_001_bad]
 +double_free_001_bad
SCC(1): [double_free_001_good]
 +double_free_001_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_001_bad, double_free_001_good, main]
Loops     []
----
function: double_free_001_bad
P+ = [] 
P- = [H(double_free_001_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_001_good
P+ = [] 
P- = [H(double_free_001_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_001_bad::call), H(double_free_001_good::call)] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N268): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N244
On edge  : N244 -{call void @free(i8* %2, i8* @free)}-> N246
Message  : the memory is already freed
> Start from entry function: main, At N268 of Function main
> Entering function: double_free_001_good, On N271 -> N251 (call double_free_001_good)
> takes the true branch, At N258 of Function double_free_001_good
> Leaving function: double_free_001_good, On N250 -> N272 (Return edge from double_free_001_good to main)
> Entering function: double_free_001_bad, On N272 -> N232 (call double_free_001_bad)
> takes the false branch, At N239 of Function double_free_001_bad
<Defect> : N244 -> N246: [call void @free(i8* %2, i8* @free)]
N244 -> N246: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N244
On edge  : N244 -{call void @free(i8* %2, i8* @free)}-> N246
Message  : the memory is already freed
> Start from entry function: main, At N268 of Function main
> Entering function: double_free_001_good, On N271 -> N251 (call double_free_001_good)
> takes the true branch, At N258 of Function double_free_001_good
> Leaving function: double_free_001_good, On N250 -> N272 (Return edge from double_free_001_good to main)
> Entering function: double_free_001_bad, On N272 -> N232 (call double_free_001_bad)
> takes the false branch, At N239 of Function double_free_001_bad
<Defect> : N244 -> N246: [call void @free(i8* %2, i8* @free)]
N244 -> N246: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_1.c 24] double_free_001_bad 		[N244 -{call void @free(i8* %2, i8* @free)}-> N246]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_1.c 24] double_free_001_bad 		[N244 -{call void @free(i8* %2, i8* @free)}-> N246]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_002_bad]
 +double_free_002_bad
SCC(1): [double_free_002_good]
 +double_free_002_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, double_free_002_bad, double_free_002_good]
Loops     [N348, N289]
----
function: double_free_002_bad
P+ = [] 
P- = [H(double_free_002_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_002_good
P+ = [] 
P- = [H(double_free_002_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_002_bad::call), H(double_free_002_good::call)] 
Point-To:

Ret-Value: R
----
loop N289 in double_free_002_bad: 
N289 -> P+ = [H(double_free_002_bad::call)], P- = [H(double_free_002_bad::call)] Point-To: L(double_free_002_bad::ptr) -> [H(double_free_002_bad::call)]
N291 -> P+ = [H(double_free_002_bad::call)], P- = [H(double_free_002_bad::call)] Point-To: L(double_free_002_bad::ptr) -> [H(double_free_002_bad::call)]
----
loop N348 in double_free_002_good: 
N333 -> P+ = [H(double_free_002_good::call)], P- = [H(double_free_002_good::call)] Point-To: L(double_free_002_good::ptr) -> [H(double_free_002_good::call)]
N335 -> P+ = [H(double_free_002_good::call)], P- = [H(double_free_002_good::call)] Point-To: L(double_free_002_good::ptr) -> [H(double_free_002_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.042s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N364): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N340
On edge  : N340 -{store i8 97, i8* %arrayidx, align 1}-> N341
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the false branch, At N328 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
<Defect> : N340 -> N341: [store i8 97, i8* %arrayidx, align 1]
N340 -> N341: [store i8 97, i8* %arrayidx, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N345
On edge  : N345 -{call void @free(i8* %5, i8* @free)}-> N348
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the false branch, At N328 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
<Defect> : N345 -> N348: [call void @free(i8* %5, i8* @free)]
N345 -> N348: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N353
On edge  : N353 -{call void @free(i8* %7, i8* @free)}-> N355
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the false branch, At N328 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
> takes the false branch, At N335 of Function double_free_002_good
<Defect> : N353 -> N355: [call void @free(i8* %7, i8* @free)]
N353 -> N355: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N296
On edge  : N296 -{store i8 97, i8* %arrayidx, align 1}-> N297
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the true branch, At N328 of Function double_free_002_good
> Leaving function: double_free_002_good, On N319 -> N368 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N368 -> N276 (call double_free_002_bad)
> takes the false branch, At N284 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
<Defect> : N296 -> N297: [store i8 97, i8* %arrayidx, align 1]
N296 -> N297: [store i8 97, i8* %arrayidx, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N301
On edge  : N301 -{call void @free(i8* %5, i8* @free)}-> N304
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the true branch, At N328 of Function double_free_002_good
> Leaving function: double_free_002_good, On N319 -> N368 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N368 -> N276 (call double_free_002_bad)
> takes the false branch, At N284 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
<Defect> : N301 -> N304: [call void @free(i8* %5, i8* @free)]
N301 -> N304: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N309
On edge  : N309 -{call void @free(i8* %7, i8* @free)}-> N311
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the true branch, At N328 of Function double_free_002_good
> Leaving function: double_free_002_good, On N319 -> N368 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N368 -> N276 (call double_free_002_bad)
> takes the false branch, At N284 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
> takes the false branch, At N291 of Function double_free_002_bad
<Defect> : N309 -> N311: [call void @free(i8* %7, i8* @free)]
N309 -> N311: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N345
On edge  : N345 -{call void @free(i8* %5, i8* @free)}-> N348
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the false branch, At N328 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
<Defect> : N345 -> N348: [call void @free(i8* %5, i8* @free)]
N345 -> N348: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N353
On edge  : N353 -{call void @free(i8* %7, i8* @free)}-> N355
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the false branch, At N328 of Function double_free_002_good
> takes the true branch, At N335 of Function double_free_002_good
> takes the true branch, At N343 of Function double_free_002_good
> takes the false branch, At N335 of Function double_free_002_good
<Defect> : N353 -> N355: [call void @free(i8* %7, i8* @free)]
N353 -> N355: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N301
On edge  : N301 -{call void @free(i8* %5, i8* @free)}-> N304
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the true branch, At N328 of Function double_free_002_good
> Leaving function: double_free_002_good, On N319 -> N368 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N368 -> N276 (call double_free_002_bad)
> takes the false branch, At N284 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
<Defect> : N301 -> N304: [call void @free(i8* %5, i8* @free)]
N301 -> N304: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N309
On edge  : N309 -{call void @free(i8* %7, i8* @free)}-> N311
Message  : the memory is already freed
> Start from entry function: main, At N364 of Function main
> Entering function: double_free_002_good, On N367 -> N320 (call double_free_002_good)
> takes the true branch, At N328 of Function double_free_002_good
> Leaving function: double_free_002_good, On N319 -> N368 (Return edge from double_free_002_good to main)
> Entering function: double_free_002_bad, On N368 -> N276 (call double_free_002_bad)
> takes the false branch, At N284 of Function double_free_002_bad
> takes the true branch, At N291 of Function double_free_002_bad
> takes the true branch, At N299 of Function double_free_002_bad
> takes the false branch, At N291 of Function double_free_002_bad
<Defect> : N309 -> N311: [call void @free(i8* %7, i8* @free)]
N309 -> N311: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 6
	[./415_double_free_2.c 48] double_free_002_good 		[N340 -{store i8 97, i8* %arrayidx, align 1}-> N341]	(the memory is already freed)
	[./415_double_free_2.c 50] double_free_002_good 		[N345 -{call void @free(i8* %5, i8* @free)}-> N348]	(the memory is already freed)
	[./415_double_free_2.c 52] double_free_002_good 		[N353 -{call void @free(i8* %7, i8* @free)}-> N355]	(the memory is already freed)
	[./415_double_free_2.c 26] double_free_002_bad 		[N296 -{store i8 97, i8* %arrayidx, align 1}-> N297]	(the memory is already freed)
	[./415_double_free_2.c 29] double_free_002_bad 		[N301 -{call void @free(i8* %5, i8* @free)}-> N304]	(the memory is already freed)
	[./415_double_free_2.c 32] double_free_002_bad 		[N309 -{call void @free(i8* %7, i8* @free)}-> N311]	(the memory is already freed)

CWE_415(Double Free): 4
	[./415_double_free_2.c 50] double_free_002_good 		[N345 -{call void @free(i8* %5, i8* @free)}-> N348]	(the memory is already freed)
	[./415_double_free_2.c 52] double_free_002_good 		[N353 -{call void @free(i8* %7, i8* @free)}-> N355]	(the memory is already freed)
	[./415_double_free_2.c 29] double_free_002_bad 		[N301 -{call void @free(i8* %5, i8* @free)}-> N304]	(the memory is already freed)
	[./415_double_free_2.c 32] double_free_002_bad 		[N309 -{call void @free(i8* %7, i8* @free)}-> N311]	(the memory is already freed)

Found 10 defects in all (108 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :4
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_2$1(AP_ITC_415_Test.java:58)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_2(AP_ITC_415_Test.java:57)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_003_bad]
 +double_free_003_bad
SCC(1): [double_free_003_good]
 +double_free_003_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_003_bad, double_free_003_good, main]
Loops     [N429, N385]
----
function: double_free_003_bad
P+ = [] 
P- = [H(double_free_003_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_003_good
P+ = [] 
P- = [H(double_free_003_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_003_bad::call), H(double_free_003_good::call)] 
Point-To:

Ret-Value: R
----
loop N385 in double_free_003_bad: 
N385 -> P+ = [H(double_free_003_bad::call)], P- = [H(double_free_003_bad::call)] Point-To: L(double_free_003_bad::ptr) -> [H(double_free_003_bad::call)]
N387 -> P+ = [H(double_free_003_bad::call)], P- = [H(double_free_003_bad::call)] Point-To: L(double_free_003_bad::ptr) -> [H(double_free_003_bad::call)]
----
loop N429 in double_free_003_good: 
N429 -> P+ = [H(double_free_003_good::call)], P- = [] Point-To: L(double_free_003_good::ptr) -> [H(double_free_003_good::call)]
N431 -> P+ = [H(double_free_003_good::call)], P- = [] Point-To: L(double_free_003_good::ptr) -> [H(double_free_003_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N452): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N392
On edge  : N392 -{store i8 97, i8* %add.ptr, align 1}-> N393
Message  : the memory is already freed
> Start from entry function: main, At N452 of Function main
> Entering function: double_free_003_good, On N455 -> N416 (call double_free_003_good)
> takes the true branch, At N424 of Function double_free_003_good
> Leaving function: double_free_003_good, On N415 -> N456 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N456 -> N372 (call double_free_003_bad)
> takes the false branch, At N380 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
<Defect> : N392 -> N393: [store i8 97, i8* %add.ptr, align 1]
N392 -> N393: [store i8 97, i8* %add.ptr, align 1] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N397
On edge  : N397 -{call void @free(i8* %5, i8* @free)}-> N400
Message  : the memory is already freed
> Start from entry function: main, At N452 of Function main
> Entering function: double_free_003_good, On N455 -> N416 (call double_free_003_good)
> takes the true branch, At N424 of Function double_free_003_good
> Leaving function: double_free_003_good, On N415 -> N456 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N456 -> N372 (call double_free_003_bad)
> takes the false branch, At N380 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
<Defect> : N397 -> N400: [call void @free(i8* %5, i8* @free)]
N397 -> N400: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N405
On edge  : N405 -{call void @free(i8* %7, i8* @free)}-> N407
Message  : the memory is already freed
> Start from entry function: main, At N452 of Function main
> Entering function: double_free_003_good, On N455 -> N416 (call double_free_003_good)
> takes the true branch, At N424 of Function double_free_003_good
> Leaving function: double_free_003_good, On N415 -> N456 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N456 -> N372 (call double_free_003_bad)
> takes the false branch, At N380 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
> takes the false branch, At N387 of Function double_free_003_bad
<Defect> : N405 -> N407: [call void @free(i8* %7, i8* @free)]
N405 -> N407: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N397
On edge  : N397 -{call void @free(i8* %5, i8* @free)}-> N400
Message  : the memory is already freed
> Start from entry function: main, At N452 of Function main
> Entering function: double_free_003_good, On N455 -> N416 (call double_free_003_good)
> takes the true branch, At N424 of Function double_free_003_good
> Leaving function: double_free_003_good, On N415 -> N456 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N456 -> N372 (call double_free_003_bad)
> takes the false branch, At N380 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
<Defect> : N397 -> N400: [call void @free(i8* %5, i8* @free)]
N397 -> N400: [call void @free(i8* %5, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N405
On edge  : N405 -{call void @free(i8* %7, i8* @free)}-> N407
Message  : the memory is already freed
> Start from entry function: main, At N452 of Function main
> Entering function: double_free_003_good, On N455 -> N416 (call double_free_003_good)
> takes the true branch, At N424 of Function double_free_003_good
> Leaving function: double_free_003_good, On N415 -> N456 (Return edge from double_free_003_good to main)
> Entering function: double_free_003_bad, On N456 -> N372 (call double_free_003_bad)
> takes the false branch, At N380 of Function double_free_003_bad
> takes the true branch, At N387 of Function double_free_003_bad
> takes the true branch, At N395 of Function double_free_003_bad
> takes the false branch, At N387 of Function double_free_003_bad
<Defect> : N405 -> N407: [call void @free(i8* %7, i8* @free)]
N405 -> N407: [call void @free(i8* %7, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 3
	[./415_double_free_3.c 26] double_free_003_bad 		[N392 -{store i8 97, i8* %add.ptr, align 1}-> N393]	(the memory is already freed)
	[./415_double_free_3.c 29] double_free_003_bad 		[N397 -{call void @free(i8* %5, i8* @free)}-> N400]	(the memory is already freed)
	[./415_double_free_3.c 32] double_free_003_bad 		[N405 -{call void @free(i8* %7, i8* @free)}-> N407]	(the memory is already freed)

CWE_415(Double Free): 2
	[./415_double_free_3.c 29] double_free_003_bad 		[N397 -{call void @free(i8* %5, i8* @free)}-> N400]	(the memory is already freed)
	[./415_double_free_3.c 32] double_free_003_bad 		[N405 -{call void @free(i8* %7, i8* @free)}-> N407]	(the memory is already freed)

Found 5 defects in all (54 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_3$2(AP_ITC_415_Test.java:70)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_3(AP_ITC_415_Test.java:69)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_004_bad]
 +double_free_004_bad
SCC(1): [double_free_004_good]
 +double_free_004_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_004_good, main, double_free_004_bad]
Loops     [N473, N524]
----
function: double_free_004_bad
P+ = [] 
P- = [H(double_free_004_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_004_good
P+ = [] 
P- = [H(double_free_004_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_004_bad::call), H(double_free_004_good::call)] 
Point-To:

Ret-Value: R
----
loop N473 in double_free_004_bad: 
N473 -> P+ = [H(double_free_004_bad::call)], P- = [] Point-To: L(double_free_004_bad::ptr) -> [H(double_free_004_bad::call)]
N475 -> P+ = [H(double_free_004_bad::call)], P- = [] Point-To: L(double_free_004_bad::ptr) -> [H(double_free_004_bad::call)]
----
loop N524 in double_free_004_good: 
N524 -> P+ = [H(double_free_004_good::call)], P- = [] Point-To: L(double_free_004_good::ptr) -> [H(double_free_004_good::call)]
N526 -> P+ = [H(double_free_004_good::call)], P- = [] Point-To: L(double_free_004_good::ptr) -> [H(double_free_004_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.011s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N547): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N498
On edge  : N498 -{call void @free(i8* %6, i8* @free)}-> N500
Message  : the memory is already freed
> Start from entry function: main, At N547 of Function main
> Entering function: double_free_004_good, On N550 -> N511 (call double_free_004_good)
> takes the true branch, At N519 of Function double_free_004_good
> Leaving function: double_free_004_good, On N510 -> N551 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N551 -> N460 (call double_free_004_bad)
> takes the false branch, At N468 of Function double_free_004_bad
> takes the false branch, At N475 of Function double_free_004_bad
> takes the true branch, At N489 of Function double_free_004_bad
> takes the true branch, At N496 of Function double_free_004_bad
<Defect> : N498 -> N500: [call void @free(i8* %6, i8* @free)]
N498 -> N500: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N498
On edge  : N498 -{call void @free(i8* %6, i8* @free)}-> N500
Message  : the memory is already freed
> Start from entry function: main, At N547 of Function main
> Entering function: double_free_004_good, On N550 -> N511 (call double_free_004_good)
> takes the true branch, At N519 of Function double_free_004_good
> Leaving function: double_free_004_good, On N510 -> N551 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N551 -> N460 (call double_free_004_bad)
> takes the false branch, At N468 of Function double_free_004_bad
> takes the false branch, At N475 of Function double_free_004_bad
> takes the true branch, At N489 of Function double_free_004_bad
> takes the true branch, At N496 of Function double_free_004_bad
<Defect> : N498 -> N500: [call void @free(i8* %6, i8* @free)]
N498 -> N500: [call void @free(i8* %6, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N459
On edge  : N459 -{Return edge from double_free_004_bad to main}-> N552
Message  : the heap object @H(double_free_004_bad::call) is not referenced any more
> Start from entry function: main, At N547 of Function main
> Entering function: double_free_004_good, On N550 -> N511 (call double_free_004_good)
> takes the true branch, At N519 of Function double_free_004_good
> Leaving function: double_free_004_good, On N510 -> N551 (Return edge from double_free_004_good to main)
> Entering function: double_free_004_bad, On N551 -> N460 (call double_free_004_bad)
> takes the false branch, At N468 of Function double_free_004_bad
> takes the false branch, At N475 of Function double_free_004_bad
> takes the false branch, At N489 of Function double_free_004_bad
> takes the false branch, At N496 of Function double_free_004_bad
<Defect> : N459 -> N552: [Return edge from double_free_004_bad to main]
N459 -> N552: [Return edge from double_free_004_bad to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_4.c 37] double_free_004_bad 		[N498 -{call void @free(i8* %6, i8* @free)}-> N500]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_4.c 37] double_free_004_bad 		[N498 -{call void @free(i8* %6, i8* @free)}-> N500]	(the memory is already freed)

CWE_401(Memory Leak): 1
	[./415_double_free_4.c 66] double_free_004_bad 		[N459 -{Return edge from double_free_004_bad to main}-> N552]	(the heap object @H(double_free_004_bad::call) is not referenced any more)

Found 3 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_005_bad]
 +double_free_005_bad
SCC(1): [double_free_005_good]
 +double_free_005_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_005_bad, double_free_005_good, main]
Loops     []
----
function: double_free_005_bad
P+ = [] 
P- = [H(double_free_005_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_005_good
P+ = [] 
P- = [H(double_free_005_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_005_bad::call), H(double_free_005_good::call)] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N601): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N570
On edge  : N570 -{call void @free(i8* %3, i8* @free)}-> N572
Message  : the memory is already freed
> Start from entry function: main, At N601 of Function main
> Entering function: double_free_005_good, On N604 -> N579 (call double_free_005_good)
> takes the true branch, At N586 of Function double_free_005_good
> Leaving function: double_free_005_good, On N578 -> N605 (Return edge from double_free_005_good to main)
> Entering function: double_free_005_bad, On N605 -> N555 (call double_free_005_bad)
> takes the false branch, At N562 of Function double_free_005_bad
> takes the true branch, At N568 of Function double_free_005_bad
<Defect> : N570 -> N572: [call void @free(i8* %3, i8* @free)]
N570 -> N572: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N570
On edge  : N570 -{call void @free(i8* %3, i8* @free)}-> N572
Message  : the memory is already freed
> Start from entry function: main, At N601 of Function main
> Entering function: double_free_005_good, On N604 -> N579 (call double_free_005_good)
> takes the true branch, At N586 of Function double_free_005_good
> Leaving function: double_free_005_good, On N578 -> N605 (Return edge from double_free_005_good to main)
> Entering function: double_free_005_bad, On N605 -> N555 (call double_free_005_bad)
> takes the false branch, At N562 of Function double_free_005_bad
> takes the true branch, At N568 of Function double_free_005_bad
<Defect> : N570 -> N572: [call void @free(i8* %3, i8* @free)]
N570 -> N572: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_5.c 25] double_free_005_bad 		[N570 -{call void @free(i8* %3, i8* @free)}-> N572]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_5.c 25] double_free_005_bad 		[N570 -{call void @free(i8* %3, i8* @free)}-> N572]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_006_bad]
 +double_free_006_bad
SCC(1): [double_free_006_good]
 +double_free_006_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_006_bad, double_free_006_good, main]
Loops     []
----
function: double_free_006_bad
P+ = [] 
P- = [H(double_free_006_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_006_good
P+ = [] 
P- = [H(double_free_006_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_006_bad::call), H(double_free_006_good::call)] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N645): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N621
On edge  : N621 -{call void @free(i8* %2, i8* @free)}-> N623
Message  : the memory is already freed
> Start from entry function: main, At N645 of Function main
> Entering function: double_free_006_good, On N648 -> N628 (call double_free_006_good)
> takes the true branch, At N635 of Function double_free_006_good
> Leaving function: double_free_006_good, On N627 -> N649 (Return edge from double_free_006_good to main)
> Entering function: double_free_006_bad, On N649 -> N609 (call double_free_006_bad)
> takes the false branch, At N616 of Function double_free_006_bad
<Defect> : N621 -> N623: [call void @free(i8* %2, i8* @free)]
N621 -> N623: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N621
On edge  : N621 -{call void @free(i8* %2, i8* @free)}-> N623
Message  : the memory is already freed
> Start from entry function: main, At N645 of Function main
> Entering function: double_free_006_good, On N648 -> N628 (call double_free_006_good)
> takes the true branch, At N635 of Function double_free_006_good
> Leaving function: double_free_006_good, On N627 -> N649 (Return edge from double_free_006_good to main)
> Entering function: double_free_006_bad, On N649 -> N609 (call double_free_006_bad)
> takes the false branch, At N616 of Function double_free_006_bad
<Defect> : N621 -> N623: [call void @free(i8* %2, i8* @free)]
N621 -> N623: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_6.c 25] double_free_006_bad 		[N621 -{call void @free(i8* %2, i8* @free)}-> N623]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_6.c 25] double_free_006_bad 		[N621 -{call void @free(i8* %2, i8* @free)}-> N623]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_007_bad]
 +double_free_007_bad
SCC(1): [double_free_007_good]
 +double_free_007_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_007_good, main, double_free_007_bad]
Loops     []
----
function: double_free_007_bad
P+ = [] 
P- = [H(double_free_007_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_007_good
P+ = [] 
P- = [H(double_free_007_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_007_bad::call), H(double_free_007_good::call)] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N709): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N700
On edge  : N700 -{call void @free(i8* %3, i8* @free)}-> N702
Message  : the memory is already freed
> Start from entry function: main, At N709 of Function main
> Entering function: double_free_007_good, On N712 -> N681 (call double_free_007_good)
> takes the false branch, At N689 of Function double_free_007_good
> takes the true branch, At N695 of Function double_free_007_good
<Defect> : N700 -> N702: [call void @free(i8* %3, i8* @free)]
N700 -> N702: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N672
On edge  : N672 -{call void @free(i8* %3, i8* @free)}-> N674
Message  : the memory is already freed
> Start from entry function: main, At N709 of Function main
> Entering function: double_free_007_good, On N712 -> N681 (call double_free_007_good)
> takes the true branch, At N689 of Function double_free_007_good
> Leaving function: double_free_007_good, On N680 -> N713 (Return edge from double_free_007_good to main)
> Entering function: double_free_007_bad, On N713 -> N653 (call double_free_007_bad)
> takes the false branch, At N661 of Function double_free_007_bad
> takes the true branch, At N667 of Function double_free_007_bad
<Defect> : N672 -> N674: [call void @free(i8* %3, i8* @free)]
N672 -> N674: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N700
On edge  : N700 -{call void @free(i8* %3, i8* @free)}-> N702
Message  : the memory is already freed
> Start from entry function: main, At N709 of Function main
> Entering function: double_free_007_good, On N712 -> N681 (call double_free_007_good)
> takes the false branch, At N689 of Function double_free_007_good
> takes the true branch, At N695 of Function double_free_007_good
<Defect> : N700 -> N702: [call void @free(i8* %3, i8* @free)]
N700 -> N702: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N672
On edge  : N672 -{call void @free(i8* %3, i8* @free)}-> N674
Message  : the memory is already freed
> Start from entry function: main, At N709 of Function main
> Entering function: double_free_007_good, On N712 -> N681 (call double_free_007_good)
> takes the true branch, At N689 of Function double_free_007_good
> Leaving function: double_free_007_good, On N680 -> N713 (Return edge from double_free_007_good to main)
> Entering function: double_free_007_bad, On N713 -> N653 (call double_free_007_bad)
> takes the false branch, At N661 of Function double_free_007_bad
> takes the true branch, At N667 of Function double_free_007_bad
<Defect> : N672 -> N674: [call void @free(i8* %3, i8* @free)]
N672 -> N674: [call void @free(i8* %3, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 2
	[./415_double_free_7.c 44] double_free_007_good 		[N700 -{call void @free(i8* %3, i8* @free)}-> N702]	(the memory is already freed)
	[./415_double_free_7.c 27] double_free_007_bad 		[N672 -{call void @free(i8* %3, i8* @free)}-> N674]	(the memory is already freed)

CWE_415(Double Free): 2
	[./415_double_free_7.c 44] double_free_007_good 		[N700 -{call void @free(i8* %3, i8* @free)}-> N702]	(the memory is already freed)
	[./415_double_free_7.c 27] double_free_007_bad 		[N672 -{call void @free(i8* %3, i8* @free)}-> N674]	(the memory is already freed)

Found 4 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_7$6(AP_ITC_415_Test.java:118)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_7(AP_ITC_415_Test.java:117)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [double_free_function_008_bad]
 +double_free_function_008_bad
SCC(1): [double_free_008_bad]
 +double_free_008_bad
SCC(1): [double_free_function_008_good]
 +double_free_function_008_good
SCC(1): [double_free_008_good]
 +double_free_008_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_function_008_bad, double_free_function_008_good, main, double_free_008_bad, double_free_008_good]
Loops     []
----
function: double_free_008_bad
P+ = [H(double_free_008_bad::call)] 
P- = [G(double_free_function_008_gbl_ptr_bad)(*), H(double_free_008_bad::call)] 
Point-To:
G(double_free_function_008_gbl_ptr_bad) -> [H(double_free_008_bad::call)]
Ret-Value: 
----
function: double_free_008_good
P+ = [H(double_free_008_good::call)] 
P- = [G(double_free_function_008_gbl_ptr_good)(*)] 
Point-To:
G(double_free_function_008_gbl_ptr_good) -> [H(double_free_008_good::call)]
Ret-Value: 
----
function: double_free_function_008_bad
P+ = [] 
P- = [G(double_free_function_008_gbl_ptr_bad)(*)] 
Point-To:

Ret-Value: 
----
function: double_free_function_008_good
P+ = [] 
P- = [G(double_free_function_008_gbl_ptr_good)(*)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [H(double_free_008_bad::call), H(double_free_008_good::call)] 
P- = [G(double_free_function_008_gbl_ptr_bad)(*), G(double_free_function_008_gbl_ptr_good)(*), H(double_free_008_bad::call)] 
Point-To:
G(double_free_function_008_gbl_ptr_bad) -> [H(double_free_008_bad::call)]
G(double_free_function_008_gbl_ptr_good) -> [H(double_free_008_good::call)]
Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N759): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N726
On edge  : N726 -{call void @free(i8* %1, i8* @free)}-> N728
Message  : the memory is already freed
> Start from entry function: main, At N759 of Function main
> Entering function: double_free_008_good, On N762 -> N733 (call double_free_008_good)
> takes the true branch, At N738 of Function double_free_008_good
> Leaving function: double_free_008_good, On N732 -> N763 (Return edge from double_free_008_good to main)
> Entering function: double_free_008_bad, On N763 -> N717 (call double_free_008_bad)
> takes the false branch, At N722 of Function double_free_008_bad
> Entering function: double_free_function_008_bad, On N731 -> N747 (call double_free_function_008_bad)
> Leaving function: double_free_function_008_bad, On N746 -> N725 (Return edge from double_free_function_008_bad to double_free_008_bad)
<Defect> : N726 -> N728: [call void @free(i8* %1, i8* @free)]
N726 -> N728: [call void @free(i8* %1, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N726
On edge  : N726 -{call void @free(i8* %1, i8* @free)}-> N728
Message  : the memory is already freed
> Start from entry function: main, At N759 of Function main
> Entering function: double_free_008_good, On N762 -> N733 (call double_free_008_good)
> takes the true branch, At N738 of Function double_free_008_good
> Leaving function: double_free_008_good, On N732 -> N763 (Return edge from double_free_008_good to main)
> Entering function: double_free_008_bad, On N763 -> N717 (call double_free_008_bad)
> takes the false branch, At N722 of Function double_free_008_bad
> Entering function: double_free_function_008_bad, On N731 -> N747 (call double_free_function_008_bad)
> Leaving function: double_free_function_008_bad, On N746 -> N725 (Return edge from double_free_function_008_bad to double_free_008_bad)
<Defect> : N726 -> N728: [call void @free(i8* %1, i8* @free)]
N726 -> N728: [call void @free(i8* %1, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./415_double_free_8.c 28] double_free_008_bad 		[N726 -{call void @free(i8* %1, i8* @free)}-> N728]	(the memory is already freed)

CWE_415(Double Free): 1
	[./415_double_free_8.c 28] double_free_008_bad 		[N726 -{call void @free(i8* %1, i8* @free)}-> N728]	(the memory is already freed)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/415/415_double_free_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [double_free_009_bad]
 +double_free_009_bad
SCC(1): [double_free_009_good]
 +double_free_009_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [double_free_009_bad, double_free_009_good, main]
Loops     [N782, N814]
----
function: double_free_009_bad
P+ = [] 
P- = [H(double_free_009_bad::call)] 
Point-To:

Ret-Value: 
----
function: double_free_009_good
P+ = [] 
P- = [H(double_free_009_good::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(double_free_009_bad::call), H(double_free_009_good::call)] 
Point-To:

Ret-Value: R
----
loop N782 in double_free_009_bad: 
N782 -> P+ = [H(double_free_009_bad::call)], P- = [H(double_free_009_bad::call)] Point-To: L(double_free_009_bad::ptr) -> [H(double_free_009_bad::call)]
N784 -> P+ = [H(double_free_009_bad::call)], P- = [H(double_free_009_bad::call)] Point-To: L(double_free_009_bad::ptr) -> [H(double_free_009_bad::call)]
----
loop N814 in double_free_009_good: 
N814 -> P+ = [H(double_free_009_good::call)], P- = [H(double_free_009_good::call)] Point-To: L(double_free_009_good::ptr) -> [H(double_free_009_good::call)]
N816 -> P+ = [H(double_free_009_good::call)], P- = [H(double_free_009_good::call)] Point-To: L(double_free_009_good::ptr) -> [H(double_free_009_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.02s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N833): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N818
On edge  : N818 -{call void @free(i8* %2, i8* @free)}-> N819
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the false branch, At N809 of Function double_free_009_good
> takes the true branch, At N816 of Function double_free_009_good
> takes the true branch, At N816 of Function double_free_009_good
<Defect> : N818 -> N819: [call void @free(i8* %2, i8* @free)]
N818 -> N819: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N824
On edge  : N824 -{call void @free(i8* %4, i8* @free)}-> N826
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the false branch, At N809 of Function double_free_009_good
> takes the true branch, At N816 of Function double_free_009_good
> takes the false branch, At N816 of Function double_free_009_good
<Defect> : N824 -> N826: [call void @free(i8* %4, i8* @free)]
N824 -> N826: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N786
On edge  : N786 -{call void @free(i8* %2, i8* @free)}-> N787
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the true branch, At N809 of Function double_free_009_good
> Leaving function: double_free_009_good, On N800 -> N837 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N837 -> N769 (call double_free_009_bad)
> takes the false branch, At N777 of Function double_free_009_bad
> takes the true branch, At N784 of Function double_free_009_bad
> takes the true branch, At N784 of Function double_free_009_bad
<Defect> : N786 -> N787: [call void @free(i8* %2, i8* @free)]
N786 -> N787: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N792
On edge  : N792 -{call void @free(i8* %4, i8* @free)}-> N794
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the true branch, At N809 of Function double_free_009_good
> Leaving function: double_free_009_good, On N800 -> N837 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N837 -> N769 (call double_free_009_bad)
> takes the false branch, At N777 of Function double_free_009_bad
> takes the true branch, At N784 of Function double_free_009_bad
> takes the false branch, At N784 of Function double_free_009_bad
<Defect> : N792 -> N794: [call void @free(i8* %4, i8* @free)]
N792 -> N794: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N818
On edge  : N818 -{call void @free(i8* %2, i8* @free)}-> N819
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the false branch, At N809 of Function double_free_009_good
> takes the true branch, At N816 of Function double_free_009_good
> takes the true branch, At N816 of Function double_free_009_good
<Defect> : N818 -> N819: [call void @free(i8* %2, i8* @free)]
N818 -> N819: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N824
On edge  : N824 -{call void @free(i8* %4, i8* @free)}-> N826
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the false branch, At N809 of Function double_free_009_good
> takes the true branch, At N816 of Function double_free_009_good
> takes the false branch, At N816 of Function double_free_009_good
<Defect> : N824 -> N826: [call void @free(i8* %4, i8* @free)]
N824 -> N826: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N786
On edge  : N786 -{call void @free(i8* %2, i8* @free)}-> N787
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the true branch, At N809 of Function double_free_009_good
> Leaving function: double_free_009_good, On N800 -> N837 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N837 -> N769 (call double_free_009_bad)
> takes the false branch, At N777 of Function double_free_009_bad
> takes the true branch, At N784 of Function double_free_009_bad
> takes the true branch, At N784 of Function double_free_009_bad
<Defect> : N786 -> N787: [call void @free(i8* %2, i8* @free)]
N786 -> N787: [call void @free(i8* %2, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N792
On edge  : N792 -{call void @free(i8* %4, i8* @free)}-> N794
Message  : the memory is already freed
> Start from entry function: main, At N833 of Function main
> Entering function: double_free_009_good, On N836 -> N801 (call double_free_009_good)
> takes the true branch, At N809 of Function double_free_009_good
> Leaving function: double_free_009_good, On N800 -> N837 (Return edge from double_free_009_good to main)
> Entering function: double_free_009_bad, On N837 -> N769 (call double_free_009_bad)
> takes the false branch, At N777 of Function double_free_009_bad
> takes the true branch, At N784 of Function double_free_009_bad
> takes the false branch, At N784 of Function double_free_009_bad
<Defect> : N792 -> N794: [call void @free(i8* %4, i8* @free)]
N792 -> N794: [call void @free(i8* %4, i8* @free)] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 4
	[./415_double_free_9.c 45] double_free_009_good 		[N818 -{call void @free(i8* %2, i8* @free)}-> N819]	(the memory is already freed)
	[./415_double_free_9.c 48] double_free_009_good 		[N824 -{call void @free(i8* %4, i8* @free)}-> N826]	(the memory is already freed)
	[./415_double_free_9.c 26] double_free_009_bad 		[N786 -{call void @free(i8* %2, i8* @free)}-> N787]	(the memory is already freed)
	[./415_double_free_9.c 29] double_free_009_bad 		[N792 -{call void @free(i8* %4, i8* @free)}-> N794]	(the memory is already freed)

CWE_415(Double Free): 4
	[./415_double_free_9.c 45] double_free_009_good 		[N818 -{call void @free(i8* %2, i8* @free)}-> N819]	(the memory is already freed)
	[./415_double_free_9.c 48] double_free_009_good 		[N824 -{call void @free(i8* %4, i8* @free)}-> N826]	(the memory is already freed)
	[./415_double_free_9.c 26] double_free_009_bad 		[N786 -{call void @free(i8* %2, i8* @free)}-> N787]	(the memory is already freed)
	[./415_double_free_9.c 29] double_free_009_bad 		[N792 -{call void @free(i8* %4, i8* @free)}-> N794]	(the memory is already freed)

Found 8 defects in all (72 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :4
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.lambda$itc_415_9$8(AP_ITC_415_Test.java:142)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.AP_ITC_415_Test.itc_415_9(AP_ITC_415_Test.java:141)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)


Process finished with exit code 255
