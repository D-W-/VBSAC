/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=36201:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.Juliet_416_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad1]
 +bad1
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad1, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good1, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad1
P+ = [] 
P- = [H(bad1::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good1
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad1::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.245s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N63): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N19
On edge  : N19 -{call printLine}-> N88
Message  : the memory is already freed
> Start from entry function: main, At N63 of Function main
> Entering function: good1, On N111 -> N40 (call good1)
> takes the true branch, At N48 of Function good1
> Leaving function: good1, On N39 -> N65 (Return edge from good1 to main)
> Entering function: bad1, On N65 -> N1 (call bad1)
> takes the false branch, At N9 of Function bad1
<Defect> : N19 -> N88: [call printLine]
N19 -> N88: [call printLine] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N39
On edge  : N39 -{Return edge from good1 to main}-> N65
Message  : the heap object @H(good1::call) is not referenced any more
> Start from entry function: main, At N63 of Function main
> Entering function: good1, On N111 -> N40 (call good1)
> takes the false branch, At N48 of Function good1
> Entering function: printLine, On N56 -> N88 (call printLine)
> takes the true branch, At N94 of Function printLine
> Leaving function: printLine, On N87 -> N58 (Return edge from printLine to good1)
<Defect> : N39 -> N65: [Return edge from good1 to main]
N39 -> N65: [Return edge from good1 to main] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_1.c 68] bad1 		[N19 -{call printLine}-> N88]	(the memory is already freed)

CWE_401(Memory Leak): 1
	[./416_1.c 98] good1 		[N39 -{Return edge from good1 to main}-> N65]	(the heap object @H(good1::call) is not referenced any more)

Found 2 defects in all (5 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad2]
 +bad2
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad2, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good2, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad2
P+ = [] 
P- = [H(bad2::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good2
P+ = [] 
P- = [H(good2::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad2::call), H(good2::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.033s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N183): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N139
On edge  : N139 -{call printLine}-> N208
Message  : the memory is already freed
> Start from entry function: main, At N183 of Function main
> Entering function: good2, On N231 -> N160 (call good2)
> takes the true branch, At N168 of Function good2
> Leaving function: good2, On N159 -> N185 (Return edge from good2 to main)
> Entering function: bad2, On N185 -> N121 (call bad2)
> takes the false branch, At N129 of Function bad2
<Defect> : N139 -> N208: [call printLine]
N139 -> N208: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_2.c 69] bad2 		[N139 -{call printLine}-> N208]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad3]
 +bad3
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad3, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good3, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad3
P+ = [] 
P- = [H(bad3::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good3
P+ = [] 
P- = [H(good3::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad3::call), H(good3::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.035s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N303): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N259
On edge  : N259 -{call printLine}-> N328
Message  : the memory is already freed
> Start from entry function: main, At N303 of Function main
> Entering function: good3, On N351 -> N280 (call good3)
> takes the true branch, At N288 of Function good3
> Leaving function: good3, On N279 -> N305 (Return edge from good3 to main)
> Entering function: bad3, On N305 -> N241 (call bad3)
> takes the false branch, At N249 of Function bad3
<Defect> : N259 -> N328: [call printLine]
N259 -> N328: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_3.c 69] bad3 		[N259 -{call printLine}-> N328]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad4]
 +bad4
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad4, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good4, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad4
P+ = [] 
P- = [H(bad4::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good4
P+ = [] 
P- = [H(good4::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad4::call), H(good4::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.024s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N423): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N379
On edge  : N379 -{call printLine}-> N448
Message  : the memory is already freed
> Start from entry function: main, At N423 of Function main
> Entering function: good4, On N471 -> N400 (call good4)
> takes the true branch, At N408 of Function good4
> Leaving function: good4, On N399 -> N425 (Return edge from good4 to main)
> Entering function: bad4, On N425 -> N361 (call bad4)
> takes the false branch, At N369 of Function bad4
<Defect> : N379 -> N448: [call printLine]
N379 -> N448: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_4.c 72] bad4 		[N379 -{call printLine}-> N448]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad5]
 +bad5
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad5, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good5, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad5
P+ = [] 
P- = [H(bad5::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good5
P+ = [] 
P- = [H(good5::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad5::call), H(good5::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N567): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N506
On edge  : N506 -{call printLine}-> N592
Message  : the memory is already freed
> Start from entry function: main, At N567 of Function main
> Entering function: good5, On N615 -> N531 (call good5)
> takes the true branch, At N537 of Function good5
> takes the true branch, At N542 of Function good5
> Leaving function: good5, On N530 -> N569 (Return edge from good5 to main)
> Entering function: bad5, On N569 -> N481 (call bad5)
> takes the true branch, At N487 of Function bad5
> takes the false branch, At N492 of Function bad5
> takes the true branch, At N504 of Function bad5
<Defect> : N506 -> N592: [call printLine]
N506 -> N592: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_5.c 72] bad5 		[N506 -{call printLine}-> N592]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [bad6]
 +bad6
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad6, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good6, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad6
P+ = [] 
P- = [H(bad6::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good6
P+ = [] 
P- = [H(good6::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad6::call), H(good6::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N690): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N646
On edge  : N646 -{call printLine}-> N715
Message  : the memory is already freed
> Start from entry function: main, At N690 of Function main
> Entering function: good6, On N738 -> N667 (call good6)
> takes the true branch, At N675 of Function good6
> Leaving function: good6, On N666 -> N692 (Return edge from good6 to main)
> Entering function: bad6, On N692 -> N628 (call bad6)
> takes the false branch, At N636 of Function bad6
<Defect> : N646 -> N715: [call printLine]
N646 -> N715: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_6.c 71] bad6 		[N646 -{call printLine}-> N715]	(the memory is already freed)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad7]
 +bad7
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad7, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good7, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N817, N762]
----
function: bad7
P+ = [] 
P- = [H(bad7::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good7
P+ = [] 
P- = [H(good7::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad7::call), H(good7::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N762 in bad7: 
N762 -> P+ = [H(bad7::call)], P- = [] Point-To: L(bad7::data) -> [H(bad7::call)]
N764 -> P+ = [H(bad7::call)], P- = [] Point-To: L(bad7::data) -> [H(bad7::call)]
----
loop N817 in good7: 
N817 -> P+ = [H(good7::call)], P- = [] Point-To: L(good7::data) -> [H(good7::call)]
N819 -> P+ = [H(good7::call)], P- = [] Point-To: L(good7::data) -> [H(good7::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.023s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N844): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N779
On edge  : N779 -{%9 = load i32, i32* %arrayidx2, align 4}-> N780
Message  : the memory is already freed
> Start from entry function: main, At N844 of Function main
> Entering function: good7, On N892 -> N803 (call good7)
> takes the false branch, At N813 of Function good7
> Leaving function: good7, On N802 -> N846 (Return edge from good7 to main)
> Entering function: bad7, On N846 -> N748 (call bad7)
> takes the true branch, At N758 of Function bad7
> takes the false branch, At N764 of Function bad7
<Defect> : N779 -> N780: [%9 = load i32, i32* %arrayidx2, align 4]
N779 -> N780: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N779
On edge  : N779 -{%9 = load i32, i32* %arrayidx2, align 4}-> N780
Message  : use of uninitialized variable
> Start from entry function: main, At N844 of Function main
> Entering function: good7, On N892 -> N803 (call good7)
> takes the false branch, At N813 of Function good7
> Leaving function: good7, On N802 -> N846 (Return edge from good7 to main)
> Entering function: bad7, On N846 -> N748 (call bad7)
> takes the true branch, At N758 of Function bad7
> takes the false branch, At N764 of Function bad7
<Defect> : N779 -> N780: [%9 = load i32, i32* %arrayidx2, align 4]
N779 -> N780: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_7.c 68] bad7 		[N779 -{%9 = load i32, i32* %arrayidx2, align 4}-> N780]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_7.c 68] bad7 		[N779 -{%9 = load i32, i32* %arrayidx2, align 4}-> N780]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad8]
 +bad8
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad8, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good8]
Loops     [N917, N973]
----
function: bad8
P+ = [] 
P- = [H(bad8::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good8
P+ = [] 
P- = [H(good8::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad8::call), H(good8::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N917 in bad8: 
N917 -> P+ = [H(bad8::call)], P- = [] Point-To: L(bad8::data) -> [H(bad8::call)]
N919 -> P+ = [H(bad8::call)], P- = [] Point-To: L(bad8::data) -> [H(bad8::call)]
----
loop N973 in good8: 
N973 -> P+ = [H(good8::call)], P- = [] Point-To: L(good8::data) -> [H(good8::call)]
N975 -> P+ = [H(good8::call)], P- = [] Point-To: L(good8::data) -> [H(good8::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.019s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N996): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N934
On edge  : N934 -{%9 = load i32, i32* %arrayidx2, align 4}-> N935
Message  : the memory is already freed
> Start from entry function: main, At N996 of Function main
> Entering function: good8, On N1044 -> N958 (call good8)
> takes the true branch, At N968 of Function good8
> Leaving function: good8, On N957 -> N998 (Return edge from good8 to main)
> Entering function: bad8, On N998 -> N902 (call bad8)
> takes the false branch, At N912 of Function bad8
> takes the false branch, At N919 of Function bad8
<Defect> : N934 -> N935: [%9 = load i32, i32* %arrayidx2, align 4]
N934 -> N935: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N934
On edge  : N934 -{%9 = load i32, i32* %arrayidx2, align 4}-> N935
Message  : use of uninitialized variable
> Start from entry function: main, At N996 of Function main
> Entering function: good8, On N1044 -> N958 (call good8)
> takes the true branch, At N968 of Function good8
> Leaving function: good8, On N957 -> N998 (Return edge from good8 to main)
> Entering function: bad8, On N998 -> N902 (call bad8)
> takes the false branch, At N912 of Function bad8
> takes the false branch, At N919 of Function bad8
<Defect> : N934 -> N935: [%9 = load i32, i32* %arrayidx2, align 4]
N934 -> N935: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_8.c 74] bad8 		[N934 -{%9 = load i32, i32* %arrayidx2, align 4}-> N935]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_8.c 74] bad8 		[N934 -{%9 = load i32, i32* %arrayidx2, align 4}-> N935]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad9]
 +bad9
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad9, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good9, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N1069, N1125]
----
function: bad9
P+ = [] 
P- = [H(bad9::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good9
P+ = [] 
P- = [H(good9::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad9::call), H(good9::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N1069 in bad9: 
N1069 -> P+ = [H(bad9::call)], P- = [] Point-To: L(bad9::data) -> [H(bad9::call)]
N1071 -> P+ = [H(bad9::call)], P- = [] Point-To: L(bad9::data) -> [H(bad9::call)]
----
loop N1125 in good9: 
N1125 -> P+ = [H(good9::call)], P- = [] Point-To: L(good9::data) -> [H(good9::call)]
N1127 -> P+ = [H(good9::call)], P- = [] Point-To: L(good9::data) -> [H(good9::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.037s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1148): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N1086
On edge  : N1086 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1087
Message  : the memory is already freed
> Start from entry function: main, At N1148 of Function main
> Entering function: good9, On N1196 -> N1110 (call good9)
> takes the true branch, At N1120 of Function good9
> Leaving function: good9, On N1109 -> N1150 (Return edge from good9 to main)
> Entering function: bad9, On N1150 -> N1054 (call bad9)
> takes the false branch, At N1064 of Function bad9
> takes the false branch, At N1071 of Function bad9
<Defect> : N1086 -> N1087: [%9 = load i32, i32* %arrayidx2, align 4]
N1086 -> N1087: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1086
On edge  : N1086 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1087
Message  : use of uninitialized variable
> Start from entry function: main, At N1148 of Function main
> Entering function: good9, On N1196 -> N1110 (call good9)
> takes the true branch, At N1120 of Function good9
> Leaving function: good9, On N1109 -> N1150 (Return edge from good9 to main)
> Entering function: bad9, On N1150 -> N1054 (call bad9)
> takes the false branch, At N1064 of Function bad9
> takes the false branch, At N1071 of Function bad9
<Defect> : N1086 -> N1087: [%9 = load i32, i32* %arrayidx2, align 4]
N1086 -> N1087: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_9.c 74] bad9 		[N1086 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1087]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_9.c 74] bad9 		[N1086 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1087]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsTrue, globalReturnsTrueOrFalse, good10, main, printHexCharLine, printIntLine, printLine, printLongLine, bad10, globalReturnsFalse]
Loops     [N1277, N1221]
----
function: bad10
P+ = [] 
P- = [H(bad10::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good10
P+ = [] 
P- = [H(good10::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad10::call), H(good10::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N1221 in bad10: 
N1221 -> P+ = [H(bad10::call)], P- = [] Point-To: L(bad10::data) -> [H(bad10::call)]
N1223 -> P+ = [H(bad10::call)], P- = [] Point-To: L(bad10::data) -> [H(bad10::call)]
----
loop N1277 in good10: 
N1277 -> P+ = [H(good10::call)], P- = [] Point-To: L(good10::data) -> [H(good10::call)]
N1279 -> P+ = [H(good10::call)], P- = [] Point-To: L(good10::data) -> [H(good10::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1300): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N1238
On edge  : N1238 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1239
Message  : the memory is already freed
> Start from entry function: main, At N1300 of Function main
> Entering function: good10, On N1348 -> N1262 (call good10)
> takes the true branch, At N1272 of Function good10
> Leaving function: good10, On N1261 -> N1302 (Return edge from good10 to main)
> Entering function: bad10, On N1302 -> N1206 (call bad10)
> takes the false branch, At N1216 of Function bad10
> takes the false branch, At N1223 of Function bad10
<Defect> : N1238 -> N1239: [%9 = load i32, i32* %arrayidx2, align 4]
N1238 -> N1239: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1238
On edge  : N1238 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1239
Message  : use of uninitialized variable
> Start from entry function: main, At N1300 of Function main
> Entering function: good10, On N1348 -> N1262 (call good10)
> takes the true branch, At N1272 of Function good10
> Leaving function: good10, On N1261 -> N1302 (Return edge from good10 to main)
> Entering function: bad10, On N1302 -> N1206 (call bad10)
> takes the false branch, At N1216 of Function bad10
> takes the false branch, At N1223 of Function bad10
<Defect> : N1238 -> N1239: [%9 = load i32, i32* %arrayidx2, align 4]
N1238 -> N1239: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_10.c 77] bad10 		[N1238 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1239]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_10.c 77] bad10 		[N1238 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1239]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad11, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good11, main, printHexCharLine, printIntLine, printLine]
Loops     [N1376, N1443]
----
function: bad11
P+ = [] 
P- = [H(bad11::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good11
P+ = [] 
P- = [H(good11::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad11::call), H(good11::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N1376 in bad11: 
N1376 -> P+ = [H(bad11::call)], P- = [] Point-To: L(bad11::data) -> [H(bad11::call)]
N1378 -> P+ = [H(bad11::call)], P- = [] Point-To: L(bad11::data) -> [H(bad11::call)]
----
loop N1443 in good11: 
N1443 -> P+ = [H(good11::call)], P- = [] Point-To: L(good11::data) -> [H(good11::call)]
N1445 -> P+ = [H(good11::call)], P- = [] Point-To: L(good11::data) -> [H(good11::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1476): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N1397
On edge  : N1397 -{%11 = load i32, i32* %arrayidx6, align 4}-> N1398
Message  : the memory is already freed
> Start from entry function: main, At N1476 of Function main
> Entering function: good11, On N1524 -> N1425 (call good11)
> takes the true branch, At N1432 of Function good11
> takes the true branch, At N1438 of Function good11
> Leaving function: good11, On N1424 -> N1478 (Return edge from good11 to main)
> Entering function: bad11, On N1478 -> N1358 (call bad11)
> takes the true branch, At N1365 of Function bad11
> takes the false branch, At N1371 of Function bad11
> takes the false branch, At N1378 of Function bad11
> takes the true branch, At N1394 of Function bad11
<Defect> : N1397 -> N1398: [%11 = load i32, i32* %arrayidx6, align 4]
N1397 -> N1398: [%11 = load i32, i32* %arrayidx6, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1397
On edge  : N1397 -{%11 = load i32, i32* %arrayidx6, align 4}-> N1398
Message  : use of uninitialized variable
> Start from entry function: main, At N1476 of Function main
> Entering function: good11, On N1524 -> N1425 (call good11)
> takes the true branch, At N1432 of Function good11
> takes the true branch, At N1438 of Function good11
> Leaving function: good11, On N1424 -> N1478 (Return edge from good11 to main)
> Entering function: bad11, On N1478 -> N1358 (call bad11)
> takes the true branch, At N1365 of Function bad11
> takes the false branch, At N1371 of Function bad11
> takes the false branch, At N1378 of Function bad11
> takes the true branch, At N1394 of Function bad11
<Defect> : N1397 -> N1398: [%11 = load i32, i32* %arrayidx6, align 4]
N1397 -> N1398: [%11 = load i32, i32* %arrayidx6, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_11.c 77] bad11 		[N1397 -{%11 = load i32, i32* %arrayidx6, align 4}-> N1398]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_11.c 77] bad11 		[N1397 -{%11 = load i32, i32* %arrayidx6, align 4}-> N1398]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad12, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good12, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N1608, N1552]
----
function: bad12
P+ = [] 
P- = [H(bad12::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good12
P+ = [] 
P- = [H(good12::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad12::call), H(good12::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N1552 in bad12: 
N1552 -> P+ = [H(bad12::call)], P- = [] Point-To: L(bad12::data) -> [H(bad12::call)]
N1554 -> P+ = [H(bad12::call)], P- = [] Point-To: L(bad12::data) -> [H(bad12::call)]
----
loop N1608 in good12: 
N1608 -> P+ = [H(good12::call)], P- = [] Point-To: L(good12::data) -> [H(good12::call)]
N1610 -> P+ = [H(good12::call)], P- = [] Point-To: L(good12::data) -> [H(good12::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.011s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1631): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N1569
On edge  : N1569 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1570
Message  : the memory is already freed
> Start from entry function: main, At N1631 of Function main
> Entering function: good12, On N1679 -> N1593 (call good12)
> takes the true branch, At N1603 of Function good12
> Leaving function: good12, On N1592 -> N1633 (Return edge from good12 to main)
> Entering function: bad12, On N1633 -> N1537 (call bad12)
> takes the false branch, At N1547 of Function bad12
> takes the false branch, At N1554 of Function bad12
<Defect> : N1569 -> N1570: [%9 = load i32, i32* %arrayidx2, align 4]
N1569 -> N1570: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1569
On edge  : N1569 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1570
Message  : use of uninitialized variable
> Start from entry function: main, At N1631 of Function main
> Entering function: good12, On N1679 -> N1593 (call good12)
> takes the true branch, At N1603 of Function good12
> Leaving function: good12, On N1592 -> N1633 (Return edge from good12 to main)
> Entering function: bad12, On N1633 -> N1537 (call bad12)
> takes the false branch, At N1547 of Function bad12
> takes the false branch, At N1554 of Function bad12
<Defect> : N1569 -> N1570: [%9 = load i32, i32* %arrayidx2, align 4]
N1569 -> N1570: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_12.c 76] bad12 		[N1569 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1570]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_12.c 76] bad12 		[N1569 -{%9 = load i32, i32* %arrayidx2, align 4}-> N1570]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad13, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good13]
Loops     [N1760, N1704]
----
function: bad13
P+ = [] 
P- = [H(bad13::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good13
P+ = [] 
P- = [H(good13::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad13::call), H(good13::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N1704 in bad13: 
N1704 -> P+ = [H(bad13::call)], P- = [] Point-To: L(bad13::data) -> [H(bad13::call)]
N1706 -> P+ = [H(bad13::call)], P- = [] Point-To: L(bad13::data) -> [H(bad13::call)]
----
loop N1760 in good13: 
N1760 -> P+ = [H(good13::call)], P- = [] Point-To: L(good13::data) -> [H(good13::call)]
N1762 -> P+ = [H(good13::call)], P- = [] Point-To: L(good13::data) -> [H(good13::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1787): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N1721
On edge  : N1721 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1722
Message  : the memory is already freed
> Start from entry function: main, At N1787 of Function main
> Entering function: good13, On N1835 -> N1745 (call good13)
> takes the true branch, At N1755 of Function good13
> Leaving function: good13, On N1744 -> N1789 (Return edge from good13 to main)
> Entering function: bad13, On N1789 -> N1689 (call bad13)
> takes the false branch, At N1699 of Function bad13
> takes the false branch, At N1706 of Function bad13
<Defect> : N1721 -> N1722: [%9 = load i64, i64* %arrayidx2, align 8]
N1721 -> N1722: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1721
On edge  : N1721 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1722
Message  : use of uninitialized variable
> Start from entry function: main, At N1787 of Function main
> Entering function: good13, On N1835 -> N1745 (call good13)
> takes the true branch, At N1755 of Function good13
> Leaving function: good13, On N1744 -> N1789 (Return edge from good13 to main)
> Entering function: bad13, On N1789 -> N1689 (call bad13)
> takes the false branch, At N1699 of Function bad13
> takes the false branch, At N1706 of Function bad13
<Defect> : N1721 -> N1722: [%9 = load i64, i64* %arrayidx2, align 8]
N1721 -> N1722: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_13.c 69] bad13 		[N1721 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1722]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_13.c 69] bad13 		[N1721 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1722]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [bad14, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good14, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N1860, N1916]
----
function: bad14
P+ = [] 
P- = [H(bad14::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good14
P+ = [] 
P- = [H(good14::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad14::call), H(good14::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N1860 in bad14: 
N1860 -> P+ = [H(bad14::call)], P- = [] Point-To: L(bad14::data) -> [H(bad14::call)]
N1862 -> P+ = [H(bad14::call)], P- = [] Point-To: L(bad14::data) -> [H(bad14::call)]
----
loop N1916 in good14: 
N1916 -> P+ = [H(good14::call)], P- = [] Point-To: L(good14::data) -> [H(good14::call)]
N1918 -> P+ = [H(good14::call)], P- = [] Point-To: L(good14::data) -> [H(good14::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.019s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1939): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N1877
On edge  : N1877 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1878
Message  : the memory is already freed
> Start from entry function: main, At N1939 of Function main
> Entering function: good14, On N1987 -> N1901 (call good14)
> takes the true branch, At N1911 of Function good14
> Leaving function: good14, On N1900 -> N1941 (Return edge from good14 to main)
> Entering function: bad14, On N1941 -> N1845 (call bad14)
> takes the false branch, At N1855 of Function bad14
> takes the false branch, At N1862 of Function bad14
<Defect> : N1877 -> N1878: [%9 = load i64, i64* %arrayidx2, align 8]
N1877 -> N1878: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N1877
On edge  : N1877 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1878
Message  : use of uninitialized variable
> Start from entry function: main, At N1939 of Function main
> Entering function: good14, On N1987 -> N1901 (call good14)
> takes the true branch, At N1911 of Function good14
> Leaving function: good14, On N1900 -> N1941 (Return edge from good14 to main)
> Entering function: bad14, On N1941 -> N1845 (call bad14)
> takes the false branch, At N1855 of Function bad14
> takes the false branch, At N1862 of Function bad14
<Defect> : N1877 -> N1878: [%9 = load i64, i64* %arrayidx2, align 8]
N1877 -> N1878: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_14.c 74] bad14 		[N1877 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1878]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_14.c 74] bad14 		[N1877 -{%9 = load i64, i64* %arrayidx2, align 8}-> N1878]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good15, main, printHexCharLine, printIntLine, printLine, printLongLine, bad15]
Loops     [N2068, N2012]
----
function: bad15
P+ = [] 
P- = [H(bad15::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good15
P+ = [] 
P- = [H(good15::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad15::call), H(good15::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N2012 in bad15: 
N2012 -> P+ = [H(bad15::call)], P- = [] Point-To: L(bad15::data) -> [H(bad15::call)]
N2014 -> P+ = [H(bad15::call)], P- = [] Point-To: L(bad15::data) -> [H(bad15::call)]
----
loop N2068 in good15: 
N2068 -> P+ = [H(good15::call)], P- = [] Point-To: L(good15::data) -> [H(good15::call)]
N2070 -> P+ = [H(good15::call)], P- = [] Point-To: L(good15::data) -> [H(good15::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2091): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N2029
On edge  : N2029 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2030
Message  : the memory is already freed
> Start from entry function: main, At N2091 of Function main
> Entering function: good15, On N2139 -> N2053 (call good15)
> takes the true branch, At N2063 of Function good15
> Leaving function: good15, On N2052 -> N2093 (Return edge from good15 to main)
> Entering function: bad15, On N2093 -> N1997 (call bad15)
> takes the false branch, At N2007 of Function bad15
> takes the false branch, At N2014 of Function bad15
<Defect> : N2029 -> N2030: [%9 = load i64, i64* %arrayidx2, align 8]
N2029 -> N2030: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2029
On edge  : N2029 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2030
Message  : use of uninitialized variable
> Start from entry function: main, At N2091 of Function main
> Entering function: good15, On N2139 -> N2053 (call good15)
> takes the true branch, At N2063 of Function good15
> Leaving function: good15, On N2052 -> N2093 (Return edge from good15 to main)
> Entering function: bad15, On N2093 -> N1997 (call bad15)
> takes the false branch, At N2007 of Function bad15
> takes the false branch, At N2014 of Function bad15
<Defect> : N2029 -> N2030: [%9 = load i64, i64* %arrayidx2, align 8]
N2029 -> N2030: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_15.c 74] bad15 		[N2029 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2030]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_15.c 74] bad15 		[N2029 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2030]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_16.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad16, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good16, main, printHexCharLine, printIntLine, printLine]
Loops     [N2164, N2220]
----
function: bad16
P+ = [] 
P- = [H(bad16::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good16
P+ = [] 
P- = [H(good16::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad16::call), H(good16::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N2164 in bad16: 
N2164 -> P+ = [H(bad16::call)], P- = [] Point-To: L(bad16::data) -> [H(bad16::call)]
N2166 -> P+ = [H(bad16::call)], P- = [] Point-To: L(bad16::data) -> [H(bad16::call)]
----
loop N2220 in good16: 
N2220 -> P+ = [H(good16::call)], P- = [] Point-To: L(good16::data) -> [H(good16::call)]
N2222 -> P+ = [H(good16::call)], P- = [] Point-To: L(good16::data) -> [H(good16::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.011s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2243): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N2181
On edge  : N2181 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2182
Message  : the memory is already freed
> Start from entry function: main, At N2243 of Function main
> Entering function: good16, On N2291 -> N2205 (call good16)
> takes the true branch, At N2215 of Function good16
> Leaving function: good16, On N2204 -> N2245 (Return edge from good16 to main)
> Entering function: bad16, On N2245 -> N2149 (call bad16)
> takes the false branch, At N2159 of Function bad16
> takes the false branch, At N2166 of Function bad16
<Defect> : N2181 -> N2182: [%9 = load i64, i64* %arrayidx2, align 8]
N2181 -> N2182: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2181
On edge  : N2181 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2182
Message  : use of uninitialized variable
> Start from entry function: main, At N2243 of Function main
> Entering function: good16, On N2291 -> N2205 (call good16)
> takes the true branch, At N2215 of Function good16
> Leaving function: good16, On N2204 -> N2245 (Return edge from good16 to main)
> Entering function: bad16, On N2245 -> N2149 (call bad16)
> takes the false branch, At N2159 of Function bad16
> takes the false branch, At N2166 of Function bad16
<Defect> : N2181 -> N2182: [%9 = load i64, i64* %arrayidx2, align 8]
N2181 -> N2182: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_16.c 77] bad16 		[N2181 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2182]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_16.c 77] bad16 		[N2181 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2182]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_17.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [bad17, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good17, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N2386, N2319]
----
function: bad17
P+ = [] 
P- = [H(bad17::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good17
P+ = [] 
P- = [H(good17::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad17::call), H(good17::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N2319 in bad17: 
N2319 -> P+ = [H(bad17::call)], P- = [] Point-To: L(bad17::data) -> [H(bad17::call)]
N2321 -> P+ = [H(bad17::call)], P- = [] Point-To: L(bad17::data) -> [H(bad17::call)]
----
loop N2386 in good17: 
N2386 -> P+ = [H(good17::call)], P- = [] Point-To: L(good17::data) -> [H(good17::call)]
N2388 -> P+ = [H(good17::call)], P- = [] Point-To: L(good17::data) -> [H(good17::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2419): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N2340
On edge  : N2340 -{%11 = load i64, i64* %arrayidx6, align 8}-> N2341
Message  : the memory is already freed
> Start from entry function: main, At N2419 of Function main
> Entering function: good17, On N2467 -> N2368 (call good17)
> takes the true branch, At N2375 of Function good17
> takes the true branch, At N2381 of Function good17
> Leaving function: good17, On N2367 -> N2421 (Return edge from good17 to main)
> Entering function: bad17, On N2421 -> N2301 (call bad17)
> takes the true branch, At N2308 of Function bad17
> takes the false branch, At N2314 of Function bad17
> takes the false branch, At N2321 of Function bad17
> takes the true branch, At N2337 of Function bad17
<Defect> : N2340 -> N2341: [%11 = load i64, i64* %arrayidx6, align 8]
N2340 -> N2341: [%11 = load i64, i64* %arrayidx6, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2340
On edge  : N2340 -{%11 = load i64, i64* %arrayidx6, align 8}-> N2341
Message  : use of uninitialized variable
> Start from entry function: main, At N2419 of Function main
> Entering function: good17, On N2467 -> N2368 (call good17)
> takes the true branch, At N2375 of Function good17
> takes the true branch, At N2381 of Function good17
> Leaving function: good17, On N2367 -> N2421 (Return edge from good17 to main)
> Entering function: bad17, On N2421 -> N2301 (call bad17)
> takes the true branch, At N2308 of Function bad17
> takes the false branch, At N2314 of Function bad17
> takes the false branch, At N2321 of Function bad17
> takes the true branch, At N2337 of Function bad17
<Defect> : N2340 -> N2341: [%11 = load i64, i64* %arrayidx6, align 8]
N2340 -> N2341: [%11 = load i64, i64* %arrayidx6, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_17.c 77] bad17 		[N2340 -{%11 = load i64, i64* %arrayidx6, align 8}-> N2341]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_17.c 77] bad17 		[N2340 -{%11 = load i64, i64* %arrayidx6, align 8}-> N2341]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_18.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsTrueOrFalse, good18, main, printHexCharLine, printIntLine, printLine, printLongLine, bad18, globalReturnsFalse, globalReturnsTrue]
Loops     [N2551, N2495]
----
function: bad18
P+ = [] 
P- = [H(bad18::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good18
P+ = [] 
P- = [H(good18::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad18::call), H(good18::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N2495 in bad18: 
N2495 -> P+ = [H(bad18::call)], P- = [] Point-To: L(bad18::data) -> [H(bad18::call)]
N2497 -> P+ = [H(bad18::call)], P- = [] Point-To: L(bad18::data) -> [H(bad18::call)]
----
loop N2551 in good18: 
N2551 -> P+ = [H(good18::call)], P- = [] Point-To: L(good18::data) -> [H(good18::call)]
N2553 -> P+ = [H(good18::call)], P- = [] Point-To: L(good18::data) -> [H(good18::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2574): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N2512
On edge  : N2512 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2513
Message  : the memory is already freed
> Start from entry function: main, At N2574 of Function main
> Entering function: good18, On N2622 -> N2536 (call good18)
> takes the true branch, At N2546 of Function good18
> Leaving function: good18, On N2535 -> N2576 (Return edge from good18 to main)
> Entering function: bad18, On N2576 -> N2480 (call bad18)
> takes the false branch, At N2490 of Function bad18
> takes the false branch, At N2497 of Function bad18
<Defect> : N2512 -> N2513: [%9 = load i64, i64* %arrayidx2, align 8]
N2512 -> N2513: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2512
On edge  : N2512 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2513
Message  : use of uninitialized variable
> Start from entry function: main, At N2574 of Function main
> Entering function: good18, On N2622 -> N2536 (call good18)
> takes the true branch, At N2546 of Function good18
> Leaving function: good18, On N2535 -> N2576 (Return edge from good18 to main)
> Entering function: bad18, On N2576 -> N2480 (call bad18)
> takes the false branch, At N2490 of Function bad18
> takes the false branch, At N2497 of Function bad18
<Defect> : N2512 -> N2513: [%9 = load i64, i64* %arrayidx2, align 8]
N2512 -> N2513: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_18.c 76] bad18 		[N2512 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2513]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_18.c 76] bad18 		[N2512 -{%9 = load i64, i64* %arrayidx2, align 8}-> N2513]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_19.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad19, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good19, main, printHexCharLine, printIntLine, printLine]
Loops     [N2650, N2717]
----
function: bad19
P+ = [] 
P- = [H(bad19::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good19
P+ = [] 
P- = [H(good19::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad19::call), H(good19::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N2650 in bad19: 
N2650 -> P+ = [H(bad19::call)], P- = [] Point-To: L(bad19::data) -> [H(bad19::call)]
N2652 -> P+ = [H(bad19::call)], P- = [] Point-To: L(bad19::data) -> [H(bad19::call)]
----
loop N2717 in good19: 
N2717 -> P+ = [H(good19::call)], P- = [] Point-To: L(good19::data) -> [H(good19::call)]
N2719 -> P+ = [H(good19::call)], P- = [] Point-To: L(good19::data) -> [H(good19::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2750): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N2671
On edge  : N2671 -{%11 = load i64, i64* %arrayidx7, align 8}-> N2672
Message  : the memory is already freed
> Start from entry function: main, At N2750 of Function main
> Entering function: good19, On N2798 -> N2699 (call good19)
> takes the true branch, At N2706 of Function good19
> takes the true branch, At N2712 of Function good19
> Leaving function: good19, On N2698 -> N2752 (Return edge from good19 to main)
> Entering function: bad19, On N2752 -> N2632 (call bad19)
> takes the true branch, At N2639 of Function bad19
> takes the false branch, At N2645 of Function bad19
> takes the false branch, At N2652 of Function bad19
> takes the true branch, At N2668 of Function bad19
<Defect> : N2671 -> N2672: [%11 = load i64, i64* %arrayidx7, align 8]
N2671 -> N2672: [%11 = load i64, i64* %arrayidx7, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2671
On edge  : N2671 -{%11 = load i64, i64* %arrayidx7, align 8}-> N2672
Message  : use of uninitialized variable
> Start from entry function: main, At N2750 of Function main
> Entering function: good19, On N2798 -> N2699 (call good19)
> takes the true branch, At N2706 of Function good19
> takes the true branch, At N2712 of Function good19
> Leaving function: good19, On N2698 -> N2752 (Return edge from good19 to main)
> Entering function: bad19, On N2752 -> N2632 (call bad19)
> takes the true branch, At N2639 of Function bad19
> takes the false branch, At N2645 of Function bad19
> takes the false branch, At N2652 of Function bad19
> takes the true branch, At N2668 of Function bad19
<Defect> : N2671 -> N2672: [%11 = load i64, i64* %arrayidx7, align 8]
N2671 -> N2672: [%11 = load i64, i64* %arrayidx7, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_19.c 76] bad19 		[N2671 -{%11 = load i64, i64* %arrayidx7, align 8}-> N2672]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_19.c 76] bad19 		[N2671 -{%11 = load i64, i64* %arrayidx7, align 8}-> N2672]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_20.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [bad20, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good20, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue]
Loops     [N2828, N2895]
----
function: bad20
P+ = [] 
P- = [H(bad20::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good20
P+ = [] 
P- = [H(good20::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad20::call1), H(good20::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
loop N2828 in bad20: 
N2828 -> P+ = [H(bad20::call1)], P- = [] Point-To: L(bad20::data) -> [H(bad20::call1)]
N2830 -> P+ = [H(bad20::call1)], P- = [] Point-To: L(bad20::data) -> [H(bad20::call1)]
----
loop N2895 in good20: 
N2895 -> P+ = [H(good20::call1)], P- = [] Point-To: L(good20::data) -> [H(good20::call1)]
N2897 -> P+ = [H(good20::call1)], P- = [] Point-To: L(good20::data) -> [H(good20::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.015s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2928): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N2849
On edge  : N2849 -{%9 = load i64, i64* %arrayidx8, align 8}-> N2850
Message  : the memory is already freed
> Start from entry function: main, At N2928 of Function main
> Entering function: good20, On N2984 -> N2877 (call good20)
> Entering function: staticReturnsTrue, On N2882 -> N2981 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2980 -> N2883 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N2884 of Function good20
> takes the true branch, At N2890 of Function good20
> Leaving function: good20, On N2876 -> N2930 (Return edge from good20 to main)
> Entering function: bad20, On N2930 -> N2810 (call bad20)
> Entering function: staticReturnsTrue, On N2815 -> N2981 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2980 -> N2816 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N2817 of Function bad20
> takes the false branch, At N2823 of Function bad20
> takes the false branch, At N2830 of Function bad20
> Entering function: staticReturnsTrue, On N2844 -> N2981 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2980 -> N2845 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N2846 of Function bad20
<Defect> : N2849 -> N2850: [%9 = load i64, i64* %arrayidx8, align 8]
N2849 -> N2850: [%9 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2849
On edge  : N2849 -{%9 = load i64, i64* %arrayidx8, align 8}-> N2850
Message  : use of uninitialized variable
> Start from entry function: main, At N2928 of Function main
> Entering function: good20, On N2984 -> N2877 (call good20)
> Entering function: staticReturnsTrue, On N2882 -> N2981 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2980 -> N2883 (Return edge from staticReturnsTrue to good20)
> takes the true branch, At N2884 of Function good20
> takes the true branch, At N2890 of Function good20
> Leaving function: good20, On N2876 -> N2930 (Return edge from good20 to main)
> Entering function: bad20, On N2930 -> N2810 (call bad20)
> Entering function: staticReturnsTrue, On N2815 -> N2981 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2980 -> N2816 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N2817 of Function bad20
> takes the false branch, At N2823 of Function bad20
> takes the false branch, At N2830 of Function bad20
> Entering function: staticReturnsTrue, On N2844 -> N2981 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N2980 -> N2845 (Return edge from staticReturnsTrue to bad20)
> takes the true branch, At N2846 of Function bad20
<Defect> : N2849 -> N2850: [%9 = load i64, i64* %arrayidx8, align 8]
N2849 -> N2850: [%9 = load i64, i64* %arrayidx8, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_20.c 84] bad20 		[N2849 -{%9 = load i64, i64* %arrayidx8, align 8}-> N2850]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_20.c 84] bad20 		[N2849 -{%9 = load i64, i64* %arrayidx8, align 8}-> N2850]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_21.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad21]
 +bad21
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsTrue, globalReturnsTrueOrFalse, good21, main, printHexCharLine, printIntLine, printLine, printLongLine, bad21, globalReturnsFalse]
Loops     [N3010, N3066]
----
function: bad21
P+ = [] 
P- = [H(bad21::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good21
P+ = [] 
P- = [H(good21::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad21::call), H(good21::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N3010 in bad21: 
N3010 -> P+ = [H(bad21::call)], P- = [] Point-To: L(bad21::data) -> [H(bad21::call)]
N3012 -> P+ = [H(bad21::call)], P- = [] Point-To: L(bad21::data) -> [H(bad21::call)]
----
loop N3066 in good21: 
N3066 -> P+ = [H(good21::call)], P- = [] Point-To: L(good21::data) -> [H(good21::call)]
N3068 -> P+ = [H(good21::call)], P- = [] Point-To: L(good21::data) -> [H(good21::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.021s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3089): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N3027
On edge  : N3027 -{%9 = load i64, i64* %arrayidx2, align 8}-> N3028
Message  : the memory is already freed
> Start from entry function: main, At N3089 of Function main
> Entering function: good21, On N3137 -> N3051 (call good21)
> takes the true branch, At N3061 of Function good21
> Leaving function: good21, On N3050 -> N3091 (Return edge from good21 to main)
> Entering function: bad21, On N3091 -> N2995 (call bad21)
> takes the false branch, At N3005 of Function bad21
> takes the false branch, At N3012 of Function bad21
<Defect> : N3027 -> N3028: [%9 = load i64, i64* %arrayidx2, align 8]
N3027 -> N3028: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3027
On edge  : N3027 -{%9 = load i64, i64* %arrayidx2, align 8}-> N3028
Message  : use of uninitialized variable
> Start from entry function: main, At N3089 of Function main
> Entering function: good21, On N3137 -> N3051 (call good21)
> takes the true branch, At N3061 of Function good21
> Leaving function: good21, On N3050 -> N3091 (Return edge from good21 to main)
> Entering function: bad21, On N3091 -> N2995 (call bad21)
> takes the false branch, At N3005 of Function bad21
> takes the false branch, At N3012 of Function bad21
<Defect> : N3027 -> N3028: [%9 = load i64, i64* %arrayidx2, align 8]
N3027 -> N3028: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_21.c 74] bad21 		[N3027 -{%9 = load i64, i64* %arrayidx2, align 8}-> N3028]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_21.c 74] bad21 		[N3027 -{%9 = load i64, i64* %arrayidx2, align 8}-> N3028]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_22.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad22]
 +bad22
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printStructLine, bad22, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good22, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N3162, N3223]
----
function: bad22
P+ = [] 
P- = [H(bad22::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good22
P+ = [] 
P- = [H(good22::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad22::call), H(good22::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N3162 in bad22: 
N3162 -> P+ = [H(bad22::call)], P- = [] Point-To: L(bad22::data) -> [H(bad22::call)]
N3164 -> P+ = [H(bad22::call)], P- = [] Point-To: L(bad22::data) -> [H(bad22::call)]
----
loop N3223 in good22: 
N3223 -> P+ = [H(good22::call)], P- = [] Point-To: L(good22::data) -> [H(good22::call)]
N3225 -> P+ = [H(good22::call)], P- = [] Point-To: L(good22::data) -> [H(good22::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.019s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3255): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N3185
On edge  : N3185 -{call printStructLine}-> N3304
Message  : the memory is already freed
> Start from entry function: main, At N3255 of Function main
> Entering function: good22, On N3317 -> N3208 (call good22)
> takes the true branch, At N3218 of Function good22
> Leaving function: good22, On N3207 -> N3257 (Return edge from good22 to main)
> Entering function: bad22, On N3257 -> N3147 (call bad22)
> takes the false branch, At N3157 of Function bad22
> takes the false branch, At N3164 of Function bad22
<Defect> : N3185 -> N3304: [call printStructLine]
N3185 -> N3304: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3310
On edge  : N3310 -{%1 = load i32, i32* %intOne, align 4}-> N3311
Message  : use of uninitialized variable
> Start from entry function: main, At N3255 of Function main
> Entering function: good22, On N3317 -> N3208 (call good22)
> takes the true branch, At N3218 of Function good22
> Leaving function: good22, On N3207 -> N3257 (Return edge from good22 to main)
> Entering function: bad22, On N3257 -> N3147 (call bad22)
> takes the false branch, At N3157 of Function bad22
> takes the false branch, At N3164 of Function bad22
> Entering function: printStructLine, On N3185 -> N3304 (call printStructLine)
<Defect> : N3310 -> N3311: [%1 = load i32, i32* %intOne, align 4]
N3310 -> N3311: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3313
On edge  : N3313 -{%3 = load i32, i32* %intTwo, align 4}-> N3314
Message  : use of uninitialized variable
> Start from entry function: main, At N3255 of Function main
> Entering function: good22, On N3317 -> N3208 (call good22)
> takes the true branch, At N3218 of Function good22
> Leaving function: good22, On N3207 -> N3257 (Return edge from good22 to main)
> Entering function: bad22, On N3257 -> N3147 (call bad22)
> takes the false branch, At N3157 of Function bad22
> takes the false branch, At N3164 of Function bad22
> Entering function: printStructLine, On N3185 -> N3304 (call printStructLine)
<Defect> : N3313 -> N3314: [%3 = load i32, i32* %intTwo, align 4]
N3313 -> N3314: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_22.c 74] bad22 		[N3185 -{call printStructLine}-> N3304]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_22.c 51] printStructLine 		[N3310 -{%1 = load i32, i32* %intOne, align 4}-> N3311]	(use of uninitialized variable)
	[./416_22.c 51] printStructLine 		[N3313 -{%3 = load i32, i32* %intTwo, align 4}-> N3314]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_23.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad23]
 +bad23
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad23, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good23, main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine]
Loops     [N3343, N3404]
----
function: bad23
P+ = [] 
P- = [H(bad23::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good23
P+ = [] 
P- = [H(good23::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad23::call), H(good23::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N3343 in bad23: 
N3343 -> P+ = [H(bad23::call)], P- = [] Point-To: L(bad23::data) -> [H(bad23::call)]
N3345 -> P+ = [H(bad23::call)], P- = [] Point-To: L(bad23::data) -> [H(bad23::call)]
----
loop N3404 in good23: 
N3404 -> P+ = [H(good23::call)], P- = [] Point-To: L(good23::data) -> [H(good23::call)]
N3406 -> P+ = [H(good23::call)], P- = [] Point-To: L(good23::data) -> [H(good23::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.013s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3433): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N3366
On edge  : N3366 -{call printStructLine}-> N3482
Message  : the memory is already freed
> Start from entry function: main, At N3433 of Function main
> Entering function: good23, On N3495 -> N3389 (call good23)
> takes the true branch, At N3399 of Function good23
> Leaving function: good23, On N3388 -> N3435 (Return edge from good23 to main)
> Entering function: bad23, On N3435 -> N3328 (call bad23)
> takes the false branch, At N3338 of Function bad23
> takes the false branch, At N3345 of Function bad23
<Defect> : N3366 -> N3482: [call printStructLine]
N3366 -> N3482: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3488
On edge  : N3488 -{%1 = load i32, i32* %intOne, align 4}-> N3489
Message  : use of uninitialized variable
> Start from entry function: main, At N3433 of Function main
> Entering function: good23, On N3495 -> N3389 (call good23)
> takes the true branch, At N3399 of Function good23
> Leaving function: good23, On N3388 -> N3435 (Return edge from good23 to main)
> Entering function: bad23, On N3435 -> N3328 (call bad23)
> takes the false branch, At N3338 of Function bad23
> takes the false branch, At N3345 of Function bad23
> Entering function: printStructLine, On N3366 -> N3482 (call printStructLine)
<Defect> : N3488 -> N3489: [%1 = load i32, i32* %intOne, align 4]
N3488 -> N3489: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3491
On edge  : N3491 -{%3 = load i32, i32* %intTwo, align 4}-> N3492
Message  : use of uninitialized variable
> Start from entry function: main, At N3433 of Function main
> Entering function: good23, On N3495 -> N3389 (call good23)
> takes the true branch, At N3399 of Function good23
> Leaving function: good23, On N3388 -> N3435 (Return edge from good23 to main)
> Entering function: bad23, On N3435 -> N3328 (call bad23)
> takes the false branch, At N3338 of Function bad23
> takes the false branch, At N3345 of Function bad23
> Entering function: printStructLine, On N3366 -> N3482 (call printStructLine)
<Defect> : N3491 -> N3492: [%3 = load i32, i32* %intTwo, align 4]
N3491 -> N3492: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_23.c 79] bad23 		[N3366 -{call printStructLine}-> N3482]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_23.c 51] printStructLine 		[N3488 -{%1 = load i32, i32* %intOne, align 4}-> N3489]	(use of uninitialized variable)
	[./416_23.c 51] printStructLine 		[N3491 -{%3 = load i32, i32* %intTwo, align 4}-> N3492]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_24.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad24]
 +bad24
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good24, main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine, bad24]
Loops     [N3582, N3521]
----
function: bad24
P+ = [] 
P- = [H(bad24::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good24
P+ = [] 
P- = [H(good24::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad24::call), H(good24::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N3521 in bad24: 
N3521 -> P+ = [H(bad24::call)], P- = [] Point-To: L(bad24::data) -> [H(bad24::call)]
N3523 -> P+ = [H(bad24::call)], P- = [] Point-To: L(bad24::data) -> [H(bad24::call)]
----
loop N3582 in good24: 
N3582 -> P+ = [H(good24::call)], P- = [] Point-To: L(good24::data) -> [H(good24::call)]
N3584 -> P+ = [H(good24::call)], P- = [] Point-To: L(good24::data) -> [H(good24::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3611): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N3544
On edge  : N3544 -{call printStructLine}-> N3660
Message  : the memory is already freed
> Start from entry function: main, At N3611 of Function main
> Entering function: good24, On N3673 -> N3567 (call good24)
> takes the true branch, At N3577 of Function good24
> Leaving function: good24, On N3566 -> N3613 (Return edge from good24 to main)
> Entering function: bad24, On N3613 -> N3506 (call bad24)
> takes the false branch, At N3516 of Function bad24
> takes the false branch, At N3523 of Function bad24
<Defect> : N3544 -> N3660: [call printStructLine]
N3544 -> N3660: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3666
On edge  : N3666 -{%1 = load i32, i32* %intOne, align 4}-> N3667
Message  : use of uninitialized variable
> Start from entry function: main, At N3611 of Function main
> Entering function: good24, On N3673 -> N3567 (call good24)
> takes the true branch, At N3577 of Function good24
> Leaving function: good24, On N3566 -> N3613 (Return edge from good24 to main)
> Entering function: bad24, On N3613 -> N3506 (call bad24)
> takes the false branch, At N3516 of Function bad24
> takes the false branch, At N3523 of Function bad24
> Entering function: printStructLine, On N3544 -> N3660 (call printStructLine)
<Defect> : N3666 -> N3667: [%1 = load i32, i32* %intOne, align 4]
N3666 -> N3667: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3669
On edge  : N3669 -{%3 = load i32, i32* %intTwo, align 4}-> N3670
Message  : use of uninitialized variable
> Start from entry function: main, At N3611 of Function main
> Entering function: good24, On N3673 -> N3567 (call good24)
> takes the true branch, At N3577 of Function good24
> Leaving function: good24, On N3566 -> N3613 (Return edge from good24 to main)
> Entering function: bad24, On N3613 -> N3506 (call bad24)
> takes the false branch, At N3516 of Function bad24
> takes the false branch, At N3523 of Function bad24
> Entering function: printStructLine, On N3544 -> N3660 (call printStructLine)
<Defect> : N3669 -> N3670: [%3 = load i32, i32* %intTwo, align 4]
N3669 -> N3670: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_24.c 79] bad24 		[N3544 -{call printStructLine}-> N3660]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_24.c 51] printStructLine 		[N3666 -{%1 = load i32, i32* %intOne, align 4}-> N3667]	(use of uninitialized variable)
	[./416_24.c 51] printStructLine 		[N3669 -{%3 = load i32, i32* %intTwo, align 4}-> N3670]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_25.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad25]
 +bad25
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, printStructLine, bad25, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good25, main, printHexCharLine, printIntLine]
Loops     [N3699, N3760]
----
function: bad25
P+ = [] 
P- = [H(bad25::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good25
P+ = [] 
P- = [H(good25::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad25::call), H(good25::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N3699 in bad25: 
N3699 -> P+ = [H(bad25::call)], P- = [] Point-To: L(bad25::data) -> [H(bad25::call)]
N3701 -> P+ = [H(bad25::call)], P- = [] Point-To: L(bad25::data) -> [H(bad25::call)]
----
loop N3760 in good25: 
N3760 -> P+ = [H(good25::call)], P- = [] Point-To: L(good25::data) -> [H(good25::call)]
N3762 -> P+ = [H(good25::call)], P- = [] Point-To: L(good25::data) -> [H(good25::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3789): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N3722
On edge  : N3722 -{call printStructLine}-> N3838
Message  : the memory is already freed
> Start from entry function: main, At N3789 of Function main
> Entering function: good25, On N3851 -> N3745 (call good25)
> takes the true branch, At N3755 of Function good25
> Leaving function: good25, On N3744 -> N3791 (Return edge from good25 to main)
> Entering function: bad25, On N3791 -> N3684 (call bad25)
> takes the false branch, At N3694 of Function bad25
> takes the false branch, At N3701 of Function bad25
<Defect> : N3722 -> N3838: [call printStructLine]
N3722 -> N3838: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3844
On edge  : N3844 -{%1 = load i32, i32* %intOne, align 4}-> N3845
Message  : use of uninitialized variable
> Start from entry function: main, At N3789 of Function main
> Entering function: good25, On N3851 -> N3745 (call good25)
> takes the true branch, At N3755 of Function good25
> Leaving function: good25, On N3744 -> N3791 (Return edge from good25 to main)
> Entering function: bad25, On N3791 -> N3684 (call bad25)
> takes the false branch, At N3694 of Function bad25
> takes the false branch, At N3701 of Function bad25
> Entering function: printStructLine, On N3722 -> N3838 (call printStructLine)
<Defect> : N3844 -> N3845: [%1 = load i32, i32* %intOne, align 4]
N3844 -> N3845: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N3847
On edge  : N3847 -{%3 = load i32, i32* %intTwo, align 4}-> N3848
Message  : use of uninitialized variable
> Start from entry function: main, At N3789 of Function main
> Entering function: good25, On N3851 -> N3745 (call good25)
> takes the true branch, At N3755 of Function good25
> Leaving function: good25, On N3744 -> N3791 (Return edge from good25 to main)
> Entering function: bad25, On N3791 -> N3684 (call bad25)
> takes the false branch, At N3694 of Function bad25
> takes the false branch, At N3701 of Function bad25
> Entering function: printStructLine, On N3722 -> N3838 (call printStructLine)
<Defect> : N3847 -> N3848: [%3 = load i32, i32* %intTwo, align 4]
N3847 -> N3848: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_25.c 82] bad25 		[N3722 -{call printStructLine}-> N3838]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_25.c 51] printStructLine 		[N3844 -{%1 = load i32, i32* %intOne, align 4}-> N3845]	(use of uninitialized variable)
	[./416_25.c 51] printStructLine 		[N3847 -{%3 = load i32, i32* %intTwo, align 4}-> N3848]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_26.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad26]
 +bad26
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad26, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good26, main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine]
Loops     [N3880, N3952]
----
function: bad26
P+ = [] 
P- = [H(bad26::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good26
P+ = [] 
P- = [H(good26::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad26::call), H(good26::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N3880 in bad26: 
N3880 -> P+ = [H(bad26::call)], P- = [] Point-To: L(bad26::data) -> [H(bad26::call)]
N3882 -> P+ = [H(bad26::call)], P- = [] Point-To: L(bad26::data) -> [H(bad26::call)]
----
loop N3952 in good26: 
N3952 -> P+ = [H(good26::call)], P- = [] Point-To: L(good26::data) -> [H(good26::call)]
N3954 -> P+ = [H(good26::call)], P- = [] Point-To: L(good26::data) -> [H(good26::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3991): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N3907
On edge  : N3907 -{call printStructLine}-> N4040
Message  : the memory is already freed
> Start from entry function: main, At N3991 of Function main
> Entering function: good26, On N4053 -> N3934 (call good26)
> takes the true branch, At N3941 of Function good26
> takes the true branch, At N3947 of Function good26
> Leaving function: good26, On N3933 -> N3993 (Return edge from good26 to main)
> Entering function: bad26, On N3993 -> N3862 (call bad26)
> takes the true branch, At N3869 of Function bad26
> takes the false branch, At N3875 of Function bad26
> takes the false branch, At N3882 of Function bad26
> takes the true branch, At N3904 of Function bad26
<Defect> : N3907 -> N4040: [call printStructLine]
N3907 -> N4040: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4046
On edge  : N4046 -{%1 = load i32, i32* %intOne, align 4}-> N4047
Message  : use of uninitialized variable
> Start from entry function: main, At N3991 of Function main
> Entering function: good26, On N4053 -> N3934 (call good26)
> takes the true branch, At N3941 of Function good26
> takes the true branch, At N3947 of Function good26
> Leaving function: good26, On N3933 -> N3993 (Return edge from good26 to main)
> Entering function: bad26, On N3993 -> N3862 (call bad26)
> takes the true branch, At N3869 of Function bad26
> takes the false branch, At N3875 of Function bad26
> takes the false branch, At N3882 of Function bad26
> takes the true branch, At N3904 of Function bad26
> Entering function: printStructLine, On N3907 -> N4040 (call printStructLine)
<Defect> : N4046 -> N4047: [%1 = load i32, i32* %intOne, align 4]
N4046 -> N4047: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4049
On edge  : N4049 -{%3 = load i32, i32* %intTwo, align 4}-> N4050
Message  : use of uninitialized variable
> Start from entry function: main, At N3991 of Function main
> Entering function: good26, On N4053 -> N3934 (call good26)
> takes the true branch, At N3941 of Function good26
> takes the true branch, At N3947 of Function good26
> Leaving function: good26, On N3933 -> N3993 (Return edge from good26 to main)
> Entering function: bad26, On N3993 -> N3862 (call bad26)
> takes the true branch, At N3869 of Function bad26
> takes the false branch, At N3875 of Function bad26
> takes the false branch, At N3882 of Function bad26
> takes the true branch, At N3904 of Function bad26
> Entering function: printStructLine, On N3907 -> N4040 (call printStructLine)
<Defect> : N4049 -> N4050: [%3 = load i32, i32* %intTwo, align 4]
N4049 -> N4050: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_26.c 82] bad26 		[N3907 -{call printStructLine}-> N4040]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_26.c 51] printStructLine 		[N4046 -{%1 = load i32, i32* %intOne, align 4}-> N4047]	(use of uninitialized variable)
	[./416_26.c 51] printStructLine 		[N4049 -{%3 = load i32, i32* %intTwo, align 4}-> N4050]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_27.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad27]
 +bad27
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad27, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good27, main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine]
Loops     [N4082, N4143]
----
function: bad27
P+ = [] 
P- = [H(bad27::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good27
P+ = [] 
P- = [H(good27::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad27::call), H(good27::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N4082 in bad27: 
N4082 -> P+ = [H(bad27::call)], P- = [] Point-To: L(bad27::data) -> [H(bad27::call)]
N4084 -> P+ = [H(bad27::call)], P- = [] Point-To: L(bad27::data) -> [H(bad27::call)]
----
loop N4143 in good27: 
N4143 -> P+ = [H(good27::call)], P- = [] Point-To: L(good27::data) -> [H(good27::call)]
N4145 -> P+ = [H(good27::call)], P- = [] Point-To: L(good27::data) -> [H(good27::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4172): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N4105
On edge  : N4105 -{call printStructLine}-> N4221
Message  : the memory is already freed
> Start from entry function: main, At N4172 of Function main
> Entering function: good27, On N4234 -> N4128 (call good27)
> takes the true branch, At N4138 of Function good27
> Leaving function: good27, On N4127 -> N4174 (Return edge from good27 to main)
> Entering function: bad27, On N4174 -> N4067 (call bad27)
> takes the false branch, At N4077 of Function bad27
> takes the false branch, At N4084 of Function bad27
<Defect> : N4105 -> N4221: [call printStructLine]
N4105 -> N4221: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4227
On edge  : N4227 -{%1 = load i32, i32* %intOne, align 4}-> N4228
Message  : use of uninitialized variable
> Start from entry function: main, At N4172 of Function main
> Entering function: good27, On N4234 -> N4128 (call good27)
> takes the true branch, At N4138 of Function good27
> Leaving function: good27, On N4127 -> N4174 (Return edge from good27 to main)
> Entering function: bad27, On N4174 -> N4067 (call bad27)
> takes the false branch, At N4077 of Function bad27
> takes the false branch, At N4084 of Function bad27
> Entering function: printStructLine, On N4105 -> N4221 (call printStructLine)
<Defect> : N4227 -> N4228: [%1 = load i32, i32* %intOne, align 4]
N4227 -> N4228: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4230
On edge  : N4230 -{%3 = load i32, i32* %intTwo, align 4}-> N4231
Message  : use of uninitialized variable
> Start from entry function: main, At N4172 of Function main
> Entering function: good27, On N4234 -> N4128 (call good27)
> takes the true branch, At N4138 of Function good27
> Leaving function: good27, On N4127 -> N4174 (Return edge from good27 to main)
> Entering function: bad27, On N4174 -> N4067 (call bad27)
> takes the false branch, At N4077 of Function bad27
> takes the false branch, At N4084 of Function bad27
> Entering function: printStructLine, On N4105 -> N4221 (call printStructLine)
<Defect> : N4230 -> N4231: [%3 = load i32, i32* %intTwo, align 4]
N4230 -> N4231: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_27.c 81] bad27 		[N4105 -{call printStructLine}-> N4221]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_27.c 51] printStructLine 		[N4227 -{%1 = load i32, i32* %intOne, align 4}-> N4228]	(use of uninitialized variable)
	[./416_27.c 51] printStructLine 		[N4230 -{%3 = load i32, i32* %intTwo, align 4}-> N4231]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_28.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad28]
 +bad28
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine, bad28, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good28]
Loops     [N4335, N4263]
----
function: bad28
P+ = [] 
P- = [H(bad28::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good28
P+ = [] 
P- = [H(good28::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad28::call), H(good28::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N4263 in bad28: 
N4263 -> P+ = [H(bad28::call)], P- = [] Point-To: L(bad28::data) -> [H(bad28::call)]
N4265 -> P+ = [H(bad28::call)], P- = [] Point-To: L(bad28::data) -> [H(bad28::call)]
----
loop N4335 in good28: 
N4335 -> P+ = [H(good28::call)], P- = [] Point-To: L(good28::data) -> [H(good28::call)]
N4337 -> P+ = [H(good28::call)], P- = [] Point-To: L(good28::data) -> [H(good28::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4374): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N4290
On edge  : N4290 -{call printStructLine}-> N4423
Message  : the memory is already freed
> Start from entry function: main, At N4374 of Function main
> Entering function: good28, On N4436 -> N4317 (call good28)
> takes the true branch, At N4324 of Function good28
> takes the true branch, At N4330 of Function good28
> Leaving function: good28, On N4316 -> N4376 (Return edge from good28 to main)
> Entering function: bad28, On N4376 -> N4245 (call bad28)
> takes the true branch, At N4252 of Function bad28
> takes the false branch, At N4258 of Function bad28
> takes the false branch, At N4265 of Function bad28
> takes the true branch, At N4287 of Function bad28
<Defect> : N4290 -> N4423: [call printStructLine]
N4290 -> N4423: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4429
On edge  : N4429 -{%1 = load i32, i32* %intOne, align 4}-> N4430
Message  : use of uninitialized variable
> Start from entry function: main, At N4374 of Function main
> Entering function: good28, On N4436 -> N4317 (call good28)
> takes the true branch, At N4324 of Function good28
> takes the true branch, At N4330 of Function good28
> Leaving function: good28, On N4316 -> N4376 (Return edge from good28 to main)
> Entering function: bad28, On N4376 -> N4245 (call bad28)
> takes the true branch, At N4252 of Function bad28
> takes the false branch, At N4258 of Function bad28
> takes the false branch, At N4265 of Function bad28
> takes the true branch, At N4287 of Function bad28
> Entering function: printStructLine, On N4290 -> N4423 (call printStructLine)
<Defect> : N4429 -> N4430: [%1 = load i32, i32* %intOne, align 4]
N4429 -> N4430: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4432
On edge  : N4432 -{%3 = load i32, i32* %intTwo, align 4}-> N4433
Message  : use of uninitialized variable
> Start from entry function: main, At N4374 of Function main
> Entering function: good28, On N4436 -> N4317 (call good28)
> takes the true branch, At N4324 of Function good28
> takes the true branch, At N4330 of Function good28
> Leaving function: good28, On N4316 -> N4376 (Return edge from good28 to main)
> Entering function: bad28, On N4376 -> N4245 (call bad28)
> takes the true branch, At N4252 of Function bad28
> takes the false branch, At N4258 of Function bad28
> takes the false branch, At N4265 of Function bad28
> takes the true branch, At N4287 of Function bad28
> Entering function: printStructLine, On N4290 -> N4423 (call printStructLine)
<Defect> : N4432 -> N4433: [%3 = load i32, i32* %intTwo, align 4]
N4432 -> N4433: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_28.c 81] bad28 		[N4290 -{call printStructLine}-> N4423]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_28.c 51] printStructLine 		[N4429 -{%1 = load i32, i32* %intOne, align 4}-> N4430]	(use of uninitialized variable)
	[./416_28.c 51] printStructLine 		[N4432 -{%3 = load i32, i32* %intTwo, align 4}-> N4433]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_29.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
13 SCCs to deal with
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad29]
 +bad29
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good29]
 +good29
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine, staticReturnsFalse, staticReturnsTrue, bad29, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good29]
Loops     [N4467, N4539]
----
function: bad29
P+ = [] 
P- = [H(bad29::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good29
P+ = [] 
P- = [H(good29::call1)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad29::call1), H(good29::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
loop N4467 in bad29: 
N4467 -> P+ = [H(bad29::call1)], P- = [] Point-To: L(bad29::data) -> [H(bad29::call1)]
N4469 -> P+ = [H(bad29::call1)], P- = [] Point-To: L(bad29::data) -> [H(bad29::call1)]
----
loop N4539 in good29: 
N4539 -> P+ = [H(good29::call1)], P- = [] Point-To: L(good29::data) -> [H(good29::call1)]
N4541 -> P+ = [H(good29::call1)], P- = [] Point-To: L(good29::data) -> [H(good29::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.03s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4578): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N4494
On edge  : N4494 -{call printStructLine}-> N4627
Message  : the memory is already freed
> Start from entry function: main, At N4578 of Function main
> Entering function: good29, On N4648 -> N4521 (call good29)
> Entering function: staticReturnsTrue, On N4526 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4527 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N4528 of Function good29
> takes the true branch, At N4534 of Function good29
> Leaving function: good29, On N4520 -> N4580 (Return edge from good29 to main)
> Entering function: bad29, On N4580 -> N4449 (call bad29)
> Entering function: staticReturnsTrue, On N4454 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4455 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N4456 of Function bad29
> takes the false branch, At N4462 of Function bad29
> takes the false branch, At N4469 of Function bad29
> Entering function: staticReturnsTrue, On N4489 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4490 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N4491 of Function bad29
<Defect> : N4494 -> N4627: [call printStructLine]
N4494 -> N4627: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4633
On edge  : N4633 -{%1 = load i32, i32* %intOne, align 4}-> N4634
Message  : use of uninitialized variable
> Start from entry function: main, At N4578 of Function main
> Entering function: good29, On N4648 -> N4521 (call good29)
> Entering function: staticReturnsTrue, On N4526 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4527 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N4528 of Function good29
> takes the true branch, At N4534 of Function good29
> Leaving function: good29, On N4520 -> N4580 (Return edge from good29 to main)
> Entering function: bad29, On N4580 -> N4449 (call bad29)
> Entering function: staticReturnsTrue, On N4454 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4455 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N4456 of Function bad29
> takes the false branch, At N4462 of Function bad29
> takes the false branch, At N4469 of Function bad29
> Entering function: staticReturnsTrue, On N4489 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4490 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N4491 of Function bad29
> Entering function: printStructLine, On N4494 -> N4627 (call printStructLine)
<Defect> : N4633 -> N4634: [%1 = load i32, i32* %intOne, align 4]
N4633 -> N4634: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4636
On edge  : N4636 -{%3 = load i32, i32* %intTwo, align 4}-> N4637
Message  : use of uninitialized variable
> Start from entry function: main, At N4578 of Function main
> Entering function: good29, On N4648 -> N4521 (call good29)
> Entering function: staticReturnsTrue, On N4526 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4527 (Return edge from staticReturnsTrue to good29)
> takes the true branch, At N4528 of Function good29
> takes the true branch, At N4534 of Function good29
> Leaving function: good29, On N4520 -> N4580 (Return edge from good29 to main)
> Entering function: bad29, On N4580 -> N4449 (call bad29)
> Entering function: staticReturnsTrue, On N4454 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4455 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N4456 of Function bad29
> takes the false branch, At N4462 of Function bad29
> takes the false branch, At N4469 of Function bad29
> Entering function: staticReturnsTrue, On N4489 -> N4645 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4644 -> N4490 (Return edge from staticReturnsTrue to bad29)
> takes the true branch, At N4491 of Function bad29
> Entering function: printStructLine, On N4494 -> N4627 (call printStructLine)
<Defect> : N4636 -> N4637: [%3 = load i32, i32* %intTwo, align 4]
N4636 -> N4637: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_29.c 90] bad29 		[N4494 -{call printStructLine}-> N4627]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_29.c 62] printStructLine 		[N4633 -{%1 = load i32, i32* %intOne, align 4}-> N4634]	(use of uninitialized variable)
	[./416_29.c 62] printStructLine 		[N4636 -{%3 = load i32, i32* %intTwo, align 4}-> N4637]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_30.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printStructLine]
 +printStructLine
SCC(1): [bad30]
 +bad30
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad30, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good30, main, printHexCharLine, printIntLine, printLine, printLongLine, printStructLine]
Loops     [N4736, N4675]
----
function: bad30
P+ = [] 
P- = [H(bad30::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good30
P+ = [] 
P- = [H(good30::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad30::call), H(good30::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printStructLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N4675 in bad30: 
N4675 -> P+ = [H(bad30::call)], P- = [] Point-To: L(bad30::data) -> [H(bad30::call)]
N4677 -> P+ = [H(bad30::call)], P- = [] Point-To: L(bad30::data) -> [H(bad30::call)]
----
loop N4736 in good30: 
N4736 -> P+ = [H(good30::call)], P- = [] Point-To: L(good30::data) -> [H(good30::call)]
N4738 -> P+ = [H(good30::call)], P- = [] Point-To: L(good30::data) -> [H(good30::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4765): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N4698
On edge  : N4698 -{call printStructLine}-> N4814
Message  : the memory is already freed
> Start from entry function: main, At N4765 of Function main
> Entering function: good30, On N4827 -> N4721 (call good30)
> takes the true branch, At N4731 of Function good30
> Leaving function: good30, On N4720 -> N4767 (Return edge from good30 to main)
> Entering function: bad30, On N4767 -> N4660 (call bad30)
> takes the false branch, At N4670 of Function bad30
> takes the false branch, At N4677 of Function bad30
<Defect> : N4698 -> N4814: [call printStructLine]
N4698 -> N4814: [call printStructLine] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4820
On edge  : N4820 -{%1 = load i32, i32* %intOne, align 4}-> N4821
Message  : use of uninitialized variable
> Start from entry function: main, At N4765 of Function main
> Entering function: good30, On N4827 -> N4721 (call good30)
> takes the true branch, At N4731 of Function good30
> Leaving function: good30, On N4720 -> N4767 (Return edge from good30 to main)
> Entering function: bad30, On N4767 -> N4660 (call bad30)
> takes the false branch, At N4670 of Function bad30
> takes the false branch, At N4677 of Function bad30
> Entering function: printStructLine, On N4698 -> N4814 (call printStructLine)
<Defect> : N4820 -> N4821: [%1 = load i32, i32* %intOne, align 4]
N4820 -> N4821: [%1 = load i32, i32* %intOne, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N4823
On edge  : N4823 -{%3 = load i32, i32* %intTwo, align 4}-> N4824
Message  : use of uninitialized variable
> Start from entry function: main, At N4765 of Function main
> Entering function: good30, On N4827 -> N4721 (call good30)
> takes the true branch, At N4731 of Function good30
> Leaving function: good30, On N4720 -> N4767 (Return edge from good30 to main)
> Entering function: bad30, On N4767 -> N4660 (call bad30)
> takes the false branch, At N4670 of Function bad30
> takes the false branch, At N4677 of Function bad30
> Entering function: printStructLine, On N4698 -> N4814 (call printStructLine)
<Defect> : N4823 -> N4824: [%3 = load i32, i32* %intTwo, align 4]
N4823 -> N4824: [%3 = load i32, i32* %intTwo, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_30.c 79] bad30 		[N4698 -{call printStructLine}-> N4814]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 2
	[./416_30.c 51] printStructLine 		[N4820 -{%1 = load i32, i32* %intOne, align 4}-> N4821]	(use of uninitialized variable)
	[./416_30.c 51] printStructLine 		[N4823 -{%3 = load i32, i32* %intTwo, align 4}-> N4824]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_31.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad31]
 +bad31
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad31, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good31, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N4989, N4918]
----
function: bad31
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good31
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N4918 in helperBad: 
N4918 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N4921 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N4989 in helperGood: 
N4989 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N4992 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5028): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N4848
On edge  : N4848 -{call printLine}-> N5053
Message  : the memory is already freed
> Start from entry function: main, At N5028 of Function main
> Entering function: good31, On N5076 -> N4869 (call good31)
> Entering function: helperGood, On N4872 -> N4959 (call helperGood)
> takes the true branch, At N4974 of Function helperGood
> takes the true branch, At N4984 of Function helperGood
> Leaving function: helperGood, On N4958 -> N4873 (Return edge from helperGood to good31)
> takes the true branch, At N4876 of Function good31
> Leaving function: good31, On N4868 -> N5030 (Return edge from good31 to main)
> Entering function: bad31, On N5030 -> N4838 (call bad31)
> Entering function: helperBad, On N4841 -> N4888 (call helperBad)
> takes the true branch, At N4903 of Function helperBad
> takes the false branch, At N4913 of Function helperBad
> takes the false branch, At N4921 of Function helperBad
> Leaving function: helperBad, On N4887 -> N4842 (Return edge from helperBad to bad31)
> takes the false branch, At N4845 of Function bad31
<Defect> : N4848 -> N5053: [call printLine]
N4848 -> N5053: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_31.c 108] bad31 		[N4848 -{call printLine}-> N5053]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_32.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad32]
 +bad32
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good32, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine, bad32]
Loops     [N5239, N5168]
----
function: bad32
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good32
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N5168 in helperBad: 
N5168 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N5171 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N5239 in helperGood: 
N5239 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N5242 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5278): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N5098
On edge  : N5098 -{call printLine}-> N5303
Message  : the memory is already freed
> Start from entry function: main, At N5278 of Function main
> Entering function: good32, On N5326 -> N5119 (call good32)
> Entering function: helperGood, On N5122 -> N5209 (call helperGood)
> takes the true branch, At N5224 of Function helperGood
> takes the true branch, At N5234 of Function helperGood
> Leaving function: helperGood, On N5208 -> N5123 (Return edge from helperGood to good32)
> takes the true branch, At N5126 of Function good32
> Leaving function: good32, On N5118 -> N5280 (Return edge from good32 to main)
> Entering function: bad32, On N5280 -> N5088 (call bad32)
> Entering function: helperBad, On N5091 -> N5138 (call helperBad)
> takes the true branch, At N5153 of Function helperBad
> takes the false branch, At N5163 of Function helperBad
> takes the false branch, At N5171 of Function helperBad
> Leaving function: helperBad, On N5137 -> N5092 (Return edge from helperBad to bad32)
> takes the false branch, At N5095 of Function bad32
<Defect> : N5098 -> N5303: [call printLine]
N5098 -> N5303: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_32.c 109] bad32 		[N5098 -{call printLine}-> N5303]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_33.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad33]
 +bad33
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good33, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine, bad33]
Loops     [N5489, N5418]
----
function: bad33
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good33
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N5418 in helperBad: 
N5418 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N5421 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N5489 in helperGood: 
N5489 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N5492 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5528): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N5348
On edge  : N5348 -{call printLine}-> N5553
Message  : the memory is already freed
> Start from entry function: main, At N5528 of Function main
> Entering function: good33, On N5576 -> N5369 (call good33)
> Entering function: helperGood, On N5372 -> N5459 (call helperGood)
> takes the true branch, At N5474 of Function helperGood
> takes the true branch, At N5484 of Function helperGood
> Leaving function: helperGood, On N5458 -> N5373 (Return edge from helperGood to good33)
> takes the true branch, At N5376 of Function good33
> Leaving function: good33, On N5368 -> N5530 (Return edge from good33 to main)
> Entering function: bad33, On N5530 -> N5338 (call bad33)
> Entering function: helperBad, On N5341 -> N5388 (call helperBad)
> takes the true branch, At N5403 of Function helperBad
> takes the false branch, At N5413 of Function helperBad
> takes the false branch, At N5421 of Function helperBad
> Leaving function: helperBad, On N5387 -> N5342 (Return edge from helperBad to bad33)
> takes the false branch, At N5345 of Function bad33
<Defect> : N5348 -> N5553: [call printLine]
N5348 -> N5553: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_33.c 109] bad33 		[N5348 -{call printLine}-> N5553]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_34.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad34]
 +bad34
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good34, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine, bad34]
Loops     [N5668, N5739]
----
function: bad34
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good34
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N5668 in helperBad: 
N5668 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N5671 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N5739 in helperGood: 
N5739 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N5742 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.02s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5778): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N5598
On edge  : N5598 -{call printLine}-> N5803
Message  : the memory is already freed
> Start from entry function: main, At N5778 of Function main
> Entering function: good34, On N5826 -> N5619 (call good34)
> Entering function: helperGood, On N5622 -> N5709 (call helperGood)
> takes the true branch, At N5724 of Function helperGood
> takes the true branch, At N5734 of Function helperGood
> Leaving function: helperGood, On N5708 -> N5623 (Return edge from helperGood to good34)
> takes the true branch, At N5626 of Function good34
> Leaving function: good34, On N5618 -> N5780 (Return edge from good34 to main)
> Entering function: bad34, On N5780 -> N5588 (call bad34)
> Entering function: helperBad, On N5591 -> N5638 (call helperBad)
> takes the true branch, At N5653 of Function helperBad
> takes the false branch, At N5663 of Function helperBad
> takes the false branch, At N5671 of Function helperBad
> Leaving function: helperBad, On N5637 -> N5592 (Return edge from helperBad to bad34)
> takes the false branch, At N5595 of Function bad34
<Defect> : N5598 -> N5803: [call printLine]
N5598 -> N5803: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_34.c 115] bad34 		[N5598 -{call printLine}-> N5803]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_35.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad35]
 +bad35
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad35, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good35, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N6001, N5930]
----
function: bad35
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good35
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N5930 in helperBad: 
N5930 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N5933 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N6001 in helperGood: 
N6001 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N6004 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.189s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6040): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N5851
On edge  : N5851 -{call printLine}-> N6065
Message  : the memory is already freed
> Start from entry function: main, At N6040 of Function main
> Entering function: good35, On N6088 -> N5874 (call good35)
> takes the false branch, At N5878 of Function good35
> Entering function: helperGood, On N5896 -> N5971 (call helperGood)
> takes the true branch, At N5986 of Function helperGood
> takes the true branch, At N5996 of Function helperGood
> Leaving function: helperGood, On N5970 -> N5883 (Return edge from helperGood to good35)
> takes the true branch, At N5886 of Function good35
> Leaving function: good35, On N5873 -> N6042 (Return edge from good35 to main)
> Entering function: bad35, On N6042 -> N5838 (call bad35)
> takes the true branch, At N5842 of Function bad35
> Entering function: helperBad, On N5855 -> N5900 (call helperBad)
> takes the true branch, At N5915 of Function helperBad
> takes the false branch, At N5925 of Function helperBad
> takes the false branch, At N5933 of Function helperBad
> Leaving function: helperBad, On N5899 -> N5845 (Return edge from helperBad to bad35)
> takes the false branch, At N5848 of Function bad35
<Defect> : N5851 -> N6065: [call printLine]
N5851 -> N6065: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_35.c 115] bad35 		[N5851 -{call printLine}-> N6065]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_36.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad36]
 +bad36
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good36, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine, bad36]
Loops     [N6183, N6254]
----
function: bad36
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good36
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N6183 in helperBad: 
N6183 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N6186 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N6254 in helperGood: 
N6254 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N6257 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.023s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6293): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N6113
On edge  : N6113 -{call printLine}-> N6318
Message  : the memory is already freed
> Start from entry function: main, At N6293 of Function main
> Entering function: good36, On N6341 -> N6134 (call good36)
> Entering function: helperGood, On N6137 -> N6224 (call helperGood)
> takes the true branch, At N6239 of Function helperGood
> takes the true branch, At N6249 of Function helperGood
> Leaving function: helperGood, On N6223 -> N6138 (Return edge from helperGood to good36)
> takes the true branch, At N6141 of Function good36
> Leaving function: good36, On N6133 -> N6295 (Return edge from good36 to main)
> Entering function: bad36, On N6295 -> N6103 (call bad36)
> Entering function: helperBad, On N6106 -> N6153 (call helperBad)
> takes the true branch, At N6168 of Function helperBad
> takes the false branch, At N6178 of Function helperBad
> takes the false branch, At N6186 of Function helperBad
> Leaving function: helperBad, On N6152 -> N6107 (Return edge from helperBad to bad36)
> takes the false branch, At N6110 of Function bad36
<Defect> : N6113 -> N6318: [call printLine]
N6113 -> N6318: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_36.c 114] bad36 		[N6113 -{call printLine}-> N6318]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_37.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad37, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good37, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N6445, N6516]
----
function: bad37
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good37
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N6445 in helperBad: 
N6445 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N6448 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N6516 in helperGood: 
N6516 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N6519 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6555): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N6366
On edge  : N6366 -{call printLine}-> N6580
Message  : the memory is already freed
> Start from entry function: main, At N6555 of Function main
> Entering function: good37, On N6603 -> N6389 (call good37)
> takes the false branch, At N6393 of Function good37
> Entering function: helperGood, On N6411 -> N6486 (call helperGood)
> takes the true branch, At N6501 of Function helperGood
> takes the true branch, At N6511 of Function helperGood
> Leaving function: helperGood, On N6485 -> N6398 (Return edge from helperGood to good37)
> takes the true branch, At N6401 of Function good37
> Leaving function: good37, On N6388 -> N6557 (Return edge from good37 to main)
> Entering function: bad37, On N6557 -> N6353 (call bad37)
> takes the true branch, At N6357 of Function bad37
> Entering function: helperBad, On N6370 -> N6415 (call helperBad)
> takes the true branch, At N6430 of Function helperBad
> takes the false branch, At N6440 of Function helperBad
> takes the false branch, At N6448 of Function helperBad
> Leaving function: helperBad, On N6414 -> N6360 (Return edge from helperBad to bad37)
> takes the false branch, At N6363 of Function bad37
<Defect> : N6366 -> N6580: [call printLine]
N6366 -> N6580: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_37.c 114] bad37 		[N6366 -{call printLine}-> N6580]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_38.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
14 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good38, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue, bad38]
Loops     [N6709, N6780]
----
function: bad38
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good38
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
loop N6709 in helperBad: 
N6709 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N6712 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N6780 in helperGood: 
N6780 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N6783 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.011s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6819): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N6630
On edge  : N6630 -{call printLine}-> N6844
Message  : the memory is already freed
> Start from entry function: main, At N6819 of Function main
> Entering function: good38, On N6875 -> N6653 (call good38)
> Entering function: staticReturnsFalse, On N6655 -> N6868 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N6867 -> N6656 (Return edge from staticReturnsFalse to good38)
> takes the false branch, At N6657 of Function good38
> Entering function: helperGood, On N6675 -> N6750 (call helperGood)
> takes the true branch, At N6765 of Function helperGood
> takes the true branch, At N6775 of Function helperGood
> Leaving function: helperGood, On N6749 -> N6662 (Return edge from helperGood to good38)
> takes the true branch, At N6665 of Function good38
> Leaving function: good38, On N6652 -> N6821 (Return edge from good38 to main)
> Entering function: bad38, On N6821 -> N6617 (call bad38)
> Entering function: staticReturnsTrue, On N6619 -> N6872 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N6871 -> N6620 (Return edge from staticReturnsTrue to bad38)
> takes the true branch, At N6621 of Function bad38
> Entering function: helperBad, On N6634 -> N6679 (call helperBad)
> takes the true branch, At N6694 of Function helperBad
> takes the false branch, At N6704 of Function helperBad
> takes the false branch, At N6712 of Function helperBad
> Leaving function: helperBad, On N6678 -> N6624 (Return edge from helperBad to bad38)
> takes the false branch, At N6627 of Function bad38
<Defect> : N6630 -> N6844: [call printLine]
N6630 -> N6844: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_38.c 122] bad38 		[N6630 -{call printLine}-> N6844]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_39.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad39, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good39, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N6968, N7039]
----
function: bad39
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good39
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N6968 in helperBad: 
N6968 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N6971 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N7039 in helperGood: 
N7039 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N7042 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N7078): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N6898
On edge  : N6898 -{call printLine}-> N7103
Message  : the memory is already freed
> Start from entry function: main, At N7078 of Function main
> Entering function: good39, On N7126 -> N6919 (call good39)
> Entering function: helperGood, On N6922 -> N7009 (call helperGood)
> takes the true branch, At N7024 of Function helperGood
> takes the true branch, At N7034 of Function helperGood
> Leaving function: helperGood, On N7008 -> N6923 (Return edge from helperGood to good39)
> takes the true branch, At N6926 of Function good39
> Leaving function: good39, On N6918 -> N7080 (Return edge from good39 to main)
> Entering function: bad39, On N7080 -> N6888 (call bad39)
> Entering function: helperBad, On N6891 -> N6938 (call helperBad)
> takes the true branch, At N6953 of Function helperBad
> takes the false branch, At N6963 of Function helperBad
> takes the false branch, At N6971 of Function helperBad
> Leaving function: helperBad, On N6937 -> N6892 (Return edge from helperBad to bad39)
> takes the false branch, At N6895 of Function bad39
<Defect> : N6898 -> N7103: [call printLine]
N6898 -> N7103: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_39.c 109] bad39 		[N6898 -{call printLine}-> N7103]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_40.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad40, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good40, helperBad, helperGood, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N7230, N7301]
----
function: bad40
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good40
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N7230 in helperBad: 
N7230 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N7233 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N7301 in helperGood: 
N7301 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N7304 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N7340): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N7151
On edge  : N7151 -{call printLine}-> N7365
Message  : the memory is already freed
> Start from entry function: main, At N7340 of Function main
> Entering function: good40, On N7388 -> N7174 (call good40)
> takes the false branch, At N7178 of Function good40
> Entering function: helperGood, On N7196 -> N7271 (call helperGood)
> takes the true branch, At N7286 of Function helperGood
> takes the true branch, At N7296 of Function helperGood
> Leaving function: helperGood, On N7270 -> N7183 (Return edge from helperGood to good40)
> takes the true branch, At N7186 of Function good40
> Leaving function: good40, On N7173 -> N7342 (Return edge from good40 to main)
> Entering function: bad40, On N7342 -> N7138 (call bad40)
> takes the true branch, At N7142 of Function bad40
> Entering function: helperBad, On N7155 -> N7200 (call helperBad)
> takes the true branch, At N7215 of Function helperBad
> takes the false branch, At N7225 of Function helperBad
> takes the false branch, At N7233 of Function helperBad
> Leaving function: helperBad, On N7199 -> N7145 (Return edge from helperBad to bad40)
> takes the false branch, At N7148 of Function bad40
<Defect> : N7151 -> N7365: [call printLine]
N7151 -> N7365: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_40.c 109] bad40 		[N7151 -{call printLine}-> N7365]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_41.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad41]
 +bad41
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad41, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good41, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N7416, N7472]
----
function: bad41
P+ = [] 
P- = [H(bad41::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good41
P+ = [] 
P- = [H(good41::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad41::call), H(good41::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N7416 in bad41: 
N7416 -> P+ = [H(bad41::call)], P- = [] Point-To: L(bad41::data) -> [H(bad41::call)]
N7418 -> P+ = [H(bad41::call)], P- = [] Point-To: L(bad41::data) -> [H(bad41::call)]
----
loop N7472 in good41: 
N7472 -> P+ = [H(good41::call)], P- = [] Point-To: L(good41::data) -> [H(good41::call)]
N7474 -> P+ = [H(good41::call)], P- = [] Point-To: L(good41::data) -> [H(good41::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N7495): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N7433
On edge  : N7433 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7434
Message  : the memory is already freed
> Start from entry function: main, At N7495 of Function main
> Entering function: bad41, On N7543 -> N7401 (call bad41)
> takes the false branch, At N7411 of Function bad41
> takes the false branch, At N7418 of Function bad41
<Defect> : N7433 -> N7434: [%9 = load i32, i32* %arrayidx2, align 4]
N7433 -> N7434: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N7433
On edge  : N7433 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7434
Message  : use of uninitialized variable
> Start from entry function: main, At N7495 of Function main
> Entering function: bad41, On N7543 -> N7401 (call bad41)
> takes the false branch, At N7411 of Function bad41
> takes the false branch, At N7418 of Function bad41
<Defect> : N7433 -> N7434: [%9 = load i32, i32* %arrayidx2, align 4]
N7433 -> N7434: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_41.c 81] bad41 		[N7433 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7434]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_41.c 81] bad41 		[N7433 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7434]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_42.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad42, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good42]
Loops     [N7628, N7569]
----
function: bad42
P+ = [] 
P- = [H(bad42::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good42
P+ = [] 
P- = [H(good42::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad42::call), H(good42::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N7569 in bad42: 
N7569 -> P+ = [H(bad42::call)], P- = [] Point-To: L(bad42::data) -> [H(bad42::call)]
N7571 -> P+ = [H(bad42::call)], P- = [] Point-To: L(bad42::data) -> [H(bad42::call)]
----
loop N7628 in good42: 
N7628 -> P+ = [H(good42::call)], P- = [] Point-To: L(good42::data) -> [H(good42::call)]
N7630 -> P+ = [H(good42::call)], P- = [] Point-To: L(good42::data) -> [H(good42::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N7653): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N7588
On edge  : N7588 -{%9 = load i32, i32* %arrayidx3, align 4}-> N7589
Message  : the memory is already freed
> Start from entry function: main, At N7653 of Function main
> Entering function: good42, On N7701 -> N7612 (call good42)
> takes the true branch, At N7623 of Function good42
> Leaving function: good42, On N7611 -> N7655 (Return edge from good42 to main)
> Entering function: bad42, On N7655 -> N7553 (call bad42)
> takes the false branch, At N7564 of Function bad42
> takes the false branch, At N7571 of Function bad42
<Defect> : N7588 -> N7589: [%9 = load i32, i32* %arrayidx3, align 4]
N7588 -> N7589: [%9 = load i32, i32* %arrayidx3, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N7588
On edge  : N7588 -{%9 = load i32, i32* %arrayidx3, align 4}-> N7589
Message  : use of uninitialized variable
> Start from entry function: main, At N7653 of Function main
> Entering function: good42, On N7701 -> N7612 (call good42)
> takes the true branch, At N7623 of Function good42
> Leaving function: good42, On N7611 -> N7655 (Return edge from good42 to main)
> Entering function: bad42, On N7655 -> N7553 (call bad42)
> takes the false branch, At N7564 of Function bad42
> takes the false branch, At N7571 of Function bad42
<Defect> : N7588 -> N7589: [%9 = load i32, i32* %arrayidx3, align 4]
N7588 -> N7589: [%9 = load i32, i32* %arrayidx3, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_42.c 75] bad42 		[N7588 -{%9 = load i32, i32* %arrayidx3, align 4}-> N7589]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_42.c 75] bad42 		[N7588 -{%9 = load i32, i32* %arrayidx3, align 4}-> N7589]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_43.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad43, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good43, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N7805, N7733]
----
function: bad43
P+ = [] 
P- = [H(bad43::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good43
P+ = [] 
P- = [H(good43::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad43::call), H(good43::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N7733 in bad43: 
N7720 -> P+ = [H(bad43::call)], P- = [H(bad43::call)] Point-To: L(bad43::data) -> [N, H(bad43::call)]
N7722 -> P+ = [H(bad43::call)], P- = [H(bad43::call)] Point-To: L(bad43::data) -> [N, H(bad43::call)]
N7728 -> P+ = [H(bad43::call)], P- = [H(bad43::call)] Point-To: L(bad43::data) -> [H(bad43::call)]
----
loop N7805 in good43: 
N7792 -> P+ = [H(good43::call)], P- = [H(good43::call)] Point-To: L(good43::data) -> [N, H(good43::call)]
N7794 -> P+ = [H(good43::call)], P- = [H(good43::call)] Point-To: L(good43::data) -> [N, H(good43::call)]
N7800 -> P+ = [H(good43::call)], P- = [H(good43::call)] Point-To: L(good43::data) -> [H(good43::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.011s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N7834): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N7755
On edge  : N7755 -{%11 = load i32, i32* %arrayidx9, align 4}-> N7756
Message  : the memory is already freed
> Start from entry function: main, At N7834 of Function main
> Entering function: good43, On N7882 -> N7781 (call good43)
> takes the true branch, At N7794 of Function good43
> takes the true branch, At N7800 of Function good43
> Leaving function: good43, On N7780 -> N7836 (Return edge from good43 to main)
> Entering function: bad43, On N7836 -> N7711 (call bad43)
> takes the true branch, At N7722 of Function bad43
> takes the false branch, At N7728 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the false branch, At N7735 of Function bad43
> takes the false branch, At N7722 of Function bad43
<Defect> : N7755 -> N7756: [%11 = load i32, i32* %arrayidx9, align 4]
N7755 -> N7756: [%11 = load i32, i32* %arrayidx9, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N7755
On edge  : N7755 -{%11 = load i32, i32* %arrayidx9, align 4}-> N7756
Message  : use of uninitialized variable
> Start from entry function: main, At N7834 of Function main
> Entering function: good43, On N7882 -> N7781 (call good43)
> takes the true branch, At N7794 of Function good43
> takes the true branch, At N7800 of Function good43
> Leaving function: good43, On N7780 -> N7836 (Return edge from good43 to main)
> Entering function: bad43, On N7836 -> N7711 (call bad43)
> takes the true branch, At N7722 of Function bad43
> takes the false branch, At N7728 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the true branch, At N7735 of Function bad43
> takes the false branch, At N7735 of Function bad43
> takes the false branch, At N7722 of Function bad43
<Defect> : N7755 -> N7756: [%11 = load i32, i32* %arrayidx9, align 4]
N7755 -> N7756: [%11 = load i32, i32* %arrayidx9, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[416_43.c 74] bad43 		[N7755 -{%11 = load i32, i32* %arrayidx9, align 4}-> N7756]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[416_43.c 74] bad43 		[N7755 -{%11 = load i32, i32* %arrayidx9, align 4}-> N7756]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_44.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good44, main, printHexCharLine, printIntLine, printLine, printLongLine, bad44]
Loops     [N7908, N7966]
----
function: bad44
P+ = [] 
P- = [H(bad44::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good44
P+ = [] 
P- = [H(good44::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad44::call), H(good44::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N7908 in bad44: 
N7908 -> P+ = [H(bad44::call)], P- = [] Point-To: L(bad44::data) -> [H(bad44::call)]
N7910 -> P+ = [H(bad44::call)], P- = [] Point-To: L(bad44::data) -> [H(bad44::call)]
----
loop N7966 in good44: 
N7966 -> P+ = [H(good44::call)], P- = [] Point-To: L(good44::data) -> [H(good44::call)]
N7968 -> P+ = [H(good44::call)], P- = [] Point-To: L(good44::data) -> [H(good44::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N7989): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N7926
On edge  : N7926 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7927
Message  : the memory is already freed
> Start from entry function: main, At N7989 of Function main
> Entering function: bad44, On N8037 -> N7892 (call bad44)
> takes the false branch, At N7903 of Function bad44
> takes the false branch, At N7910 of Function bad44
<Defect> : N7926 -> N7927: [%9 = load i32, i32* %arrayidx2, align 4]
N7926 -> N7927: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N7926
On edge  : N7926 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7927
Message  : use of uninitialized variable
> Start from entry function: main, At N7989 of Function main
> Entering function: bad44, On N8037 -> N7892 (call bad44)
> takes the false branch, At N7903 of Function bad44
> takes the false branch, At N7910 of Function bad44
<Defect> : N7926 -> N7927: [%9 = load i32, i32* %arrayidx2, align 4]
N7926 -> N7927: [%9 = load i32, i32* %arrayidx2, align 4] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_44.c 73] bad44 		[N7926 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7927]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_44.c 73] bad44 		[N7926 -{%9 = load i32, i32* %arrayidx2, align 4}-> N7927]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_45.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad45, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good45, main, printHexCharLine, printIntLine]
Loops     [N8118, N8062]
----
function: bad45
P+ = [] 
P- = [H(bad45::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good45
P+ = [] 
P- = [H(good45::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad45::call), H(good45::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N8062 in bad45: 
N8062 -> P+ = [H(bad45::call)], P- = [] Point-To: L(bad45::data) -> [H(bad45::call)]
N8064 -> P+ = [H(bad45::call)], P- = [] Point-To: L(bad45::data) -> [H(bad45::call)]
----
loop N8118 in good45: 
N8118 -> P+ = [H(good45::call)], P- = [] Point-To: L(good45::data) -> [H(good45::call)]
N8120 -> P+ = [H(good45::call)], P- = [] Point-To: L(good45::data) -> [H(good45::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N8141): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N8079
On edge  : N8079 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8080
Message  : the memory is already freed
> Start from entry function: main, At N8141 of Function main
> Entering function: good45, On N8189 -> N8103 (call good45)
> takes the true branch, At N8113 of Function good45
> Leaving function: good45, On N8102 -> N8143 (Return edge from good45 to main)
> Entering function: bad45, On N8143 -> N8047 (call bad45)
> takes the false branch, At N8057 of Function bad45
> takes the false branch, At N8064 of Function bad45
<Defect> : N8079 -> N8080: [%9 = load i64, i64* %arrayidx2, align 8]
N8079 -> N8080: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N8079
On edge  : N8079 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8080
Message  : use of uninitialized variable
> Start from entry function: main, At N8141 of Function main
> Entering function: good45, On N8189 -> N8103 (call good45)
> takes the true branch, At N8113 of Function good45
> Leaving function: good45, On N8102 -> N8143 (Return edge from good45 to main)
> Entering function: bad45, On N8143 -> N8047 (call bad45)
> takes the false branch, At N8057 of Function bad45
> takes the false branch, At N8064 of Function bad45
<Defect> : N8079 -> N8080: [%9 = load i64, i64* %arrayidx2, align 8]
N8079 -> N8080: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_45.c 81] bad45 		[N8079 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8080]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_45.c 81] bad45 		[N8079 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8080]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_46.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [bad46, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good46, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N8215, N8274]
----
function: bad46
P+ = [] 
P- = [H(bad46::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good46
P+ = [] 
P- = [H(good46::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad46::call), H(good46::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N8215 in bad46: 
N8215 -> P+ = [H(bad46::call)], P- = [] Point-To: L(bad46::data) -> [H(bad46::call)]
N8217 -> P+ = [H(bad46::call)], P- = [] Point-To: L(bad46::data) -> [H(bad46::call)]
----
loop N8274 in good46: 
N8274 -> P+ = [H(good46::call)], P- = [] Point-To: L(good46::data) -> [H(good46::call)]
N8276 -> P+ = [H(good46::call)], P- = [] Point-To: L(good46::data) -> [H(good46::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N8299): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N8234
On edge  : N8234 -{%9 = load i64, i64* %arrayidx3, align 8}-> N8235
Message  : the memory is already freed
> Start from entry function: main, At N8299 of Function main
> Entering function: good46, On N8347 -> N8258 (call good46)
> takes the true branch, At N8269 of Function good46
> Leaving function: good46, On N8257 -> N8301 (Return edge from good46 to main)
> Entering function: bad46, On N8301 -> N8199 (call bad46)
> takes the false branch, At N8210 of Function bad46
> takes the false branch, At N8217 of Function bad46
<Defect> : N8234 -> N8235: [%9 = load i64, i64* %arrayidx3, align 8]
N8234 -> N8235: [%9 = load i64, i64* %arrayidx3, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N8234
On edge  : N8234 -{%9 = load i64, i64* %arrayidx3, align 8}-> N8235
Message  : use of uninitialized variable
> Start from entry function: main, At N8299 of Function main
> Entering function: good46, On N8347 -> N8258 (call good46)
> takes the true branch, At N8269 of Function good46
> Leaving function: good46, On N8257 -> N8301 (Return edge from good46 to main)
> Entering function: bad46, On N8301 -> N8199 (call bad46)
> takes the false branch, At N8210 of Function bad46
> takes the false branch, At N8217 of Function bad46
<Defect> : N8234 -> N8235: [%9 = load i64, i64* %arrayidx3, align 8]
N8234 -> N8235: [%9 = load i64, i64* %arrayidx3, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_46.c 75] bad46 		[N8234 -{%9 = load i64, i64* %arrayidx3, align 8}-> N8235]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_46.c 75] bad46 		[N8234 -{%9 = load i64, i64* %arrayidx3, align 8}-> N8235]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_47.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad47]
 +bad47
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good47, main, printHexCharLine, printIntLine, printLine, printLongLine, bad47]
Loops     [N8381, N8403, N8451, N8486]
----
function: bad47
P+ = [] 
P- = [H(bad47::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good47
P+ = [] 
P- = [H(good47::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad47::call), H(good47::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N8381 in bad47: 
N8368 -> P+ = [H(bad47::call)], P- = [H(bad47::call)] Point-To: L(bad47::data) -> [N, H(bad47::call)]
N8370 -> P+ = [H(bad47::call)], P- = [H(bad47::call)] Point-To: L(bad47::data) -> [N, H(bad47::call)]
N8376 -> P+ = [H(bad47::call)], P- = [H(bad47::call)] Point-To: L(bad47::data) -> [H(bad47::call)]
----
loop N8403 in bad47: 
N8403 -> P+ = [H(bad47::call)], P- = [H(bad47::call)] Point-To: L(bad47::data) -> [N, H(bad47::call)]
N8405 -> P+ = [H(bad47::call)], P- = [H(bad47::call)] Point-To: L(bad47::data) -> [N, H(bad47::call)]
----
loop N8451 in good47: 
N8451 -> P+ = [H(good47::call)], P- = [H(good47::call)] Point-To: L(good47::data) -> [N, H(good47::call)]
N8453 -> P+ = [H(good47::call)], P- = [H(good47::call)] Point-To: L(good47::data) -> [N, H(good47::call)]
N8459 -> P+ = [H(good47::call)], P- = [H(good47::call)] Point-To: L(good47::data) -> [H(good47::call)]
----
loop N8486 in good47: 
N8486 -> P+ = [H(good47::call)], P- = [H(good47::call)] Point-To: L(good47::data) -> [N, H(good47::call)]
N8488 -> P+ = [H(good47::call)], P- = [H(good47::call)] Point-To: L(good47::data) -> [N, H(good47::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N8505): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N8408
On edge  : N8408 -{%12 = load i64, i64* %arrayidx12, align 8}-> N8409
Message  : the memory is already freed
> Start from entry function: main, At N8505 of Function main
> Entering function: good47, On N8553 -> N8440 (call good47)
> takes the true branch, At N8453 of Function good47
> takes the true branch, At N8459 of Function good47
> Leaving function: good47, On N8439 -> N8507 (Return edge from good47 to main)
> Entering function: bad47, On N8507 -> N8357 (call bad47)
> takes the true branch, At N8370 of Function bad47
> takes the false branch, At N8376 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the false branch, At N8383 of Function bad47
> takes the false branch, At N8370 of Function bad47
> takes the true branch, At N8405 of Function bad47
<Defect> : N8408 -> N8409: [%12 = load i64, i64* %arrayidx12, align 8]
N8408 -> N8409: [%12 = load i64, i64* %arrayidx12, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N8408
On edge  : N8408 -{%12 = load i64, i64* %arrayidx12, align 8}-> N8409
Message  : use of uninitialized variable
> Start from entry function: main, At N8505 of Function main
> Entering function: good47, On N8553 -> N8440 (call good47)
> takes the true branch, At N8453 of Function good47
> takes the true branch, At N8459 of Function good47
> Leaving function: good47, On N8439 -> N8507 (Return edge from good47 to main)
> Entering function: bad47, On N8507 -> N8357 (call bad47)
> takes the true branch, At N8370 of Function bad47
> takes the false branch, At N8376 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the true branch, At N8383 of Function bad47
> takes the false branch, At N8383 of Function bad47
> takes the false branch, At N8370 of Function bad47
> takes the true branch, At N8405 of Function bad47
<Defect> : N8408 -> N8409: [%12 = load i64, i64* %arrayidx12, align 8]
N8408 -> N8409: [%12 = load i64, i64* %arrayidx12, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[416_47.c 75] bad47 		[N8408 -{%12 = load i64, i64* %arrayidx12, align 8}-> N8409]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[416_47.c 75] bad47 		[N8408 -{%12 = load i64, i64* %arrayidx12, align 8}-> N8409]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_48.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad48, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good48, main, printHexCharLine]
Loops     [N8637, N8579]
----
function: bad48
P+ = [] 
P- = [H(bad48::call)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good48
P+ = [] 
P- = [H(good48::call)] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [H(bad48::call), H(good48::call)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N8579 in bad48: 
N8579 -> P+ = [H(bad48::call)], P- = [] Point-To: L(bad48::data) -> [H(bad48::call)]
N8581 -> P+ = [H(bad48::call)], P- = [] Point-To: L(bad48::data) -> [H(bad48::call)]
----
loop N8637 in good48: 
N8637 -> P+ = [H(good48::call)], P- = [] Point-To: L(good48::data) -> [H(good48::call)]
N8639 -> P+ = [H(good48::call)], P- = [] Point-To: L(good48::data) -> [H(good48::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N8660): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N8597
On edge  : N8597 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8598
Message  : the memory is already freed
> Start from entry function: main, At N8660 of Function main
> Entering function: bad48, On N8708 -> N8563 (call bad48)
> takes the false branch, At N8574 of Function bad48
> takes the false branch, At N8581 of Function bad48
<Defect> : N8597 -> N8598: [%9 = load i64, i64* %arrayidx2, align 8]
N8597 -> N8598: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N8597
On edge  : N8597 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8598
Message  : use of uninitialized variable
> Start from entry function: main, At N8660 of Function main
> Entering function: bad48, On N8708 -> N8563 (call bad48)
> takes the false branch, At N8574 of Function bad48
> takes the false branch, At N8581 of Function bad48
<Defect> : N8597 -> N8598: [%9 = load i64, i64* %arrayidx2, align 8]
N8597 -> N8598: [%9 = load i64, i64* %arrayidx2, align 8] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_48.c 73] bad48 		[N8597 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8598]	(the memory is already freed)

CWE_457(Use of Uninitialized Variable): 1
	[./416_48.c 73] bad48 		[N8597 -{%9 = load i64, i64* %arrayidx2, align 8}-> N8598]	(use of uninitialized variable)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_49.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad49, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good49, helperBad, helperGood, main, printHexCharLine, printIntLine]
Loops     [N8869, N8798]
----
function: bad49
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good49
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N8798 in helperBad: 
N8798 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N8801 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N8869 in helperGood: 
N8869 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N8872 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N8908): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N8728
On edge  : N8728 -{call printLine}-> N8933
Message  : the memory is already freed
> Start from entry function: main, At N8908 of Function main
> Entering function: good49, On N8956 -> N8749 (call good49)
> Entering function: helperGood, On N8752 -> N8839 (call helperGood)
> takes the true branch, At N8854 of Function helperGood
> takes the true branch, At N8864 of Function helperGood
> Leaving function: helperGood, On N8838 -> N8753 (Return edge from helperGood to good49)
> takes the true branch, At N8756 of Function good49
> Leaving function: good49, On N8748 -> N8910 (Return edge from good49 to main)
> Entering function: bad49, On N8910 -> N8718 (call bad49)
> Entering function: helperBad, On N8721 -> N8768 (call helperBad)
> takes the true branch, At N8783 of Function helperBad
> takes the false branch, At N8793 of Function helperBad
> takes the false branch, At N8801 of Function helperBad
> Leaving function: helperBad, On N8767 -> N8722 (Return edge from helperBad to bad49)
> takes the false branch, At N8725 of Function bad49
<Defect> : N8728 -> N8933: [call printLine]
N8728 -> N8933: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_49.c 110] bad49 		[N8728 -{call printLine}-> N8933]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/416/416_50.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [helperBad]
 +helperBad
SCC(1): [printLine]
 +printLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [helperGood]
 +helperGood
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad50, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good50, helperBad, helperGood, main, printHexCharLine, printIntLine]
Loops     [N9121, N9050]
----
function: bad50
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good50
P+ = [] 
P- = [N, H(helperGood::call1)] 
Point-To:

Ret-Value: 
----
function: helperBad
P+ = [] 
P- = [H(helperBad::call1)] 
Point-To:

Ret-Value: N, H(helperBad::call1)
----
function: helperGood
P+ = [] 
P- = [] 
Point-To:

Ret-Value: N, H(helperGood::call1)
----
function: main
P+ = [] 
P- = [N, H(helperBad::call1), H(helperGood::call1)] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N9050 in helperBad: 
N9050 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
N9053 -> P+ = [H(helperBad::call1)], P- = [] Point-To: L(helperBad::aString.addr) -> [P(helperBad::aString)]; L(helperBad::reversedString) -> [H(helperBad::call1)]
----
loop N9121 in helperGood: 
N9121 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
N9124 -> P+ = [H(helperGood::call1)], P- = [] Point-To: L(helperGood::aString.addr) -> [P(helperGood::aString)]; L(helperGood::reversedString) -> [H(helperGood::call1)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N9160): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Use After Free
At node  : N8979
On edge  : N8979 -{call printLine}-> N9185
Message  : the memory is already freed
> Start from entry function: main, At N9160 of Function main
> Entering function: good50, On N9208 -> N9000 (call good50)
> Entering function: helperGood, On N9004 -> N9091 (call helperGood)
> takes the true branch, At N9106 of Function helperGood
> takes the true branch, At N9116 of Function helperGood
> Leaving function: helperGood, On N9090 -> N9005 (Return edge from helperGood to good50)
> takes the true branch, At N9008 of Function good50
> Leaving function: good50, On N8999 -> N9162 (Return edge from good50 to main)
> Entering function: bad50, On N9162 -> N8968 (call bad50)
> Entering function: helperBad, On N8972 -> N9020 (call helperBad)
> takes the true branch, At N9035 of Function helperBad
> takes the false branch, At N9045 of Function helperBad
> takes the false branch, At N9053 of Function helperBad
> Leaving function: helperBad, On N9019 -> N8973 (Return edge from helperBad to bad50)
> takes the false branch, At N8976 of Function bad50
<Defect> : N8979 -> N9185: [call printLine]
N8979 -> N9185: [call printLine] <--
-- end of trace --
=====================================================
CWE_416(Use After Free): 1
	[./416_50.c 109] bad50 		[N8979 -{call printLine}-> N9185]	(the memory is already freed)

Found 1 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 0
