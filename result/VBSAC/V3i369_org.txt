/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=33125:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.ITC_369_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_012_good]
 +zero_division_012_good
SCC(1): [zero_division_012_bad]
 +zero_division_012_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_012_bad, zero_division_012_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_012_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_012_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.224s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
N1 -{%retval = alloca i32, align 4}-> N3
N3 -{store i32 0, i32* %retval, align 4}-> N4
N4 -{call zero_division_012_good}-> N28
N28 -{%dividend = alloca i32, align 4}-> N30
N30 -{%divisor = alloca i32, align 4}-> N31
N31 -{%ret = alloca i32, align 4}-> N33
N33 -{store i32 1000, i32* %dividend, align 4}-> N35
N35 -{store i32 2, i32* %divisor, align 4}-> N37
N37 -{%0 = load i32, i32* %dividend, align 4}-> N38
N38 -{%1 = load i32, i32* %divisor, align 4}-> N39
N39 -{%2 = load i32, i32* %divisor, align 4}-> N40
N40 -{%mul = mul i32 %1, %2}-> N41
N41 -{%sub = sub i32 %mul, 3}-> N42
N42 -{%div = sdiv i32 %0, %sub}-> N43
N43 -{store i32 %div, i32* %ret, align 4}-> N44
N44 -{ret void}-> N27
N27 -{Return edge from zero_division_012_good to main}-> N5
N5 -{call zero_division_012_bad}-> N9
N9 -{%dividend = alloca i32, align 4}-> N11
N11 -{%divisor = alloca i32, align 4}-> N12
N12 -{%ret = alloca i32, align 4}-> N14
N14 -{store i32 1000, i32* %dividend, align 4}-> N16
N16 -{store i32 2, i32* %divisor, align 4}-> N18
N18 -{%0 = load i32, i32* %dividend, align 4}-> N19
N19 -{%1 = load i32, i32* %divisor, align 4}-> N20
N20 -{%2 = load i32, i32* %divisor, align 4}-> N21
N21 -{%mul = mul i32 %1, %2}-> N22
N22 -{%sub = sub i32 %mul, 4}-> N23
N23 -{%div = sdiv i32 %0, %sub}-> N24
N24 -{store i32 %div, i32* %ret, align 4}-> N25
N25 -{ret void}-> N8
N8 -{Return edge from zero_division_012_bad to main}-> N6
N6 -{ret i32 0}-> N0
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N23
On edge  : N23 -{%div = sdiv i32 %0, %sub}-> N24
Message  : Divide By Zero
> Start from entry function: main, At N1 of Function main
> Entering function: zero_division_012_good, On N4 -> N28 (call zero_division_012_good)
> Leaving function: zero_division_012_good, On N27 -> N5 (Return edge from zero_division_012_good to main)
> Entering function: zero_division_012_bad, On N5 -> N9 (call zero_division_012_bad)
<Defect> : N23 -> N24: [%div = sdiv i32 %0, %sub]
N23 -> N24: [%div = sdiv i32 %0, %sub] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_10.c 10] zero_division_012_bad 		[N23 -{%div = sdiv i32 %0, %sub}-> N24]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [zero_division_013_func_001_good]
 +zero_division_013_func_001_good
SCC(1): [zero_division_013_good]
 +zero_division_013_good
SCC(1): [zero_division_013_func_001_bad]
 +zero_division_013_func_001_bad
SCC(1): [zero_division_013_bad]
 +zero_division_013_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_013_bad, zero_division_013_func_001_bad, zero_division_013_func_001_good, zero_division_013_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_013_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_013_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_013_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_013_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N47): +oo]
> [1/1] entry: main ()
N47 -{%retval = alloca i32, align 4}-> N49
N49 -{store i32 0, i32* %retval, align 4}-> N50
N50 -{call zero_division_013_good}-> N76
N76 -{%dividend = alloca i32, align 4}-> N78
N78 -{%ret = alloca i32, align 4}-> N80
N80 -{store i32 1000, i32* %dividend, align 4}-> N82
N82 -{%0 = load i32, i32* %dividend, align 4}-> N83
N83 -{call zero_division_013_func_001_good}-> N72
N72 -{ret i32 1}-> N71
N71 -{Return edge from zero_division_013_func_001_good to zero_division_013_good}-> N84
N84 -{%div = sdiv i32 %0, %call}-> N85
N85 -{store i32 %div, i32* %ret, align 4}-> N86
N86 -{ret void}-> N75
N75 -{Return edge from zero_division_013_good to main}-> N51
N51 -{call zero_division_013_bad}-> N55
N55 -{%dividend = alloca i32, align 4}-> N57
N57 -{%ret = alloca i32, align 4}-> N59
N59 -{store i32 1000, i32* %dividend, align 4}-> N61
N61 -{%0 = load i32, i32* %dividend, align 4}-> N62
N62 -{call zero_division_013_func_001_bad}-> N68
N68 -{ret i32 0}-> N67
N67 -{Return edge from zero_division_013_func_001_bad to zero_division_013_bad}-> N63
N63 -{%div = sdiv i32 %0, %call}-> N64
N64 -{store i32 %div, i32* %ret, align 4}-> N65
N65 -{ret void}-> N54
N54 -{Return edge from zero_division_013_bad to main}-> N52
N52 -{ret i32 0}-> N46
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N63
On edge  : N63 -{%div = sdiv i32 %0, %call}-> N64
Message  : Divide By Zero
> Start from entry function: main, At N47 of Function main
> Entering function: zero_division_013_good, On N50 -> N76 (call zero_division_013_good)
> Entering function: zero_division_013_func_001_good, On N83 -> N72 (call zero_division_013_func_001_good)
> Leaving function: zero_division_013_func_001_good, On N71 -> N84 (Return edge from zero_division_013_func_001_good to zero_division_013_good)
> Leaving function: zero_division_013_good, On N75 -> N51 (Return edge from zero_division_013_good to main)
> Entering function: zero_division_013_bad, On N51 -> N55 (call zero_division_013_bad)
> Entering function: zero_division_013_func_001_bad, On N62 -> N68 (call zero_division_013_func_001_bad)
> Leaving function: zero_division_013_func_001_bad, On N67 -> N63 (Return edge from zero_division_013_func_001_bad to zero_division_013_bad)
<Defect> : N63 -> N64: [%div = sdiv i32 %0, %call]
N63 -> N64: [%div = sdiv i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_11.c 14] zero_division_013_bad 		[N63 -{%div = sdiv i32 %0, %call}-> N64]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [zero_division_014_func_001]
 +zero_division_014_func_001
SCC(1): [zero_division_014_good]
 +zero_division_014_good
SCC(1): [zero_division_014_bad]
 +zero_division_014_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_014_bad, zero_division_014_func_001, zero_division_014_good, main]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_014_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_014_func_001
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_014_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.038s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N89): +oo]
> [1/1] entry: main ()
N89 -{%retval = alloca i32, align 4}-> N91
N91 -{store i32 0, i32* %retval, align 4}-> N92
N92 -{call zero_division_014_good}-> N118
N118 -{call zero_division_014_func_001}-> N102
N102 -{%divisor.addr = alloca i32, align 4}-> N104
N104 -{%dividend = alloca i32, align 4}-> N105
N105 -{%ret = alloca i32, align 4}-> N106
N106 -{store i32 %divisor, i32* %divisor.addr, align 4}-> N109
N109 -{store i32 1000, i32* %dividend, align 4}-> N111
N111 -{%0 = load i32, i32* %dividend, align 4}-> N112
N112 -{%1 = load i32, i32* %divisor.addr, align 4}-> N113
N113 -{%div = sdiv i32 %0, %1}-> N114
N114 -{store i32 %div, i32* %ret, align 4}-> N115
N115 -{ret void}-> N101
N101 -{Return edge from zero_division_014_func_001 to zero_division_014_good}-> N120
N120 -{ret void}-> N117
N117 -{Return edge from zero_division_014_good to main}-> N93
N93 -{call zero_division_014_bad}-> N97
N97 -{call zero_division_014_func_001}-> N102
N102 -{%divisor.addr = alloca i32, align 4}-> N104
N104 -{%dividend = alloca i32, align 4}-> N105
N105 -{%ret = alloca i32, align 4}-> N106
N106 -{store i32 %divisor, i32* %divisor.addr, align 4}-> N109
N109 -{store i32 1000, i32* %dividend, align 4}-> N111
N111 -{%0 = load i32, i32* %dividend, align 4}-> N112
N112 -{%1 = load i32, i32* %divisor.addr, align 4}-> N113
N113 -{%div = sdiv i32 %0, %1}-> N114
N114 -{store i32 %div, i32* %ret, align 4}-> N115
N115 -{ret void}-> N101
N101 -{Return edge from zero_division_014_func_001 to zero_division_014_bad}-> N99
N99 -{ret void}-> N96
N96 -{Return edge from zero_division_014_bad to main}-> N94
N94 -{ret i32 0}-> N88
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N113
On edge  : N113 -{%div = sdiv i32 %0, %1}-> N114
Message  : Divide By Zero
> Start from entry function: main, At N89 of Function main
> Entering function: zero_division_014_good, On N92 -> N118 (call zero_division_014_good)
> Entering function: zero_division_014_func_001, On N118 -> N102 (call zero_division_014_func_001)
> Leaving function: zero_division_014_func_001, On N101 -> N120 (Return edge from zero_division_014_func_001 to zero_division_014_good)
> Leaving function: zero_division_014_good, On N117 -> N93 (Return edge from zero_division_014_good to main)
> Entering function: zero_division_014_bad, On N93 -> N97 (call zero_division_014_bad)
> Entering function: zero_division_014_func_001, On N97 -> N102 (call zero_division_014_func_001)
<Defect> : N113 -> N114: [%div = sdiv i32 %0, %1]
N113 -> N114: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_12.c 9] zero_division_014_func_001 		[N113 -{%div = sdiv i32 %0, %1}-> N114]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_015_good]
 +zero_division_015_good
SCC(1): [zero_division_015_bad]
 +zero_division_015_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_015_bad, zero_division_015_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_015_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_015_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N123): +oo]
> [1/1] entry: main ()
N123 -{%retval = alloca i32, align 4}-> N125
N125 -{store i32 0, i32* %retval, align 4}-> N126
N126 -{call zero_division_015_good}-> N151
N151 -{%dividend = alloca i32, align 4}-> N153
N153 -{%divisor = alloca i32, align 4}-> N154
N154 -{%divisor1 = alloca i32, align 4}-> N155
N155 -{%ret = alloca i32, align 4}-> N157
N157 -{store i32 1000, i32* %dividend, align 4}-> N159
N159 -{store i32 1, i32* %divisor, align 4}-> N162
N162 -{%0 = load i32, i32* %divisor, align 4}-> N163
N163 -{store i32 %0, i32* %divisor1, align 4}-> N164
N164 -{%1 = load i32, i32* %dividend, align 4}-> N165
N165 -{%2 = load i32, i32* %divisor1, align 4}-> N166
N166 -{%div = sdiv i32 %1, %2}-> N167
N167 -{store i32 %div, i32* %ret, align 4}-> N168
N168 -{ret void}-> N150
N150 -{Return edge from zero_division_015_good to main}-> N127
N127 -{call zero_division_015_bad}-> N131
N131 -{%dividend = alloca i32, align 4}-> N133
N133 -{%divisor = alloca i32, align 4}-> N134
N134 -{%divisor1 = alloca i32, align 4}-> N135
N135 -{%ret = alloca i32, align 4}-> N137
N137 -{store i32 1000, i32* %dividend, align 4}-> N139
N139 -{store i32 0, i32* %divisor, align 4}-> N142
N142 -{%0 = load i32, i32* %divisor, align 4}-> N143
N143 -{store i32 %0, i32* %divisor1, align 4}-> N144
N144 -{%1 = load i32, i32* %dividend, align 4}-> N145
N145 -{%2 = load i32, i32* %divisor1, align 4}-> N146
N146 -{%div = sdiv i32 %1, %2}-> N147
N147 -{store i32 %div, i32* %ret, align 4}-> N148
N148 -{ret void}-> N130
N130 -{Return edge from zero_division_015_bad to main}-> N128
N128 -{ret i32 0}-> N122
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N146
On edge  : N146 -{%div = sdiv i32 %1, %2}-> N147
Message  : Divide By Zero
> Start from entry function: main, At N123 of Function main
> Entering function: zero_division_015_good, On N126 -> N151 (call zero_division_015_good)
> Leaving function: zero_division_015_good, On N150 -> N127 (Return edge from zero_division_015_good to main)
> Entering function: zero_division_015_bad, On N127 -> N131 (call zero_division_015_bad)
<Defect> : N146 -> N147: [%div = sdiv i32 %1, %2]
N146 -> N147: [%div = sdiv i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_13.c 12] zero_division_015_bad 		[N146 -{%div = sdiv i32 %1, %2}-> N147]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [zero_division_016_func_002_good]
 +zero_division_016_func_002_good
SCC(1): [zero_division_016_func_001_good]
 +zero_division_016_func_001_good
SCC(1): [zero_division_016_good]
 +zero_division_016_good
SCC(1): [zero_division_016_func_002_bad]
 +zero_division_016_func_002_bad
SCC(1): [zero_division_016_func_001_bad]
 +zero_division_016_func_001_bad
SCC(1): [zero_division_016_bad]
 +zero_division_016_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_016_func_002_good, zero_division_016_good, main, zero_division_016_bad, zero_division_016_func_001_bad, zero_division_016_func_001_good, zero_division_016_func_002_bad]
Loops     []
----
function: main
P+ = [H(zero_division_016_func_001_bad::call), H(zero_division_016_func_001_good::call)] 
P- = [] 
Point-To:
G(zero_division_016_gbl_divisor_bad) -> [H(zero_division_016_func_001_bad::call)]
G(zero_division_016_gbl_divisor_good) -> [H(zero_division_016_func_001_good::call)]
Ret-Value: R
----
function: zero_division_016_bad
P+ = [H(zero_division_016_func_001_bad::call)] 
P- = [] 
Point-To:
G(zero_division_016_gbl_divisor_bad) -> [H(zero_division_016_func_001_bad::call)]
Ret-Value: 
----
function: zero_division_016_func_001_bad
P+ = [H(zero_division_016_func_001_bad::call)] 
P- = [] 
Point-To:
G(zero_division_016_gbl_divisor_bad) -> [H(zero_division_016_func_001_bad::call)]
Ret-Value: 
----
function: zero_division_016_func_001_good
P+ = [H(zero_division_016_func_001_good::call)] 
P- = [] 
Point-To:
G(zero_division_016_gbl_divisor_good) -> [H(zero_division_016_func_001_good::call)]
Ret-Value: 
----
function: zero_division_016_func_002_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_016_func_002_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_016_good
P+ = [H(zero_division_016_func_001_good::call)] 
P- = [] 
Point-To:
G(zero_division_016_gbl_divisor_good) -> [H(zero_division_016_func_001_good::call)]
Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.043s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N171): +oo]
> [1/1] entry: main ()
N171 -{global: zero_division_016_gbl_divisor_bad}-> N261
N261 -{global: zero_division_016_gbl_divisor_good}-> N260
N260 -{%retval = alloca i32, align 4}-> N173
N173 -{store i32 0, i32* %retval, align 4}-> N174
N174 -{call zero_division_016_good}-> N237
N237 -{%dividend = alloca i32, align 4}-> N239
N239 -{%divisor1 = alloca i32, align 4}-> N240
N240 -{%divisor2 = alloca i32, align 4}-> N241
N241 -{%ret = alloca i32, align 4}-> N243
N243 -{store i32 1000, i32* %dividend, align 4}-> N247
N247 -{call zero_division_016_func_001_good}-> N212
N212 -{%call = call i8* @malloc(i64 4, i64 @malloc)}-> N214
N212 -{%call = call i8* @malloc(i64 4, i64 @malloc)}-> N214
N214 -{%0 = bitcast i8* %call to i32*}-> N215
N214 -{%0 = bitcast i8* %call to i32*}-> N215
N215 -{store i32* %0, i32** @zero_division_016_gbl_divisor_good, align 8}-> N216
N215 -{store i32* %0, i32** @zero_division_016_gbl_divisor_good, align 8}-> N216
N216 -{%1 = load i32*, i32** @zero_division_016_gbl_divisor_good, align 8}-> N217
N216 -{%1 = load i32*, i32** @zero_division_016_gbl_divisor_good, align 8}-> N217
N217 -{store i32 1, i32* %1, align 4}-> N218
N217 -{store i32 1, i32* %1, align 4}-> N218
N218 -{ret void}-> N211
N211 -{Return edge from zero_division_016_func_001_good to zero_division_016_good}-> N248
N248 -{call zero_division_016_func_002_good}-> N229
N229 -{%0 = load i32*, i32** @zero_division_016_gbl_divisor_good, align 8}-> N231
N231 -{%1 = load i32, i32* %0, align 4}-> N232
N232 -{%inc = add i32 %1, 1}-> N233
N233 -{store i32 %inc, i32* %0, align 4}-> N234
N234 -{ret void}-> N228
N228 -{Return edge from zero_division_016_func_002_good to zero_division_016_good}-> N249
N249 -{%0 = load i32*, i32** @zero_division_016_gbl_divisor_good, align 8}-> N250
N250 -{%1 = load i32, i32* %0, align 4}-> N251
N251 -{store i32 %1, i32* %divisor1, align 4}-> N252
N252 -{%2 = load i32, i32* %divisor1, align 4}-> N253
N253 -{store i32 %2, i32* %divisor2, align 4}-> N254
N254 -{%3 = load i32, i32* %dividend, align 4}-> N255
N255 -{%4 = load i32, i32* %divisor2, align 4}-> N256
N256 -{%div = sdiv i32 %3, %4}-> N257
N257 -{store i32 %div, i32* %ret, align 4}-> N258
N258 -{ret void}-> N236
N236 -{Return edge from zero_division_016_good to main}-> N175
N175 -{call zero_division_016_bad}-> N179
N179 -{%dividend = alloca i32, align 4}-> N181
N181 -{%divisor1 = alloca i32, align 4}-> N182
N182 -{%divisor2 = alloca i32, align 4}-> N183
N183 -{%ret = alloca i32, align 4}-> N185
N185 -{store i32 1000, i32* %dividend, align 4}-> N189
N189 -{call zero_division_016_func_001_bad}-> N203
N203 -{%call = call i8* @malloc(i64 4, i64 @malloc)}-> N205
N203 -{%call = call i8* @malloc(i64 4, i64 @malloc)}-> N205
N205 -{%0 = bitcast i8* %call to i32*}-> N206
N205 -{%0 = bitcast i8* %call to i32*}-> N206
N206 -{store i32* %0, i32** @zero_division_016_gbl_divisor_bad, align 8}-> N207
N206 -{store i32* %0, i32** @zero_division_016_gbl_divisor_bad, align 8}-> N207
N207 -{%1 = load i32*, i32** @zero_division_016_gbl_divisor_bad, align 8}-> N208
N207 -{%1 = load i32*, i32** @zero_division_016_gbl_divisor_bad, align 8}-> N208
N208 -{store i32 -1, i32* %1, align 4}-> N209
N208 -{store i32 -1, i32* %1, align 4}-> N209
N209 -{ret void}-> N202
N202 -{Return edge from zero_division_016_func_001_bad to zero_division_016_bad}-> N190
N190 -{call zero_division_016_func_002_bad}-> N221
N221 -{%0 = load i32*, i32** @zero_division_016_gbl_divisor_bad, align 8}-> N223
N223 -{%1 = load i32, i32* %0, align 4}-> N224
N224 -{%inc = add i32 %1, 1}-> N225
N225 -{store i32 %inc, i32* %0, align 4}-> N226
N226 -{ret void}-> N220
N220 -{Return edge from zero_division_016_func_002_bad to zero_division_016_bad}-> N191
N191 -{%0 = load i32*, i32** @zero_division_016_gbl_divisor_bad, align 8}-> N192
N192 -{%1 = load i32, i32* %0, align 4}-> N193
N193 -{store i32 %1, i32* %divisor1, align 4}-> N194
N194 -{%2 = load i32, i32* %divisor1, align 4}-> N195
N195 -{store i32 %2, i32* %divisor2, align 4}-> N196
N196 -{%3 = load i32, i32* %dividend, align 4}-> N197
N197 -{%4 = load i32, i32* %divisor2, align 4}-> N198
N198 -{%div = sdiv i32 %3, %4}-> N199
N199 -{store i32 %div, i32* %ret, align 4}-> N200
N200 -{ret void}-> N178
N178 -{Return edge from zero_division_016_bad to main}-> N176
N176 -{ret i32 0}-> N170
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N176
On edge  : N176 -{ret i32 0}-> N170
Message  : the heap object @H(zero_division_016_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N171 of Function main
> Entering function: zero_division_016_good, On N174 -> N237 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N247 -> N212 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N211 -> N248 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N248 -> N229 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N228 -> N249 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N236 -> N175 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N175 -> N179 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N189 -> N203 (call zero_division_016_func_001_bad)
> Leaving function: zero_division_016_func_001_bad, On N202 -> N190 (Return edge from zero_division_016_func_001_bad to zero_division_016_bad)
> Entering function: zero_division_016_func_002_bad, On N190 -> N221 (call zero_division_016_func_002_bad)
> Leaving function: zero_division_016_func_002_bad, On N220 -> N191 (Return edge from zero_division_016_func_002_bad to zero_division_016_bad)
> Leaving function: zero_division_016_bad, On N178 -> N176 (Return edge from zero_division_016_bad to main)
<Defect> : N176 -> N170: [ret i32 0]
N176 -> N170: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N176
On edge  : N176 -{ret i32 0}-> N170
Message  : the heap object @H(zero_division_016_func_001_good::call) is not referenced any more
> Start from entry function: main, At N171 of Function main
> Entering function: zero_division_016_good, On N174 -> N237 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N247 -> N212 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N211 -> N248 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N248 -> N229 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N228 -> N249 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N236 -> N175 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N175 -> N179 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N189 -> N203 (call zero_division_016_func_001_bad)
> Leaving function: zero_division_016_func_001_bad, On N202 -> N190 (Return edge from zero_division_016_func_001_bad to zero_division_016_bad)
> Entering function: zero_division_016_func_002_bad, On N190 -> N221 (call zero_division_016_func_002_bad)
> Leaving function: zero_division_016_func_002_bad, On N220 -> N191 (Return edge from zero_division_016_func_002_bad to zero_division_016_bad)
> Leaving function: zero_division_016_bad, On N178 -> N176 (Return edge from zero_division_016_bad to main)
<Defect> : N176 -> N170: [ret i32 0]
N176 -> N170: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Divide By Zero
At node  : N198
On edge  : N198 -{%div = sdiv i32 %3, %4}-> N199
Message  : Divide By Zero
> Start from entry function: main, At N171 of Function main
> Entering function: zero_division_016_good, On N174 -> N237 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N247 -> N212 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N211 -> N248 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N248 -> N229 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N228 -> N249 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N236 -> N175 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N175 -> N179 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N189 -> N203 (call zero_division_016_func_001_bad)
> Leaving function: zero_division_016_func_001_bad, On N202 -> N190 (Return edge from zero_division_016_func_001_bad to zero_division_016_bad)
> Entering function: zero_division_016_func_002_bad, On N190 -> N221 (call zero_division_016_func_002_bad)
> Leaving function: zero_division_016_func_002_bad, On N220 -> N191 (Return edge from zero_division_016_func_002_bad to zero_division_016_bad)
<Defect> : N198 -> N199: [%div = sdiv i32 %3, %4]
N198 -> N199: [%div = sdiv i32 %3, %4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N217
On edge  : N217 -{store i32 1, i32* %1, align 4}-> N218
Message  : null pointer dereference
> Start from entry function: main, At N171 of Function main
> Entering function: zero_division_016_good, On N174 -> N237 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N247 -> N212 (call zero_division_016_func_001_good)
<Defect> : N217 -> N218: [store i32 1, i32* %1, align 4]
N217 -> N218: [store i32 1, i32* %1, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N208
On edge  : N208 -{store i32 -1, i32* %1, align 4}-> N209
Message  : null pointer dereference
> Start from entry function: main, At N171 of Function main
> Entering function: zero_division_016_good, On N174 -> N237 (call zero_division_016_good)
> Entering function: zero_division_016_func_001_good, On N247 -> N212 (call zero_division_016_func_001_good)
> Leaving function: zero_division_016_func_001_good, On N211 -> N248 (Return edge from zero_division_016_func_001_good to zero_division_016_good)
> Entering function: zero_division_016_func_002_good, On N248 -> N229 (call zero_division_016_func_002_good)
> Leaving function: zero_division_016_func_002_good, On N228 -> N249 (Return edge from zero_division_016_func_002_good to zero_division_016_good)
> Leaving function: zero_division_016_good, On N236 -> N175 (Return edge from zero_division_016_good to main)
> Entering function: zero_division_016_bad, On N175 -> N179 (call zero_division_016_bad)
> Entering function: zero_division_016_func_001_bad, On N189 -> N203 (call zero_division_016_func_001_bad)
<Defect> : N208 -> N209: [store i32 -1, i32* %1, align 4]
N208 -> N209: [store i32 -1, i32* %1, align 4] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[./369_zero_division_14.c 66] main 		[N176 -{ret i32 0}-> N170]	(the heap object @H(zero_division_016_func_001_bad::call) is not referenced any more)
	[./369_zero_division_14.c 66] main 		[N176 -{ret i32 0}-> N170]	(the heap object @H(zero_division_016_func_001_good::call) is not referenced any more)

CWE_369(Divide By Zero): 1
	[./369_zero_division_14.c 30] zero_division_016_bad 		[N198 -{%div = sdiv i32 %3, %4}-> N199]	(Divide By Zero)

CWE_476(Null Pointer Dereference): 2
	[./369_zero_division_14.c 42] zero_division_016_func_001_good 		[N217 -{store i32 1, i32* %1, align 4}-> N218]	(null pointer dereference)
	[./369_zero_division_14.c 12] zero_division_016_func_001_bad 		[N208 -{store i32 -1, i32* %1, align 4}-> N209]	(null pointer dereference)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_005_good]
 +zero_division_005_good
SCC(1): [zero_division_005_bad]
 +zero_division_005_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_005_good, main, zero_division_005_bad]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_005_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_005_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.033s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N263): +oo]
> [1/1] entry: main ()
N263 -{global: zero_division_005_bad.divisors}-> N307
N307 -{global: zero_division_005_good.divisors}-> N306
N306 -{%retval = alloca i32, align 4}-> N265
N265 -{store i32 0, i32* %retval, align 4}-> N266
N266 -{call zero_division_005_good}-> N289
N289 -{%dividend = alloca i32, align 4}-> N291
N291 -{%divisors = alloca [5 x i32], align 16}-> N292
N292 -{%ret = alloca i32, align 4}-> N294
N294 -{store i32 1000, i32* %dividend, align 4}-> N296
N296 -{%0 = bitcast [5 x i32]* %divisors to i8*}-> N297
N297 -{call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([5 x i32]* @zero_division_005_good.divisors to i8*), i8* 20, i8* 16, i8* false, i8* @llvm.memcpy.p0i8.p0i8.i64)}-> N299
N299 -{%1 = load i32, i32* %dividend, align 4}-> N300
N300 -{%arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %divisors, i64 0, i64 2}-> N301
N301 -{%2 = load i32, i32* %arrayidx, align 8}-> N302
N302 -{%div = sdiv i32 %1, %2}-> N303
N303 -{store i32 %div, i32* %ret, align 4}-> N304
N304 -{ret void}-> N288
N288 -{Return edge from zero_division_005_good to main}-> N267
N267 -{call zero_division_005_bad}-> N271
N271 -{%dividend = alloca i32, align 4}-> N273
N273 -{%divisors = alloca [5 x i32], align 16}-> N274
N274 -{%ret = alloca i32, align 4}-> N276
N276 -{store i32 1000, i32* %dividend, align 4}-> N278
N278 -{%0 = bitcast [5 x i32]* %divisors to i8*}-> N279
N279 -{call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([5 x i32]* @zero_division_005_bad.divisors to i8*), i8* 20, i8* 16, i8* false, i8* @llvm.memcpy.p0i8.p0i8.i64)}-> N281
N281 -{%1 = load i32, i32* %dividend, align 4}-> N282
N282 -{%arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %divisors, i64 0, i64 2}-> N283
N283 -{%2 = load i32, i32* %arrayidx, align 8}-> N284
N284 -{%div = sdiv i32 %1, %2}-> N285
N285 -{store i32 %div, i32* %ret, align 4}-> N286
N286 -{ret void}-> N270
N270 -{Return edge from zero_division_005_bad to main}-> N268
N268 -{ret i32 0}-> N262
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N284
On edge  : N284 -{%div = sdiv i32 %1, %2}-> N285
Message  : Divide By Zero
> Start from entry function: main, At N263 of Function main
> Entering function: zero_division_005_good, On N266 -> N289 (call zero_division_005_good)
> Leaving function: zero_division_005_good, On N288 -> N267 (Return edge from zero_division_005_good to main)
> Entering function: zero_division_005_bad, On N267 -> N271 (call zero_division_005_bad)
<Defect> : N284 -> N285: [%div = sdiv i32 %1, %2]
N284 -> N285: [%div = sdiv i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_15.c 14] zero_division_005_bad 		[N284 -{%div = sdiv i32 %1, %2}-> N285]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_001_good]
 +zero_division_001_good
SCC(1): [zero_division_001_bad]
 +zero_division_001_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_001_bad, zero_division_001_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N309): +oo]
> [1/1] entry: main ()
N309 -{%retval = alloca i32, align 4}-> N311
N311 -{store i32 0, i32* %retval, align 4}-> N312
N312 -{call zero_division_001_good}-> N329
N329 -{%dividend = alloca i32, align 4}-> N331
N331 -{%ret = alloca i32, align 4}-> N333
N333 -{store i32 1000, i32* %dividend, align 4}-> N335
N335 -{%0 = load i32, i32* %dividend, align 4}-> N336
N336 -{%div = sdiv i32 %0, 1}-> N337
N337 -{store i32 %div, i32* %ret, align 4}-> N338
N338 -{ret void}-> N328
N328 -{Return edge from zero_division_001_good to main}-> N313
N313 -{call zero_division_001_bad}-> N317
N317 -{%dividend = alloca i32, align 4}-> N319
N319 -{%ret = alloca i32, align 4}-> N321
N321 -{store i32 1000, i32* %dividend, align 4}-> N323
N323 -{%0 = load i32, i32* %dividend, align 4}-> N324
N324 -{%div = sdiv i32 %0, 0}-> N325
N325 -{store i32 %div, i32* %ret, align 4}-> N326
N326 -{ret void}-> N316
N316 -{Return edge from zero_division_001_bad to main}-> N314
N314 -{ret i32 0}-> N308
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N324
On edge  : N324 -{%div = sdiv i32 %0, 0}-> N325
Message  : Divide By Zero
> Start from entry function: main, At N309 of Function main
> Entering function: zero_division_001_good, On N312 -> N329 (call zero_division_001_good)
> Leaving function: zero_division_001_good, On N328 -> N313 (Return edge from zero_division_001_good to main)
> Entering function: zero_division_001_bad, On N313 -> N317 (call zero_division_001_bad)
<Defect> : N324 -> N325: [%div = sdiv i32 %0, 0]
N324 -> N325: [%div = sdiv i32 %0, 0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_1.c 9] zero_division_001_bad 		[N324 -{%div = sdiv i32 %0, 0}-> N325]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_002_good]
 +zero_division_002_good
SCC(1): [zero_division_002_bad]
 +zero_division_002_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_002_good, main, zero_division_002_bad]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_002_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_002_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N341): +oo]
> [1/1] entry: main ()
N341 -{%retval = alloca i32, align 4}-> N343
N343 -{store i32 0, i32* %retval, align 4}-> N344
N344 -{call zero_division_002_good}-> N363
N363 -{%dividend = alloca i32, align 4}-> N365
N365 -{%ret = alloca i32, align 4}-> N367
N367 -{store i32 1000, i32* %dividend, align 4}-> N369
N369 -{%0 = load i32, i32* %dividend, align 4}-> N370
N370 -{%div = sdiv i32 %0, 1}-> N371
N371 -{store i32 %div, i32* %dividend, align 4}-> N372
N372 -{%1 = load i32, i32* %dividend, align 4}-> N373
N373 -{store i32 %1, i32* %ret, align 4}-> N374
N374 -{ret void}-> N362
N362 -{Return edge from zero_division_002_good to main}-> N345
N345 -{call zero_division_002_bad}-> N349
N349 -{%dividend = alloca i32, align 4}-> N351
N351 -{%ret = alloca i32, align 4}-> N353
N353 -{store i32 1000, i32* %dividend, align 4}-> N355
N355 -{%0 = load i32, i32* %dividend, align 4}-> N356
N356 -{%div = sdiv i32 %0, 0}-> N357
N357 -{store i32 %div, i32* %dividend, align 4}-> N358
N358 -{%1 = load i32, i32* %dividend, align 4}-> N359
N359 -{store i32 %1, i32* %ret, align 4}-> N360
N360 -{ret void}-> N348
N348 -{Return edge from zero_division_002_bad to main}-> N346
N346 -{ret i32 0}-> N340
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N356
On edge  : N356 -{%div = sdiv i32 %0, 0}-> N357
Message  : Divide By Zero
> Start from entry function: main, At N341 of Function main
> Entering function: zero_division_002_good, On N344 -> N363 (call zero_division_002_good)
> Leaving function: zero_division_002_good, On N362 -> N345 (Return edge from zero_division_002_good to main)
> Entering function: zero_division_002_bad, On N345 -> N349 (call zero_division_002_bad)
<Defect> : N356 -> N357: [%div = sdiv i32 %0, 0]
N356 -> N357: [%div = sdiv i32 %0, 0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_2.c 9] zero_division_002_bad 		[N356 -{%div = sdiv i32 %0, 0}-> N357]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_003_good]
 +zero_division_003_good
SCC(1): [zero_division_003_bad]
 +zero_division_003_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_003_bad, zero_division_003_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_003_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_003_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N377): +oo]
> [1/1] entry: main ()
N377 -{%retval = alloca i32, align 4}-> N379
N379 -{store i32 0, i32* %retval, align 4}-> N380
N380 -{call zero_division_003_good}-> N397
N397 -{%dividend = alloca i32, align 4}-> N399
N399 -{%ret = alloca i32, align 4}-> N401
N401 -{store i32 1000, i32* %dividend, align 4}-> N403
N403 -{%0 = load i32, i32* %dividend, align 4}-> N404
N404 -{%rem = srem i32 %0, 1}-> N405
N405 -{store i32 %rem, i32* %ret, align 4}-> N406
N406 -{ret void}-> N396
N396 -{Return edge from zero_division_003_good to main}-> N381
N381 -{call zero_division_003_bad}-> N385
N385 -{%dividend = alloca i32, align 4}-> N387
N387 -{%ret = alloca i32, align 4}-> N389
N389 -{store i32 1000, i32* %dividend, align 4}-> N391
N391 -{%0 = load i32, i32* %dividend, align 4}-> N392
N392 -{%rem = srem i32 %0, 0}-> N393
N393 -{store i32 %rem, i32* %ret, align 4}-> N394
N394 -{ret void}-> N384
N384 -{Return edge from zero_division_003_bad to main}-> N382
N382 -{ret i32 0}-> N376
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N392
On edge  : N392 -{%rem = srem i32 %0, 0}-> N393
Message  : Divide By Zero
> Start from entry function: main, At N377 of Function main
> Entering function: zero_division_003_good, On N380 -> N397 (call zero_division_003_good)
> Leaving function: zero_division_003_good, On N396 -> N381 (Return edge from zero_division_003_good to main)
> Entering function: zero_division_003_bad, On N381 -> N385 (call zero_division_003_bad)
<Defect> : N392 -> N393: [%rem = srem i32 %0, 0]
N392 -> N393: [%rem = srem i32 %0, 0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_3.c 9] zero_division_003_bad 		[N392 -{%rem = srem i32 %0, 0}-> N393]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [zero_division_004_func_001_good]
 +zero_division_004_func_001_good
SCC(1): [zero_division_004_good]
 +zero_division_004_good
SCC(1): [zero_division_004_func_001_bad]
 +zero_division_004_func_001_bad
SCC(1): [zero_division_004_bad]
 +zero_division_004_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_004_bad, zero_division_004_func_001_bad, zero_division_004_func_001_good, zero_division_004_good, main]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_004_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_004_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_004_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_004_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N409): +oo]
> [1/1] entry: main ()
N409 -{global: zero_division_004_dividend_gbl}-> N450
N450 -{global: zero_division_004_divisor_gbl_good}-> N449
N449 -{global: zero_division_004_divisor_gbl_bad}-> N448
N448 -{%retval = alloca i32, align 4}-> N411
N411 -{store i32 0, i32* %retval, align 4}-> N412
N412 -{call zero_division_004_good}-> N441
N441 -{%0 = load i32, i32* @zero_division_004_divisor_gbl_good, align 4}-> N443
N443 -{%dec = add i32 %0, -1}-> N444
N444 -{store i32 %dec, i32* @zero_division_004_divisor_gbl_good, align 4}-> N445
N445 -{call zero_division_004_func_001_good}-> N433
N433 -{%0 = load i32, i32* @zero_division_004_divisor_gbl_good, align 4}-> N435
N435 -{%1 = load i32, i32* @zero_division_004_dividend_gbl, align 4}-> N436
N436 -{%rem = srem i32 %1, %0}-> N437
N437 -{store i32 %rem, i32* @zero_division_004_dividend_gbl, align 4}-> N438
N438 -{ret void}-> N432
N432 -{Return edge from zero_division_004_func_001_good to zero_division_004_good}-> N446
N446 -{ret void}-> N440
N440 -{Return edge from zero_division_004_good to main}-> N413
N413 -{call zero_division_004_bad}-> N417
N417 -{%0 = load i32, i32* @zero_division_004_divisor_gbl_bad, align 4}-> N419
N419 -{%dec = add i32 %0, -1}-> N420
N420 -{store i32 %dec, i32* @zero_division_004_divisor_gbl_bad, align 4}-> N421
N421 -{call zero_division_004_func_001_bad}-> N425
N425 -{%0 = load i32, i32* @zero_division_004_divisor_gbl_bad, align 4}-> N427
N427 -{%1 = load i32, i32* @zero_division_004_dividend_gbl, align 4}-> N428
N428 -{%rem = srem i32 %1, %0}-> N429
N429 -{store i32 %rem, i32* @zero_division_004_dividend_gbl, align 4}-> N430
N430 -{ret void}-> N424
N424 -{Return edge from zero_division_004_func_001_bad to zero_division_004_bad}-> N422
N422 -{ret void}-> N416
N416 -{Return edge from zero_division_004_bad to main}-> N414
N414 -{ret i32 0}-> N408
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N428
On edge  : N428 -{%rem = srem i32 %1, %0}-> N429
Message  : Divide By Zero
> Start from entry function: main, At N409 of Function main
> Entering function: zero_division_004_good, On N412 -> N441 (call zero_division_004_good)
> Entering function: zero_division_004_func_001_good, On N445 -> N433 (call zero_division_004_func_001_good)
> Leaving function: zero_division_004_func_001_good, On N432 -> N446 (Return edge from zero_division_004_func_001_good to zero_division_004_good)
> Leaving function: zero_division_004_good, On N440 -> N413 (Return edge from zero_division_004_good to main)
> Entering function: zero_division_004_bad, On N413 -> N417 (call zero_division_004_bad)
> Entering function: zero_division_004_func_001_bad, On N421 -> N425 (call zero_division_004_func_001_bad)
<Defect> : N428 -> N429: [%rem = srem i32 %1, %0]
N428 -> N429: [%rem = srem i32 %1, %0] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_4.c 9] zero_division_004_func_001_bad 		[N428 -{%rem = srem i32 %1, %0}-> N429]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_006_bad]
 +zero_division_006_bad
SCC(1): [zero_division_006_good]
 +zero_division_006_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_006_bad, zero_division_006_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_006_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_006_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N452): +oo]
> [1/1] entry: main ()
N452 -{global: zero_division_006_gbl_divisor_bad}-> N494
N494 -{global: zero_division_006_gbl_divisor_good}-> N493
N493 -{%retval = alloca i32, align 4}-> N454
N454 -{store i32 0, i32* %retval, align 4}-> N455
N455 -{call zero_division_006_good}-> N477
N477 -{%dividend = alloca i32, align 4}-> N479
N479 -{%p = alloca i32*, align 8}-> N480
N480 -{%ret = alloca i32, align 4}-> N482
N482 -{store i32 1000, i32* %dividend, align 4}-> N485
N485 -{store i32* @zero_division_006_gbl_divisor_good, i32** %p, align 8}-> N486
N486 -{%0 = load i32, i32* %dividend, align 4}-> N487
N487 -{%1 = load i32*, i32** %p, align 8}-> N488
N488 -{%2 = load i32, i32* %1, align 4}-> N489
N489 -{%div = sdiv i32 %0, %2}-> N490
N490 -{store i32 %div, i32* %ret, align 4}-> N491
N491 -{ret void}-> N476
N476 -{Return edge from zero_division_006_good to main}-> N456
N456 -{call zero_division_006_bad}-> N460
N460 -{%dividend = alloca i32, align 4}-> N462
N462 -{%p = alloca i32*, align 8}-> N463
N463 -{%ret = alloca i32, align 4}-> N465
N465 -{store i32 1000, i32* %dividend, align 4}-> N468
N468 -{store i32* @zero_division_006_gbl_divisor_bad, i32** %p, align 8}-> N469
N469 -{%0 = load i32, i32* %dividend, align 4}-> N470
N470 -{%1 = load i32*, i32** %p, align 8}-> N471
N471 -{%2 = load i32, i32* %1, align 4}-> N472
N472 -{%div = sdiv i32 %0, %2}-> N473
N473 -{store i32 %div, i32* %ret, align 4}-> N474
N474 -{ret void}-> N459
N459 -{Return edge from zero_division_006_bad to main}-> N457
N457 -{ret i32 0}-> N451
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N472
On edge  : N472 -{%div = sdiv i32 %0, %2}-> N473
Message  : Divide By Zero
> Start from entry function: main, At N452 of Function main
> Entering function: zero_division_006_good, On N455 -> N477 (call zero_division_006_good)
> Leaving function: zero_division_006_good, On N476 -> N456 (Return edge from zero_division_006_good to main)
> Entering function: zero_division_006_bad, On N456 -> N460 (call zero_division_006_bad)
<Defect> : N472 -> N473: [%div = sdiv i32 %0, %2]
N472 -> N473: [%div = sdiv i32 %0, %2] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_5.c 13] zero_division_006_bad 		[N472 -{%div = sdiv i32 %0, %2}-> N473]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [zero_division_007_func_001_good]
 +zero_division_007_func_001_good
SCC(1): [zero_division_007_good]
 +zero_division_007_good
SCC(1): [zero_division_007_func_001_bad]
 +zero_division_007_func_001_bad
SCC(1): [zero_division_007_bad]
 +zero_division_007_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_007_bad, zero_division_007_func_001_bad, zero_division_007_func_001_good, zero_division_007_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_007_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_007_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_007_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_007_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N496): +oo]
> [1/1] entry: main ()
N496 -{global: zero_division_007_s_gbl_bad}-> N542
N542 -{global: zero_division_007_s_gbl_good}-> N541
N541 -{%retval = alloca i32, align 4}-> N498
N498 -{store i32 0, i32* %retval, align 4}-> N499
N499 -{call zero_division_007_good}-> N528
N528 -{%dividend = alloca i32, align 4}-> N530
N530 -{%ret = alloca i32, align 4}-> N532
N532 -{store i32 1000, i32* %dividend, align 4}-> N534
N534 -{call zero_division_007_func_001_good}-> N523
N523 -{store i32 1, i32* getelementptr inbounds (%struct.zero_division_007_s_001, %struct.zero_division_007_s_001* @zero_division_007_s_gbl_good, i32 0, i32 2), align 4}-> N525
N525 -{ret void}-> N522
N522 -{Return edge from zero_division_007_func_001_good to zero_division_007_good}-> N535
N535 -{%0 = load i32, i32* %dividend, align 4}-> N536
N536 -{%1 = load i32, i32* getelementptr inbounds (%struct.zero_division_007_s_001, %struct.zero_division_007_s_001* @zero_division_007_s_gbl_good, i32 0, i32 2), align 4}-> N537
N537 -{%div = sdiv i32 %0, %1}-> N538
N538 -{store i32 %div, i32* %ret, align 4}-> N539
N539 -{ret void}-> N527
N527 -{Return edge from zero_division_007_good to main}-> N500
N500 -{call zero_division_007_bad}-> N504
N504 -{%dividend = alloca i32, align 4}-> N506
N506 -{%ret = alloca i32, align 4}-> N508
N508 -{store i32 1000, i32* %dividend, align 4}-> N510
N510 -{call zero_division_007_func_001_bad}-> N518
N518 -{store i32 0, i32* getelementptr inbounds (%struct.zero_division_007_s_001, %struct.zero_division_007_s_001* @zero_division_007_s_gbl_bad, i32 0, i32 2), align 4}-> N520
N520 -{ret void}-> N517
N517 -{Return edge from zero_division_007_func_001_bad to zero_division_007_bad}-> N511
N511 -{%0 = load i32, i32* %dividend, align 4}-> N512
N512 -{%1 = load i32, i32* getelementptr inbounds (%struct.zero_division_007_s_001, %struct.zero_division_007_s_001* @zero_division_007_s_gbl_bad, i32 0, i32 2), align 4}-> N513
N513 -{%div = sdiv i32 %0, %1}-> N514
N514 -{store i32 %div, i32* %ret, align 4}-> N515
N515 -{ret void}-> N503
N503 -{Return edge from zero_division_007_bad to main}-> N501
N501 -{ret i32 0}-> N495
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N513
On edge  : N513 -{%div = sdiv i32 %0, %1}-> N514
Message  : Divide By Zero
> Start from entry function: main, At N496 of Function main
> Entering function: zero_division_007_good, On N499 -> N528 (call zero_division_007_good)
> Entering function: zero_division_007_func_001_good, On N534 -> N523 (call zero_division_007_func_001_good)
> Leaving function: zero_division_007_func_001_good, On N522 -> N535 (Return edge from zero_division_007_func_001_good to zero_division_007_good)
> Leaving function: zero_division_007_good, On N527 -> N500 (Return edge from zero_division_007_good to main)
> Entering function: zero_division_007_bad, On N500 -> N504 (call zero_division_007_bad)
> Entering function: zero_division_007_func_001_bad, On N510 -> N518 (call zero_division_007_func_001_bad)
> Leaving function: zero_division_007_func_001_bad, On N517 -> N511 (Return edge from zero_division_007_func_001_bad to zero_division_007_bad)
<Defect> : N513 -> N514: [%div = sdiv i32 %0, %1]
N513 -> N514: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_6.c 23] zero_division_007_bad 		[N513 -{%div = sdiv i32 %0, %1}-> N514]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_009_good]
 +zero_division_009_good
SCC(1): [zero_division_009_bad]
 +zero_division_009_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_009_bad, zero_division_009_good, main]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_009_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_009_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N544): +oo]
> [1/1] entry: main ()
N544 -{%retval = alloca i32, align 4}-> N546
N546 -{store i32 0, i32* %retval, align 4}-> N547
N547 -{call zero_division_009_good}-> N568
N568 -{%dividend = alloca i32, align 4}-> N570
N570 -{%divisor = alloca i32, align 4}-> N571
N571 -{%ret = alloca i32, align 4}-> N573
N573 -{store i32 1000, i32* %dividend, align 4}-> N575
N575 -{store i32 1, i32* %divisor, align 4}-> N577
N577 -{%0 = load i32, i32* %dividend, align 4}-> N578
N578 -{%1 = load i32, i32* %divisor, align 4}-> N579
N579 -{%div = sdiv i32 %0, %1}-> N580
N580 -{store i32 %div, i32* %ret, align 4}-> N581
N581 -{ret void}-> N567
N567 -{Return edge from zero_division_009_good to main}-> N548
N548 -{call zero_division_009_bad}-> N552
N552 -{%dividend = alloca i32, align 4}-> N554
N554 -{%divisor = alloca i32, align 4}-> N555
N555 -{%ret = alloca i32, align 4}-> N557
N557 -{store i32 1000, i32* %dividend, align 4}-> N559
N559 -{store i32 0, i32* %divisor, align 4}-> N561
N561 -{%0 = load i32, i32* %dividend, align 4}-> N562
N562 -{%1 = load i32, i32* %divisor, align 4}-> N563
N563 -{%div = sdiv i32 %0, %1}-> N564
N564 -{store i32 %div, i32* %ret, align 4}-> N565
N565 -{ret void}-> N551
N551 -{Return edge from zero_division_009_bad to main}-> N549
N549 -{ret i32 0}-> N543
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N563
On edge  : N563 -{%div = sdiv i32 %0, %1}-> N564
Message  : Divide By Zero
> Start from entry function: main, At N544 of Function main
> Entering function: zero_division_009_good, On N547 -> N568 (call zero_division_009_good)
> Leaving function: zero_division_009_good, On N567 -> N548 (Return edge from zero_division_009_good to main)
> Entering function: zero_division_009_bad, On N548 -> N552 (call zero_division_009_bad)
<Defect> : N563 -> N564: [%div = sdiv i32 %0, %1]
N563 -> N564: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_7.c 10] zero_division_009_bad 		[N563 -{%div = sdiv i32 %0, %1}-> N564]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_010_bad]
 +zero_division_010_bad
SCC(1): [zero_division_010_good]
 +zero_division_010_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [zero_division_010_good, main, zero_division_010_bad]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_010_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_010_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N584): +oo]
> [1/1] entry: main ()
N584 -{%retval = alloca i32, align 4}-> N586
N586 -{store i32 0, i32* %retval, align 4}-> N587
N587 -{call zero_division_010_good}-> N609
N609 -{%dividend = alloca i32, align 4}-> N611
N611 -{%divisor = alloca i32, align 4}-> N612
N612 -{%ret = alloca i32, align 4}-> N614
N614 -{store i32 1000, i32* %dividend, align 4}-> N617
N617 -{%call = call i32 @rand(i32 ()* @rand)}-> N618
N618 -{store i32 %call, i32* %divisor, align 4}-> N619
N619 -{%0 = load i32, i32* %divisor, align 4}-> N620
N620 -{%cmp = icmp ne i32 %0, 0}-> N621
N621 -{[%cmp = icmp ne i32 %0, 0]}-> N629
N621 -{[!(%cmp = icmp ne i32 %0, 0)]}-> N627
N621 -{[%cmp = icmp ne i32 %0, 0]}-> N629
N621 -{[!(%cmp = icmp ne i32 %0, 0)]}-> N627
N629 -{%1 = load i32, i32* %dividend, align 4}-> N623
N623 -{%2 = load i32, i32* %divisor, align 4}-> N624
N624 -{%div = sdiv i32 %1, %2}-> N625
N625 -{store i32 %div, i32* %ret, align 4}-> N627
N627 -{ret void}-> N608
N627 -{ret void}-> N608
N608 -{Return edge from zero_division_010_good to main}-> N588
N608 -{Return edge from zero_division_010_good to main}-> N588
N588 -{call zero_division_010_bad}-> N592
N592 -{%dividend = alloca i32, align 4}-> N594
N594 -{%divisor = alloca i32, align 4}-> N595
N595 -{%ret = alloca i32, align 4}-> N597
N597 -{store i32 1000, i32* %dividend, align 4}-> N600
N600 -{%call = call i32 @rand(i32 ()* @rand)}-> N601
N601 -{store i32 %call, i32* %divisor, align 4}-> N602
N602 -{%0 = load i32, i32* %dividend, align 4}-> N603
N603 -{%1 = load i32, i32* %divisor, align 4}-> N604
N604 -{%div = sdiv i32 %0, %1}-> N605
N605 -{store i32 %div, i32* %ret, align 4}-> N606
N606 -{ret void}-> N591
N591 -{Return edge from zero_division_010_bad to main}-> N589
N589 -{ret i32 0}-> N583
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N604
On edge  : N604 -{%div = sdiv i32 %0, %1}-> N605
Message  : Divide By Zero
> Start from entry function: main, At N584 of Function main
> Entering function: zero_division_010_good, On N587 -> N609 (call zero_division_010_good)
> takes the false branch, At N621 of Function zero_division_010_good
> Leaving function: zero_division_010_good, On N608 -> N588 (Return edge from zero_division_010_good to main)
> Entering function: zero_division_010_bad, On N588 -> N592 (call zero_division_010_bad)
<Defect> : N604 -> N605: [%div = sdiv i32 %0, %1]
N604 -> N605: [%div = sdiv i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_8.c 15] zero_division_010_bad 		[N604 -{%div = sdiv i32 %0, %1}-> N605]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/369/369_zero_division_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [zero_division_011_good]
 +zero_division_011_good
SCC(1): [zero_division_011_bad]
 +zero_division_011_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, zero_division_011_bad, zero_division_011_good]
Loops     []
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: zero_division_011_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: zero_division_011_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N632): +oo]
> [1/1] entry: main ()
N632 -{%retval = alloca i32, align 4}-> N634
N634 -{store i32 0, i32* %retval, align 4}-> N635
N635 -{call zero_division_011_good}-> N658
N658 -{%dividend = alloca i32, align 4}-> N660
N660 -{%divisor = alloca i32, align 4}-> N661
N661 -{%ret = alloca i32, align 4}-> N663
N663 -{store i32 1000, i32* %dividend, align 4}-> N665
N665 -{store i32 2, i32* %divisor, align 4}-> N667
N667 -{%0 = load i32, i32* %dividend, align 4}-> N668
N668 -{%1 = load i32, i32* %divisor, align 4}-> N669
N669 -{%mul = mul i32 2, %1}-> N670
N670 -{%sub = sub i32 %mul, 3}-> N671
N671 -{%div = sdiv i32 %0, %sub}-> N672
N672 -{store i32 %div, i32* %ret, align 4}-> N673
N673 -{ret void}-> N657
N657 -{Return edge from zero_division_011_good to main}-> N636
N636 -{call zero_division_011_bad}-> N640
N640 -{%dividend = alloca i32, align 4}-> N642
N642 -{%divisor = alloca i32, align 4}-> N643
N643 -{%ret = alloca i32, align 4}-> N645
N645 -{store i32 1000, i32* %dividend, align 4}-> N647
N647 -{store i32 2, i32* %divisor, align 4}-> N649
N649 -{%0 = load i32, i32* %dividend, align 4}-> N650
N650 -{%1 = load i32, i32* %divisor, align 4}-> N651
N651 -{%mul = mul i32 2, %1}-> N652
N652 -{%sub = sub i32 %mul, 4}-> N653
N653 -{%div = sdiv i32 %0, %sub}-> N654
N654 -{store i32 %div, i32* %ret, align 4}-> N655
N655 -{ret void}-> N639
N639 -{Return edge from zero_division_011_bad to main}-> N637
N637 -{ret i32 0}-> N631
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Divide By Zero
At node  : N653
On edge  : N653 -{%div = sdiv i32 %0, %sub}-> N654
Message  : Divide By Zero
> Start from entry function: main, At N632 of Function main
> Entering function: zero_division_011_good, On N635 -> N658 (call zero_division_011_good)
> Leaving function: zero_division_011_good, On N657 -> N636 (Return edge from zero_division_011_good to main)
> Entering function: zero_division_011_bad, On N636 -> N640 (call zero_division_011_bad)
<Defect> : N653 -> N654: [%div = sdiv i32 %0, %sub]
N653 -> N654: [%div = sdiv i32 %0, %sub] <--
-- end of trace --
=====================================================
CWE_369(Divide By Zero): 1
	[./369_zero_division_9.c 10] zero_division_011_bad 		[N653 -{%div = sdiv i32 %0, %sub}-> N654]	(Divide By Zero)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 0
