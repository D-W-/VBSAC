/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=38036:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.ITC_190_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [bit_shift_013_func_001]
 +bit_shift_013_func_001
SCC(1): [bit_shift_013_bad]
 +bit_shift_013_bad
SCC(1): [bit_shift_013_good]
 +bit_shift_013_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_013_bad, bit_shift_013_func_001, bit_shift_013_good, main]
Loops     []
----
function: bit_shift_013_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_013_func_001
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_013_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.207s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N27): +oo]
> [1/1] entry: main ()
N27 -{%retval = alloca i32, align 4}-> N29
N29 -{store i32 0, i32* %retval, align 4}-> N30
N30 -{call bit_shift_013_good}-> N22
N22 -{call bit_shift_013_func_001}-> N6
N6 -{%shift.addr = alloca i32, align 4}-> N8
N8 -{%a = alloca i32, align 4}-> N9
N9 -{%ret = alloca i32, align 4}-> N10
N10 -{store i32 %shift, i32* %shift.addr, align 4}-> N13
N13 -{store i32 1, i32* %a, align 4}-> N15
N15 -{%0 = load i32, i32* %a, align 4}-> N16
N16 -{%1 = load i32, i32* %shift.addr, align 4}-> N17
N17 -{%shl = shl i32 %0, %1}-> N18
N18 -{store i32 %shl, i32* %ret, align 4}-> N19
N19 -{ret void}-> N5
N5 -{Return edge from bit_shift_013_func_001 to bit_shift_013_good}-> N24
N24 -{ret void}-> N21
N21 -{Return edge from bit_shift_013_good to main}-> N31
N31 -{call bit_shift_013_bad}-> N1
N1 -{call bit_shift_013_func_001}-> N6
N6 -{%shift.addr = alloca i32, align 4}-> N8
N8 -{%a = alloca i32, align 4}-> N9
N9 -{%ret = alloca i32, align 4}-> N10
N10 -{store i32 %shift, i32* %shift.addr, align 4}-> N13
N13 -{store i32 1, i32* %a, align 4}-> N15
N15 -{%0 = load i32, i32* %a, align 4}-> N16
N16 -{%1 = load i32, i32* %shift.addr, align 4}-> N17
N17 -{%shl = shl i32 %0, %1}-> N18
N18 -{store i32 %shl, i32* %ret, align 4}-> N19
N19 -{ret void}-> N5
N5 -{Return edge from bit_shift_013_func_001 to bit_shift_013_bad}-> N3
N3 -{ret void}-> N0
N0 -{Return edge from bit_shift_013_bad to main}-> N32
N32 -{ret i32 0}-> N26
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N17
On edge  : N17 -{%shl = shl i32 %0, %1}-> N18
Message  : integer overflow
> Start from entry function: main, At N27 of Function main
> Entering function: bit_shift_013_good, On N30 -> N22 (call bit_shift_013_good)
> Entering function: bit_shift_013_func_001, On N22 -> N6 (call bit_shift_013_func_001)
> Leaving function: bit_shift_013_func_001, On N5 -> N24 (Return edge from bit_shift_013_func_001 to bit_shift_013_good)
> Leaving function: bit_shift_013_good, On N21 -> N31 (Return edge from bit_shift_013_good to main)
> Entering function: bit_shift_013_bad, On N31 -> N1 (call bit_shift_013_bad)
> Entering function: bit_shift_013_func_001, On N1 -> N6 (call bit_shift_013_func_001)
<Defect> : N17 -> N18: [%shl = shl i32 %0, %1]
N17 -> N18: [%shl = shl i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_10.c 9] bit_shift_013_func_001 		[N17 -{%shl = shl i32 %0, %1}-> N18]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_014_bad]
 +bit_shift_014_bad
SCC(1): [bit_shift_014_good]
 +bit_shift_014_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_014_bad, bit_shift_014_good, main]
Loops     []
----
function: bit_shift_014_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_014_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.019s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N71): +oo]
> [1/1] entry: main ()
N71 -{global: bit_shift_014_bad.shifts}-> N79
N79 -{global: bit_shift_014_good.shifts}-> N78
N78 -{%retval = alloca i32, align 4}-> N73
N73 -{store i32 0, i32* %retval, align 4}-> N74
N74 -{call bit_shift_014_good}-> N53
N53 -{%a = alloca i32, align 4}-> N55
N55 -{%shifts = alloca [5 x i32], align 16}-> N56
N56 -{%ret = alloca i32, align 4}-> N58
N58 -{store i32 1, i32* %a, align 4}-> N60
N60 -{%0 = bitcast [5 x i32]* %shifts to i8*}-> N61
N61 -{call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([5 x i32]* @bit_shift_014_good.shifts to i8*), i8* 20, i8* 16, i8* false, i8* @llvm.memcpy.p0i8.p0i8.i64)}-> N63
N63 -{%1 = load i32, i32* %a, align 4}-> N64
N64 -{%arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %shifts, i64 0, i64 3}-> N65
N65 -{%2 = load i32, i32* %arrayidx, align 4}-> N66
N66 -{%shl = shl i32 %1, %2}-> N67
N67 -{store i32 %shl, i32* %ret, align 4}-> N68
N68 -{ret void}-> N52
N52 -{Return edge from bit_shift_014_good to main}-> N75
N75 -{call bit_shift_014_bad}-> N35
N35 -{%a = alloca i32, align 4}-> N37
N37 -{%shifts = alloca [5 x i32], align 16}-> N38
N38 -{%ret = alloca i32, align 4}-> N40
N40 -{store i32 1, i32* %a, align 4}-> N42
N42 -{%0 = bitcast [5 x i32]* %shifts to i8*}-> N43
N43 -{call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([5 x i32]* @bit_shift_014_bad.shifts to i8*), i8* 20, i8* 16, i8* false, i8* @llvm.memcpy.p0i8.p0i8.i64)}-> N45
N45 -{%1 = load i32, i32* %a, align 4}-> N46
N46 -{%arrayidx = getelementptr inbounds [5 x i32], [5 x i32]* %shifts, i64 0, i64 3}-> N47
N47 -{%2 = load i32, i32* %arrayidx, align 4}-> N48
N48 -{%shl = shl i32 %1, %2}-> N49
N49 -{store i32 %shl, i32* %ret, align 4}-> N50
N50 -{ret void}-> N34
N34 -{Return edge from bit_shift_014_bad to main}-> N76
N76 -{ret i32 0}-> N70
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N48
On edge  : N48 -{%shl = shl i32 %1, %2}-> N49
Message  : integer overflow
> Start from entry function: main, At N71 of Function main
> Entering function: bit_shift_014_good, On N74 -> N53 (call bit_shift_014_good)
> Leaving function: bit_shift_014_good, On N52 -> N75 (Return edge from bit_shift_014_good to main)
> Entering function: bit_shift_014_bad, On N75 -> N35 (call bit_shift_014_bad)
<Defect> : N48 -> N49: [%shl = shl i32 %1, %2]
N48 -> N49: [%shl = shl i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_11.c 10] bit_shift_014_bad 		[N48 -{%shl = shl i32 %1, %2}-> N49]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_015_bad]
 +bit_shift_015_bad
SCC(1): [bit_shift_015_good]
 +bit_shift_015_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_015_good, main, bit_shift_015_bad]
Loops     []
----
function: bit_shift_015_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_015_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.02s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N121): +oo]
> [1/1] entry: main ()
N121 -{%retval = alloca i32, align 4}-> N123
N123 -{store i32 0, i32* %retval, align 4}-> N124
N124 -{call bit_shift_015_good}-> N101
N101 -{%a = alloca i32, align 4}-> N103
N103 -{%shift = alloca i32, align 4}-> N104
N104 -{%shift1 = alloca i32, align 4}-> N105
N105 -{%ret = alloca i32, align 4}-> N107
N107 -{store i32 1, i32* %a, align 4}-> N109
N109 -{store i32 10, i32* %shift, align 4}-> N112
N112 -{%0 = load i32, i32* %shift, align 4}-> N113
N113 -{store i32 %0, i32* %shift1, align 4}-> N114
N114 -{%1 = load i32, i32* %a, align 4}-> N115
N115 -{%2 = load i32, i32* %shift1, align 4}-> N116
N116 -{%shl = shl i32 %1, %2}-> N117
N117 -{store i32 %shl, i32* %ret, align 4}-> N118
N118 -{ret void}-> N100
N100 -{Return edge from bit_shift_015_good to main}-> N125
N125 -{call bit_shift_015_bad}-> N81
N81 -{%a = alloca i32, align 4}-> N83
N83 -{%shift = alloca i32, align 4}-> N84
N84 -{%shift1 = alloca i32, align 4}-> N85
N85 -{%ret = alloca i32, align 4}-> N87
N87 -{store i32 1, i32* %a, align 4}-> N89
N89 -{store i32 32, i32* %shift, align 4}-> N92
N92 -{%0 = load i32, i32* %shift, align 4}-> N93
N93 -{store i32 %0, i32* %shift1, align 4}-> N94
N94 -{%1 = load i32, i32* %a, align 4}-> N95
N95 -{%2 = load i32, i32* %shift1, align 4}-> N96
N96 -{%shl = shl i32 %1, %2}-> N97
N97 -{store i32 %shl, i32* %ret, align 4}-> N98
N98 -{ret void}-> N80
N80 -{Return edge from bit_shift_015_bad to main}-> N126
N126 -{ret i32 0}-> N120
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N96
On edge  : N96 -{%shl = shl i32 %1, %2}-> N97
Message  : integer overflow
> Start from entry function: main, At N121 of Function main
> Entering function: bit_shift_015_good, On N124 -> N101 (call bit_shift_015_good)
> Leaving function: bit_shift_015_good, On N100 -> N125 (Return edge from bit_shift_015_good to main)
> Entering function: bit_shift_015_bad, On N125 -> N81 (call bit_shift_015_bad)
<Defect> : N96 -> N97: [%shl = shl i32 %1, %2]
N96 -> N97: [%shl = shl i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_12.c 12] bit_shift_015_bad 		[N96 -{%shl = shl i32 %1, %2}-> N97]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_016_bad]
 +bit_shift_016_bad
SCC(1): [bit_shift_016_good]
 +bit_shift_016_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, bit_shift_016_bad, bit_shift_016_good]
Loops     []
----
function: bit_shift_016_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_016_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.025s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N177): +oo]
> [1/1] entry: main ()
N177 -{%retval = alloca i32, align 4}-> N179
N179 -{store i32 0, i32* %retval, align 4}-> N180
N180 -{call bit_shift_016_good}-> N153
N153 -{%a = alloca i32, align 4}-> N155
N155 -{%shift = alloca i32, align 4}-> N156
N156 -{%shift1 = alloca i32, align 4}-> N157
N157 -{%shift2 = alloca i32, align 4}-> N158
N158 -{%ret = alloca i32, align 4}-> N160
N160 -{store i32 1, i32* %a, align 4}-> N162
N162 -{store i32 10, i32* %shift, align 4}-> N166
N166 -{%0 = load i32, i32* %shift, align 4}-> N167
N167 -{store i32 %0, i32* %shift1, align 4}-> N168
N168 -{%1 = load i32, i32* %shift1, align 4}-> N169
N169 -{store i32 %1, i32* %shift2, align 4}-> N170
N170 -{%2 = load i32, i32* %a, align 4}-> N171
N171 -{%3 = load i32, i32* %shift2, align 4}-> N172
N172 -{%shl = shl i32 %2, %3}-> N173
N173 -{store i32 %shl, i32* %ret, align 4}-> N174
N174 -{ret void}-> N152
N152 -{Return edge from bit_shift_016_good to main}-> N181
N181 -{call bit_shift_016_bad}-> N129
N129 -{%a = alloca i32, align 4}-> N131
N131 -{%shift = alloca i32, align 4}-> N132
N132 -{%shift1 = alloca i32, align 4}-> N133
N133 -{%shift2 = alloca i32, align 4}-> N134
N134 -{%ret = alloca i32, align 4}-> N136
N136 -{store i32 1, i32* %a, align 4}-> N138
N138 -{store i32 32, i32* %shift, align 4}-> N142
N142 -{%0 = load i32, i32* %shift, align 4}-> N143
N143 -{store i32 %0, i32* %shift1, align 4}-> N144
N144 -{%1 = load i32, i32* %shift1, align 4}-> N145
N145 -{store i32 %1, i32* %shift2, align 4}-> N146
N146 -{%2 = load i32, i32* %a, align 4}-> N147
N147 -{%3 = load i32, i32* %shift2, align 4}-> N148
N148 -{%shl = shl i32 %2, %3}-> N149
N149 -{store i32 %shl, i32* %ret, align 4}-> N150
N150 -{ret void}-> N128
N128 -{Return edge from bit_shift_016_bad to main}-> N182
N182 -{ret i32 0}-> N176
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N148
On edge  : N148 -{%shl = shl i32 %2, %3}-> N149
Message  : integer overflow
> Start from entry function: main, At N177 of Function main
> Entering function: bit_shift_016_good, On N180 -> N153 (call bit_shift_016_good)
> Leaving function: bit_shift_016_good, On N152 -> N181 (Return edge from bit_shift_016_good to main)
> Entering function: bit_shift_016_bad, On N181 -> N129 (call bit_shift_016_bad)
<Defect> : N148 -> N149: [%shl = shl i32 %2, %3]
N148 -> N149: [%shl = shl i32 %2, %3] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_13.c 14] bit_shift_016_bad 		[N148 -{%shl = shl i32 %2, %3}-> N149]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_017_bad]
 +bit_shift_017_bad
SCC(1): [bit_shift_017_good]
 +bit_shift_017_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, bit_shift_017_bad, bit_shift_017_good]
Loops     []
----
function: bit_shift_017_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_017_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N199): +oo]
> [1/1] entry: main ()
N199 -{%retval = alloca i32, align 4}-> N201
N201 -{store i32 0, i32* %retval, align 4}-> N202
N202 -{call bit_shift_017_good}-> N192
N192 -{%ret = alloca i32, align 4}-> N195
N195 -{store i32 1024, i32* %ret, align 4}-> N196
N196 -{ret void}-> N191
N191 -{Return edge from bit_shift_017_good to main}-> N203
N203 -{call bit_shift_017_bad}-> N185
N185 -{%ret = alloca i32, align 4}-> N188
N188 -{store i32 undef, i32* %ret, align 4}-> N189
N189 -{ret void}-> N184
N184 -{Return edge from bit_shift_017_bad to main}-> N204
N204 -{ret i32 0}-> N198
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N188
On edge  : N188 -{store i32 undef, i32* %ret, align 4}-> N189
Message  : undefined behavior
> Start from entry function: main, At N199 of Function main
> Entering function: bit_shift_017_good, On N202 -> N192 (call bit_shift_017_good)
> Leaving function: bit_shift_017_good, On N191 -> N203 (Return edge from bit_shift_017_good to main)
> Entering function: bit_shift_017_bad, On N203 -> N185 (call bit_shift_017_bad)
<Defect> : N188 -> N189: [store i32 undef, i32* %ret, align 4]
N188 -> N189: [store i32 undef, i32* %ret, align 4] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_14.c 8] bit_shift_017_bad 		[N188 -{store i32 undef, i32* %ret, align 4}-> N189]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_001_bad]
 +data_overflow_001_bad
SCC(1): [data_overflow_001_good]
 +data_overflow_001_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, data_overflow_001_bad, data_overflow_001_good]
Loops     []
----
function: data_overflow_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.021s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N235): +oo]
> [1/1] entry: main ()
N235 -{%retval = alloca i32, align 4}-> N237
N237 -{store i32 0, i32* %retval, align 4}-> N238
N238 -{call data_overflow_001_good}-> N221
N221 -{%max = alloca i8, align 1}-> N223
N223 -{%ret = alloca i8, align 1}-> N225
N225 -{store i8 112, i8* %max, align 1}-> N227
N227 -{%0 = load i8, i8* %max, align 1}-> N228
N228 -{%conv = sext i8 %0 to i32}-> N229
N229 -{%add = add i32 %conv, 2}-> N230
N230 -{%conv1 = trunc i32 %add to i8}-> N231
N231 -{store i8 %conv1, i8* %ret, align 1}-> N232
N232 -{ret void}-> N220
N220 -{Return edge from data_overflow_001_good to main}-> N239
N239 -{call data_overflow_001_bad}-> N207
N207 -{%max = alloca i8, align 1}-> N209
N209 -{%ret = alloca i8, align 1}-> N211
N211 -{store i8 127, i8* %max, align 1}-> N213
N213 -{%0 = load i8, i8* %max, align 1}-> N214
N214 -{%conv = sext i8 %0 to i32}-> N215
N215 -{%add = add i32 %conv, 1}-> N216
N216 -{%conv1 = trunc i32 %add to i8}-> N217
N217 -{store i8 %conv1, i8* %ret, align 1}-> N218
N218 -{ret void}-> N206
N206 -{Return edge from data_overflow_001_bad to main}-> N240
N240 -{ret i32 0}-> N234
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N216
On edge  : N216 -{%conv1 = trunc i32 %add to i8}-> N217
Message  : integer overflow
> Start from entry function: main, At N235 of Function main
> Entering function: data_overflow_001_good, On N238 -> N221 (call data_overflow_001_good)
> Leaving function: data_overflow_001_good, On N220 -> N239 (Return edge from data_overflow_001_good to main)
> Entering function: data_overflow_001_bad, On N239 -> N207 (call data_overflow_001_bad)
<Defect> : N216 -> N217: [%conv1 = trunc i32 %add to i8]
N216 -> N217: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_1.c 5] data_overflow_001_bad 		[N216 -{%conv1 = trunc i32 %add to i8}-> N217]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_002_bad]
 +data_overflow_002_bad
SCC(1): [data_overflow_002_good]
 +data_overflow_002_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_002_bad, data_overflow_002_good, main]
Loops     []
----
function: data_overflow_002_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_002_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N271): +oo]
> [1/1] entry: main ()
N271 -{%retval = alloca i32, align 4}-> N273
N273 -{store i32 0, i32* %retval, align 4}-> N274
N274 -{call data_overflow_002_good}-> N257
N257 -{%max = alloca i16, align 2}-> N259
N259 -{%ret = alloca i16, align 2}-> N261
N261 -{store i16 32752, i16* %max, align 2}-> N263
N263 -{%0 = load i16, i16* %max, align 2}-> N264
N264 -{%conv = sext i16 %0 to i32}-> N265
N265 -{%add = add i32 %conv, 2}-> N266
N266 -{%conv1 = trunc i32 %add to i16}-> N267
N267 -{store i16 %conv1, i16* %ret, align 2}-> N268
N268 -{ret void}-> N256
N256 -{Return edge from data_overflow_002_good to main}-> N275
N275 -{call data_overflow_002_bad}-> N243
N243 -{%max = alloca i16, align 2}-> N245
N245 -{%ret = alloca i16, align 2}-> N247
N247 -{store i16 32767, i16* %max, align 2}-> N249
N249 -{%0 = load i16, i16* %max, align 2}-> N250
N250 -{%conv = sext i16 %0 to i32}-> N251
N251 -{%add = add i32 %conv, 1}-> N252
N252 -{%conv1 = trunc i32 %add to i16}-> N253
N253 -{store i16 %conv1, i16* %ret, align 2}-> N254
N254 -{ret void}-> N242
N242 -{Return edge from data_overflow_002_bad to main}-> N276
N276 -{ret i32 0}-> N270
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N252
On edge  : N252 -{%conv1 = trunc i32 %add to i16}-> N253
Message  : integer overflow
> Start from entry function: main, At N271 of Function main
> Entering function: data_overflow_002_good, On N274 -> N257 (call data_overflow_002_good)
> Leaving function: data_overflow_002_good, On N256 -> N275 (Return edge from data_overflow_002_good to main)
> Entering function: data_overflow_002_bad, On N275 -> N243 (call data_overflow_002_bad)
<Defect> : N252 -> N253: [%conv1 = trunc i32 %add to i16]
N252 -> N253: [%conv1 = trunc i32 %add to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_2.c 9] data_overflow_002_bad 		[N252 -{%conv1 = trunc i32 %add to i16}-> N253]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_003_bad]
 +data_overflow_003_bad
SCC(1): [data_overflow_003_good]
 +data_overflow_003_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_003_good, main, data_overflow_003_bad]
Loops     []
----
function: data_overflow_003_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_003_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.027s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N303): +oo]
> [1/1] entry: main ()
N303 -{%retval = alloca i32, align 4}-> N305
N305 -{store i32 0, i32* %retval, align 4}-> N306
N306 -{call data_overflow_003_good}-> N291
N291 -{%max = alloca i32, align 4}-> N293
N293 -{%ret = alloca i32, align 4}-> N295
N295 -{store i32 2147483646, i32* %max, align 4}-> N297
N297 -{%0 = load i32, i32* %max, align 4}-> N298
N298 -{%add = add i32 %0, 1}-> N299
N299 -{store i32 %add, i32* %ret, align 4}-> N300
N300 -{ret void}-> N290
N290 -{Return edge from data_overflow_003_good to main}-> N307
N307 -{call data_overflow_003_bad}-> N279
N279 -{%max = alloca i32, align 4}-> N281
N281 -{%ret = alloca i32, align 4}-> N283
N283 -{store i32 2147483647, i32* %max, align 4}-> N285
N285 -{%0 = load i32, i32* %max, align 4}-> N286
N286 -{%add = add i32 %0, 1}-> N287
N287 -{store i32 %add, i32* %ret, align 4}-> N288
N288 -{ret void}-> N278
N278 -{Return edge from data_overflow_003_bad to main}-> N308
N308 -{ret i32 0}-> N302
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N286
On edge  : N286 -{%add = add i32 %0, 1}-> N287
Message  : integer overflow
> Start from entry function: main, At N303 of Function main
> Entering function: data_overflow_003_good, On N306 -> N291 (call data_overflow_003_good)
> Leaving function: data_overflow_003_good, On N290 -> N307 (Return edge from data_overflow_003_good to main)
> Entering function: data_overflow_003_bad, On N307 -> N279 (call data_overflow_003_bad)
<Defect> : N286 -> N287: [%add = add i32 %0, 1]
N286 -> N287: [%add = add i32 %0, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_3.c 9] data_overflow_003_bad 		[N286 -{%add = add i32 %0, 1}-> N287]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_011_bad]
 +data_overflow_011_bad
SCC(1): [data_overflow_011_good]
 +data_overflow_011_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_011_bad, data_overflow_011_good, main]
Loops     []
----
function: data_overflow_011_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_011_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N339): +oo]
> [1/1] entry: main ()
N339 -{%retval = alloca i32, align 4}-> N341
N341 -{store i32 0, i32* %retval, align 4}-> N342
N342 -{call data_overflow_011_good}-> N325
N325 -{%max = alloca i32, align 4}-> N327
N327 -{%ret = alloca i32, align 4}-> N329
N329 -{store i32 2147483646, i32* %max, align 4}-> N331
N331 -{%0 = load i32, i32* %max, align 4}-> N332
N332 -{%inc = add i32 %0, 1}-> N333
N333 -{store i32 %inc, i32* %max, align 4}-> N334
N334 -{%1 = load i32, i32* %max, align 4}-> N335
N335 -{store i32 %1, i32* %ret, align 4}-> N336
N336 -{ret void}-> N324
N324 -{Return edge from data_overflow_011_good to main}-> N343
N343 -{call data_overflow_011_bad}-> N311
N311 -{%max = alloca i32, align 4}-> N313
N313 -{%ret = alloca i32, align 4}-> N315
N315 -{store i32 2147483647, i32* %max, align 4}-> N317
N317 -{%0 = load i32, i32* %max, align 4}-> N318
N318 -{%inc = add i32 %0, 1}-> N319
N319 -{store i32 %inc, i32* %max, align 4}-> N320
N320 -{%1 = load i32, i32* %max, align 4}-> N321
N321 -{store i32 %1, i32* %ret, align 4}-> N322
N322 -{ret void}-> N310
N310 -{Return edge from data_overflow_011_bad to main}-> N344
N344 -{ret i32 0}-> N338
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N318
On edge  : N318 -{%inc = add i32 %0, 1}-> N319
Message  : integer overflow
> Start from entry function: main, At N339 of Function main
> Entering function: data_overflow_011_good, On N342 -> N325 (call data_overflow_011_good)
> Leaving function: data_overflow_011_good, On N324 -> N343 (Return edge from data_overflow_011_good to main)
> Entering function: data_overflow_011_bad, On N343 -> N311 (call data_overflow_011_bad)
<Defect> : N318 -> N319: [%inc = add i32 %0, 1]
N318 -> N319: [%inc = add i32 %0, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_4.c 9] data_overflow_011_bad 		[N318 -{%inc = add i32 %0, 1}-> N319]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_012_bad]
 +data_overflow_012_bad
SCC(1): [data_overflow_012_good]
 +data_overflow_012_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_012_good, main, data_overflow_012_bad]
Loops     []
----
function: data_overflow_012_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_012_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N371): +oo]
> [1/1] entry: main ()
N371 -{%retval = alloca i32, align 4}-> N373
N373 -{store i32 0, i32* %retval, align 4}-> N374
N374 -{call data_overflow_012_good}-> N359
N359 -{%max = alloca i32, align 4}-> N361
N361 -{%ret = alloca i32, align 4}-> N363
N363 -{store i32 2147483519, i32* %max, align 4}-> N365
N365 -{%0 = load i32, i32* %max, align 4}-> N366
N366 -{%add = add i32 %0, 128}-> N367
N367 -{store i32 %add, i32* %ret, align 4}-> N368
N368 -{ret void}-> N358
N358 -{Return edge from data_overflow_012_good to main}-> N375
N375 -{call data_overflow_012_bad}-> N347
N347 -{%max = alloca i32, align 4}-> N349
N349 -{%ret = alloca i32, align 4}-> N351
N351 -{store i32 2147483520, i32* %max, align 4}-> N353
N353 -{%0 = load i32, i32* %max, align 4}-> N354
N354 -{%add = add i32 %0, 128}-> N355
N355 -{store i32 %add, i32* %ret, align 4}-> N356
N356 -{ret void}-> N346
N346 -{Return edge from data_overflow_012_bad to main}-> N376
N376 -{ret i32 0}-> N370
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N354
On edge  : N354 -{%add = add i32 %0, 128}-> N355
Message  : integer overflow
> Start from entry function: main, At N371 of Function main
> Entering function: data_overflow_012_good, On N374 -> N359 (call data_overflow_012_good)
> Leaving function: data_overflow_012_good, On N358 -> N375 (Return edge from data_overflow_012_good to main)
> Entering function: data_overflow_012_bad, On N375 -> N347 (call data_overflow_012_bad)
<Defect> : N354 -> N355: [%add = add i32 %0, 128]
N354 -> N355: [%add = add i32 %0, 128] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_5.c 9] data_overflow_012_bad 		[N354 -{%add = add i32 %0, 128}-> N355]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_013_bad]
 +data_overflow_013_bad
SCC(1): [data_overflow_013_good]
 +data_overflow_013_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_013_bad, data_overflow_013_good, main]
Loops     []
----
function: data_overflow_013_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_013_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N403): +oo]
> [1/1] entry: main ()
N403 -{%retval = alloca i32, align 4}-> N405
N405 -{store i32 0, i32* %retval, align 4}-> N406
N406 -{call data_overflow_013_good}-> N391
N391 -{%max = alloca i32, align 4}-> N393
N393 -{%ret = alloca i32, align 4}-> N395
N395 -{store i32 1073741823, i32* %max, align 4}-> N397
N397 -{%0 = load i32, i32* %max, align 4}-> N398
N398 -{%mul = mul i32 %0, 2}-> N399
N399 -{store i32 %mul, i32* %ret, align 4}-> N400
N400 -{ret void}-> N390
N390 -{Return edge from data_overflow_013_good to main}-> N407
N407 -{call data_overflow_013_bad}-> N379
N379 -{%max = alloca i32, align 4}-> N381
N381 -{%ret = alloca i32, align 4}-> N383
N383 -{store i32 1073741824, i32* %max, align 4}-> N385
N385 -{%0 = load i32, i32* %max, align 4}-> N386
N386 -{%mul = mul i32 %0, 2}-> N387
N387 -{store i32 %mul, i32* %ret, align 4}-> N388
N388 -{ret void}-> N378
N378 -{Return edge from data_overflow_013_bad to main}-> N408
N408 -{ret i32 0}-> N402
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N386
On edge  : N386 -{%mul = mul i32 %0, 2}-> N387
Message  : integer overflow
> Start from entry function: main, At N403 of Function main
> Entering function: data_overflow_013_good, On N406 -> N391 (call data_overflow_013_good)
> Leaving function: data_overflow_013_good, On N390 -> N407 (Return edge from data_overflow_013_good to main)
> Entering function: data_overflow_013_bad, On N407 -> N379 (call data_overflow_013_bad)
<Defect> : N386 -> N387: [%mul = mul i32 %0, 2]
N386 -> N387: [%mul = mul i32 %0, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_6.c 9] data_overflow_013_bad 		[N386 -{%mul = mul i32 %0, 2}-> N387]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_014_bad]
 +data_overflow_014_bad
SCC(1): [data_overflow_014_good]
 +data_overflow_014_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_014_good, main, data_overflow_014_bad]
Loops     []
----
function: data_overflow_014_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_014_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N443): +oo]
> [1/1] entry: main ()
N443 -{%retval = alloca i32, align 4}-> N445
N445 -{store i32 0, i32* %retval, align 4}-> N446
N446 -{call data_overflow_014_good}-> N427
N427 -{%max = alloca i32, align 4}-> N429
N429 -{%d = alloca i32, align 4}-> N430
N430 -{%ret = alloca i32, align 4}-> N432
N432 -{store i32 2147483646, i32* %max, align 4}-> N434
N434 -{store i32 1, i32* %d, align 4}-> N436
N436 -{%0 = load i32, i32* %max, align 4}-> N437
N437 -{%1 = load i32, i32* %d, align 4}-> N438
N438 -{%add = add i32 %0, %1}-> N439
N439 -{store i32 %add, i32* %ret, align 4}-> N440
N440 -{ret void}-> N426
N426 -{Return edge from data_overflow_014_good to main}-> N447
N447 -{call data_overflow_014_bad}-> N411
N411 -{%max = alloca i32, align 4}-> N413
N413 -{%d = alloca i32, align 4}-> N414
N414 -{%ret = alloca i32, align 4}-> N416
N416 -{store i32 2147483647, i32* %max, align 4}-> N418
N418 -{store i32 1, i32* %d, align 4}-> N420
N420 -{%0 = load i32, i32* %max, align 4}-> N421
N421 -{%1 = load i32, i32* %d, align 4}-> N422
N422 -{%add = add i32 %0, %1}-> N423
N423 -{store i32 %add, i32* %ret, align 4}-> N424
N424 -{ret void}-> N410
N410 -{Return edge from data_overflow_014_bad to main}-> N448
N448 -{ret i32 0}-> N442
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N422
On edge  : N422 -{%add = add i32 %0, %1}-> N423
Message  : integer overflow
> Start from entry function: main, At N443 of Function main
> Entering function: data_overflow_014_good, On N446 -> N427 (call data_overflow_014_good)
> Leaving function: data_overflow_014_good, On N426 -> N447 (Return edge from data_overflow_014_good to main)
> Entering function: data_overflow_014_bad, On N447 -> N411 (call data_overflow_014_bad)
<Defect> : N422 -> N423: [%add = add i32 %0, %1]
N422 -> N423: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_7.c 10] data_overflow_014_bad 		[N422 -{%add = add i32 %0, %1}-> N423]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_014_bad]
 +data_overflow_014_bad
SCC(1): [data_overflow_014_good]
 +data_overflow_014_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, data_overflow_014_bad, data_overflow_014_good]
Loops     []
----
function: data_overflow_014_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_014_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N483): +oo]
> [1/1] entry: main ()
N483 -{%retval = alloca i32, align 4}-> N485
N485 -{store i32 0, i32* %retval, align 4}-> N486
N486 -{call data_overflow_014_good}-> N467
N467 -{%max = alloca i32, align 4}-> N469
N469 -{%d = alloca i32, align 4}-> N470
N470 -{%ret = alloca i32, align 4}-> N472
N472 -{store i32 2147483646, i32* %max, align 4}-> N474
N474 -{store i32 1, i32* %d, align 4}-> N476
N476 -{%0 = load i32, i32* %max, align 4}-> N477
N477 -{%1 = load i32, i32* %d, align 4}-> N478
N478 -{%add = add i32 %0, %1}-> N479
N479 -{store i32 %add, i32* %ret, align 4}-> N480
N480 -{ret void}-> N466
N466 -{Return edge from data_overflow_014_good to main}-> N487
N487 -{call data_overflow_014_bad}-> N451
N451 -{%max = alloca i32, align 4}-> N453
N453 -{%d = alloca i32, align 4}-> N454
N454 -{%ret = alloca i32, align 4}-> N456
N456 -{store i32 2147483646, i32* %max, align 4}-> N458
N458 -{store i32 2, i32* %d, align 4}-> N460
N460 -{%0 = load i32, i32* %max, align 4}-> N461
N461 -{%1 = load i32, i32* %d, align 4}-> N462
N462 -{%add = add i32 %0, %1}-> N463
N463 -{store i32 %add, i32* %ret, align 4}-> N464
N464 -{ret void}-> N450
N450 -{Return edge from data_overflow_014_bad to main}-> N488
N488 -{ret i32 0}-> N482
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N462
On edge  : N462 -{%add = add i32 %0, %1}-> N463
Message  : integer overflow
> Start from entry function: main, At N483 of Function main
> Entering function: data_overflow_014_good, On N486 -> N467 (call data_overflow_014_good)
> Leaving function: data_overflow_014_good, On N466 -> N487 (Return edge from data_overflow_014_good to main)
> Entering function: data_overflow_014_bad, On N487 -> N451 (call data_overflow_014_bad)
<Defect> : N462 -> N463: [%add = add i32 %0, %1]
N462 -> N463: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_8.c 10] data_overflow_014_bad 		[N462 -{%add = add i32 %0, %1}-> N463]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_015_bad]
 +data_overflow_015_bad
SCC(1): [data_overflow_015_good]
 +data_overflow_015_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_015_bad, data_overflow_015_good, main]
Loops     []
----
function: data_overflow_015_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_015_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N526): +oo]
> [1/1] entry: main ()
N526 -{%retval = alloca i32, align 4}-> N528
N528 -{store i32 0, i32* %retval, align 4}-> N529
N529 -{call data_overflow_015_good}-> N508
N508 -{%max = alloca i32, align 4}-> N510
N510 -{%d = alloca i32, align 4}-> N511
N511 -{%ret = alloca i32, align 4}-> N513
N513 -{store i32 2147483646, i32* %max, align 4}-> N516
N516 -{%call = call i32 @rand(i32 ()* @rand)}-> N517
N517 -{%rem = srem i32 %call, 2}-> N518
N518 -{store i32 %rem, i32* %d, align 4}-> N519
N519 -{%0 = load i32, i32* %max, align 4}-> N520
N520 -{%1 = load i32, i32* %d, align 4}-> N521
N521 -{%add = add i32 %0, %1}-> N522
N522 -{store i32 %add, i32* %ret, align 4}-> N523
N523 -{ret void}-> N507
N507 -{Return edge from data_overflow_015_good to main}-> N530
N530 -{call data_overflow_015_bad}-> N491
N491 -{%max = alloca i32, align 4}-> N493
N493 -{%d = alloca i32, align 4}-> N494
N494 -{%ret = alloca i32, align 4}-> N496
N496 -{store i32 2147483647, i32* %max, align 4}-> N499
N499 -{%call = call i32 @rand(i32 ()* @rand)}-> N500
N500 -{store i32 %call, i32* %d, align 4}-> N501
N501 -{%0 = load i32, i32* %max, align 4}-> N502
N502 -{%1 = load i32, i32* %d, align 4}-> N503
N503 -{%add = add i32 %0, %1}-> N504
N504 -{store i32 %add, i32* %ret, align 4}-> N505
N505 -{ret void}-> N490
N490 -{Return edge from data_overflow_015_bad to main}-> N531
N531 -{ret i32 0}-> N525
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N503
On edge  : N503 -{%add = add i32 %0, %1}-> N504
Message  : integer overflow
> Start from entry function: main, At N526 of Function main
> Entering function: data_overflow_015_good, On N529 -> N508 (call data_overflow_015_good)
> Leaving function: data_overflow_015_good, On N507 -> N530 (Return edge from data_overflow_015_good to main)
> Entering function: data_overflow_015_bad, On N530 -> N491 (call data_overflow_015_bad)
<Defect> : N503 -> N504: [%add = add i32 %0, %1]
N503 -> N504: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_9.c 14] data_overflow_015_bad 		[N503 -{%add = add i32 %0, %1}-> N504]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_001_bad]
 +bit_shift_001_bad
SCC(1): [bit_shift_001_good]
 +bit_shift_001_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_001_good, main, bit_shift_001_bad]
Loops     []
----
function: bit_shift_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N558): +oo]
> [1/1] entry: main ()
N558 -{%retval = alloca i32, align 4}-> N560
N560 -{store i32 0, i32* %retval, align 4}-> N561
N561 -{call bit_shift_001_good}-> N546
N546 -{%a = alloca i32, align 4}-> N548
N548 -{%ret = alloca i32, align 4}-> N550
N550 -{store i32 1, i32* %a, align 4}-> N552
N552 -{%0 = load i32, i32* %a, align 4}-> N553
N553 -{%shl = shl i32 %0, 10}-> N554
N554 -{store i32 %shl, i32* %ret, align 4}-> N555
N555 -{ret void}-> N545
N545 -{Return edge from bit_shift_001_good to main}-> N562
N562 -{call bit_shift_001_bad}-> N534
N534 -{%a = alloca i32, align 4}-> N536
N536 -{%ret = alloca i32, align 4}-> N538
N538 -{store i32 1, i32* %a, align 4}-> N540
N540 -{%0 = load i32, i32* %a, align 4}-> N541
N541 -{%shl = shl i32 %0, 32}-> N542
N542 -{store i32 %shl, i32* %ret, align 4}-> N543
N543 -{ret void}-> N533
N533 -{Return edge from bit_shift_001_bad to main}-> N563
N563 -{ret i32 0}-> N557
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N541
On edge  : N541 -{%shl = shl i32 %0, 32}-> N542
Message  : integer overflow
> Start from entry function: main, At N558 of Function main
> Entering function: bit_shift_001_good, On N561 -> N546 (call bit_shift_001_good)
> Leaving function: bit_shift_001_good, On N545 -> N562 (Return edge from bit_shift_001_good to main)
> Entering function: bit_shift_001_bad, On N562 -> N534 (call bit_shift_001_bad)
<Defect> : N541 -> N542: [%shl = shl i32 %0, 32]
N541 -> N542: [%shl = shl i32 %0, 32] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_1.c 9] bit_shift_001_bad 		[N541 -{%shl = shl i32 %0, 32}-> N542]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_003_bad]
 +bit_shift_003_bad
SCC(1): [bit_shift_003_good]
 +bit_shift_003_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_003_bad, bit_shift_003_good, main]
Loops     []
----
function: bit_shift_003_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_003_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N590): +oo]
> [1/1] entry: main ()
N590 -{%retval = alloca i32, align 4}-> N592
N592 -{store i32 0, i32* %retval, align 4}-> N593
N593 -{call bit_shift_003_good}-> N578
N578 -{%a = alloca i32, align 4}-> N580
N580 -{%ret = alloca i32, align 4}-> N582
N582 -{store i32 1, i32* %a, align 4}-> N584
N584 -{%0 = load i32, i32* %a, align 4}-> N585
N585 -{%shl = shl i32 %0, 10}-> N586
N586 -{store i32 %shl, i32* %ret, align 4}-> N587
N587 -{ret void}-> N577
N577 -{Return edge from bit_shift_003_good to main}-> N594
N594 -{call bit_shift_003_bad}-> N566
N566 -{%a = alloca i32, align 4}-> N568
N568 -{%ret = alloca i32, align 4}-> N570
N570 -{store i32 1, i32* %a, align 4}-> N572
N572 -{%0 = load i32, i32* %a, align 4}-> N573
N573 -{%shl = shl i32 %0, 32}-> N574
N574 -{store i32 %shl, i32* %ret, align 4}-> N575
N575 -{ret void}-> N565
N565 -{Return edge from bit_shift_003_bad to main}-> N595
N595 -{ret i32 0}-> N589
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N573
On edge  : N573 -{%shl = shl i32 %0, 32}-> N574
Message  : integer overflow
> Start from entry function: main, At N590 of Function main
> Entering function: bit_shift_003_good, On N593 -> N578 (call bit_shift_003_good)
> Leaving function: bit_shift_003_good, On N577 -> N594 (Return edge from bit_shift_003_good to main)
> Entering function: bit_shift_003_bad, On N594 -> N566 (call bit_shift_003_bad)
<Defect> : N573 -> N574: [%shl = shl i32 %0, 32]
N573 -> N574: [%shl = shl i32 %0, 32] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_2.c 9] bit_shift_003_bad 		[N573 -{%shl = shl i32 %0, 32}-> N574]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_005_bad]
 +bit_shift_005_bad
SCC(1): [bit_shift_005_good]
 +bit_shift_005_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_005_good, main, bit_shift_005_bad]
Loops     []
----
function: bit_shift_005_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_005_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N622): +oo]
> [1/1] entry: main ()
N622 -{%retval = alloca i32, align 4}-> N624
N624 -{store i32 0, i32* %retval, align 4}-> N625
N625 -{call bit_shift_005_good}-> N610
N610 -{%a = alloca i32, align 4}-> N612
N612 -{%ret = alloca i32, align 4}-> N614
N614 -{store i32 1, i32* %a, align 4}-> N616
N616 -{%0 = load i32, i32* %a, align 4}-> N617
N617 -{%shl = shl i32 %0, 10}-> N618
N618 -{store i32 %shl, i32* %ret, align 4}-> N619
N619 -{ret void}-> N609
N609 -{Return edge from bit_shift_005_good to main}-> N626
N626 -{call bit_shift_005_bad}-> N598
N598 -{%a = alloca i32, align 4}-> N600
N600 -{%ret = alloca i32, align 4}-> N602
N602 -{store i32 1, i32* %a, align 4}-> N604
N604 -{%0 = load i32, i32* %a, align 4}-> N605
N605 -{%shl = shl i32 %0, -1}-> N606
N606 -{store i32 %shl, i32* %ret, align 4}-> N607
N607 -{ret void}-> N597
N597 -{Return edge from bit_shift_005_bad to main}-> N627
N627 -{ret i32 0}-> N621
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N605
On edge  : N605 -{%shl = shl i32 %0, -1}-> N606
Message  : undefined behavior
> Start from entry function: main, At N622 of Function main
> Entering function: bit_shift_005_good, On N625 -> N610 (call bit_shift_005_good)
> Leaving function: bit_shift_005_good, On N609 -> N626 (Return edge from bit_shift_005_good to main)
> Entering function: bit_shift_005_bad, On N626 -> N598 (call bit_shift_005_bad)
<Defect> : N605 -> N606: [%shl = shl i32 %0, -1]
N605 -> N606: [%shl = shl i32 %0, -1] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_3.c 9] bit_shift_005_bad 		[N605 -{%shl = shl i32 %0, -1}-> N606]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_007_bad]
 +bit_shift_007_bad
SCC(1): [bit_shift_007_good]
 +bit_shift_007_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_007_bad, bit_shift_007_good, main]
Loops     []
----
function: bit_shift_007_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_007_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N654): +oo]
> [1/1] entry: main ()
N654 -{%retval = alloca i32, align 4}-> N656
N656 -{store i32 0, i32* %retval, align 4}-> N657
N657 -{call bit_shift_007_good}-> N642
N642 -{%a = alloca i32, align 4}-> N644
N644 -{%ret = alloca i32, align 4}-> N646
N646 -{store i32 1, i32* %a, align 4}-> N648
N648 -{%0 = load i32, i32* %a, align 4}-> N649
N649 -{%shr = ashr i32 %0, 10}-> N650
N650 -{store i32 %shr, i32* %ret, align 4}-> N651
N651 -{ret void}-> N641
N641 -{Return edge from bit_shift_007_good to main}-> N658
N658 -{call bit_shift_007_bad}-> N630
N630 -{%a = alloca i32, align 4}-> N632
N632 -{%ret = alloca i32, align 4}-> N634
N634 -{store i32 1, i32* %a, align 4}-> N636
N636 -{%0 = load i32, i32* %a, align 4}-> N637
N637 -{%shr = ashr i32 %0, -1}-> N638
N638 -{store i32 %shr, i32* %ret, align 4}-> N639
N639 -{ret void}-> N629
N629 -{Return edge from bit_shift_007_bad to main}-> N659
N659 -{ret i32 0}-> N653
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N637
On edge  : N637 -{%shr = ashr i32 %0, -1}-> N638
Message  : undefined behavior
> Start from entry function: main, At N654 of Function main
> Entering function: bit_shift_007_good, On N657 -> N642 (call bit_shift_007_good)
> Leaving function: bit_shift_007_good, On N641 -> N658 (Return edge from bit_shift_007_good to main)
> Entering function: bit_shift_007_bad, On N658 -> N630 (call bit_shift_007_bad)
<Defect> : N637 -> N638: [%shr = ashr i32 %0, -1]
N637 -> N638: [%shr = ashr i32 %0, -1] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_4.c 9] bit_shift_007_bad 		[N637 -{%shr = ashr i32 %0, -1}-> N638]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_008_bad]
 +bit_shift_008_bad
SCC(1): [bit_shift_008_good]
 +bit_shift_008_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_008_good, main, bit_shift_008_bad]
Loops     []
----
function: bit_shift_008_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_008_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N694): +oo]
> [1/1] entry: main ()
N694 -{%retval = alloca i32, align 4}-> N696
N696 -{store i32 0, i32* %retval, align 4}-> N697
N697 -{call bit_shift_008_good}-> N678
N678 -{%a = alloca i32, align 4}-> N680
N680 -{%shift = alloca i32, align 4}-> N681
N681 -{%ret = alloca i32, align 4}-> N683
N683 -{store i32 1, i32* %a, align 4}-> N685
N685 -{store i32 10, i32* %shift, align 4}-> N687
N687 -{%0 = load i32, i32* %a, align 4}-> N688
N688 -{%1 = load i32, i32* %shift, align 4}-> N689
N689 -{%shl = shl i32 %0, %1}-> N690
N690 -{store i32 %shl, i32* %ret, align 4}-> N691
N691 -{ret void}-> N677
N677 -{Return edge from bit_shift_008_good to main}-> N698
N698 -{call bit_shift_008_bad}-> N662
N662 -{%a = alloca i32, align 4}-> N664
N664 -{%shift = alloca i32, align 4}-> N665
N665 -{%ret = alloca i32, align 4}-> N667
N667 -{store i32 1, i32* %a, align 4}-> N669
N669 -{store i32 32, i32* %shift, align 4}-> N671
N671 -{%0 = load i32, i32* %a, align 4}-> N672
N672 -{%1 = load i32, i32* %shift, align 4}-> N673
N673 -{%shl = shl i32 %0, %1}-> N674
N674 -{store i32 %shl, i32* %ret, align 4}-> N675
N675 -{ret void}-> N661
N661 -{Return edge from bit_shift_008_bad to main}-> N699
N699 -{ret i32 0}-> N693
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N673
On edge  : N673 -{%shl = shl i32 %0, %1}-> N674
Message  : integer overflow
> Start from entry function: main, At N694 of Function main
> Entering function: bit_shift_008_good, On N697 -> N678 (call bit_shift_008_good)
> Leaving function: bit_shift_008_good, On N677 -> N698 (Return edge from bit_shift_008_good to main)
> Entering function: bit_shift_008_bad, On N698 -> N662 (call bit_shift_008_bad)
<Defect> : N673 -> N674: [%shl = shl i32 %0, %1]
N673 -> N674: [%shl = shl i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_5.c 10] bit_shift_008_bad 		[N673 -{%shl = shl i32 %0, %1}-> N674]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_009_bad]
 +bit_shift_009_bad
SCC(1): [bit_shift_009_good]
 +bit_shift_009_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, bit_shift_009_bad, bit_shift_009_good]
Loops     []
----
function: bit_shift_009_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_009_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N737): +oo]
> [1/1] entry: main ()
N737 -{%retval = alloca i32, align 4}-> N739
N739 -{store i32 0, i32* %retval, align 4}-> N740
N740 -{call bit_shift_009_good}-> N719
N719 -{%a = alloca i32, align 4}-> N721
N721 -{%shift = alloca i32, align 4}-> N722
N722 -{%ret = alloca i32, align 4}-> N724
N724 -{store i32 1, i32* %a, align 4}-> N727
N727 -{%call = call i32 @rand(i32 ()* @rand)}-> N728
N728 -{%rem = srem i32 %call, 30}-> N729
N729 -{store i32 %rem, i32* %shift, align 4}-> N730
N730 -{%0 = load i32, i32* %a, align 4}-> N731
N731 -{%1 = load i32, i32* %shift, align 4}-> N732
N732 -{%shl = shl i32 %0, %1}-> N733
N733 -{store i32 %shl, i32* %ret, align 4}-> N734
N734 -{ret void}-> N718
N718 -{Return edge from bit_shift_009_good to main}-> N741
N741 -{call bit_shift_009_bad}-> N702
N702 -{%a = alloca i32, align 4}-> N704
N704 -{%shift = alloca i32, align 4}-> N705
N705 -{%ret = alloca i32, align 4}-> N707
N707 -{store i32 1, i32* %a, align 4}-> N710
N710 -{%call = call i32 @rand(i32 ()* @rand)}-> N711
N711 -{store i32 %call, i32* %shift, align 4}-> N712
N712 -{%0 = load i32, i32* %a, align 4}-> N713
N713 -{%1 = load i32, i32* %shift, align 4}-> N714
N714 -{%shl = shl i32 %0, %1}-> N715
N715 -{store i32 %shl, i32* %ret, align 4}-> N716
N716 -{ret void}-> N701
N701 -{Return edge from bit_shift_009_bad to main}-> N742
N742 -{ret i32 0}-> N736
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Undefined Behavior
At node  : N714
On edge  : N714 -{%shl = shl i32 %0, %1}-> N715
Message  : undefined behavior
> Start from entry function: main, At N737 of Function main
> Entering function: bit_shift_009_good, On N740 -> N719 (call bit_shift_009_good)
> Leaving function: bit_shift_009_good, On N718 -> N741 (Return edge from bit_shift_009_good to main)
> Entering function: bit_shift_009_bad, On N741 -> N702 (call bit_shift_009_bad)
<Defect> : N714 -> N715: [%shl = shl i32 %0, %1]
N714 -> N715: [%shl = shl i32 %0, %1] <--
-- end of trace --
=====================================================
UNDEFINED_BEHAVIOR(Undefined Behavior): 1
	[./190_bit_shift_6.c 14] bit_shift_009_bad 		[N714 -{%shl = shl i32 %0, %1}-> N715]	(undefined behavior)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_010_bad]
 +bit_shift_010_bad
SCC(1): [bit_shift_010_good]
 +bit_shift_010_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_010_bad, bit_shift_010_good, main]
Loops     []
----
function: bit_shift_010_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_010_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N781): +oo]
> [1/1] entry: main ()
N781 -{%retval = alloca i32, align 4}-> N783
N783 -{store i32 0, i32* %retval, align 4}-> N784
N784 -{call bit_shift_010_good}-> N763
N763 -{%a = alloca i32, align 4}-> N765
N765 -{%shift = alloca i32, align 4}-> N766
N766 -{%ret = alloca i32, align 4}-> N768
N768 -{store i32 1, i32* %a, align 4}-> N770
N770 -{store i32 2, i32* %shift, align 4}-> N772
N772 -{%0 = load i32, i32* %a, align 4}-> N773
N773 -{%1 = load i32, i32* %shift, align 4}-> N774
N774 -{%mul = mul i32 5, %1}-> N775
N775 -{%add = add i32 %mul, 1}-> N776
N776 -{%shl = shl i32 %0, %add}-> N777
N777 -{store i32 %shl, i32* %ret, align 4}-> N778
N778 -{ret void}-> N762
N762 -{Return edge from bit_shift_010_good to main}-> N785
N785 -{call bit_shift_010_bad}-> N745
N745 -{%a = alloca i32, align 4}-> N747
N747 -{%shift = alloca i32, align 4}-> N748
N748 -{%ret = alloca i32, align 4}-> N750
N750 -{store i32 1, i32* %a, align 4}-> N752
N752 -{store i32 6, i32* %shift, align 4}-> N754
N754 -{%0 = load i32, i32* %a, align 4}-> N755
N755 -{%1 = load i32, i32* %shift, align 4}-> N756
N756 -{%mul = mul i32 5, %1}-> N757
N757 -{%add = add i32 %mul, 2}-> N758
N758 -{%shl = shl i32 %0, %add}-> N759
N759 -{store i32 %shl, i32* %ret, align 4}-> N760
N760 -{ret void}-> N744
N744 -{Return edge from bit_shift_010_bad to main}-> N786
N786 -{ret i32 0}-> N780
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N758
On edge  : N758 -{%shl = shl i32 %0, %add}-> N759
Message  : integer overflow
> Start from entry function: main, At N781 of Function main
> Entering function: bit_shift_010_good, On N784 -> N763 (call bit_shift_010_good)
> Leaving function: bit_shift_010_good, On N762 -> N785 (Return edge from bit_shift_010_good to main)
> Entering function: bit_shift_010_bad, On N785 -> N745 (call bit_shift_010_bad)
<Defect> : N758 -> N759: [%shl = shl i32 %0, %add]
N758 -> N759: [%shl = shl i32 %0, %add] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_7.c 10] bit_shift_010_bad 		[N758 -{%shl = shl i32 %0, %add}-> N759]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [bit_shift_011_bad]
 +bit_shift_011_bad
SCC(1): [bit_shift_011_good]
 +bit_shift_011_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [bit_shift_011_good, main, bit_shift_011_bad]
Loops     []
----
function: bit_shift_011_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_011_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N827): +oo]
> [1/1] entry: main ()
N827 -{%retval = alloca i32, align 4}-> N829
N829 -{store i32 0, i32* %retval, align 4}-> N830
N830 -{call bit_shift_011_good}-> N808
N808 -{%a = alloca i32, align 4}-> N810
N810 -{%shift = alloca i32, align 4}-> N811
N811 -{%ret = alloca i32, align 4}-> N813
N813 -{store i32 1, i32* %a, align 4}-> N815
N815 -{store i32 2, i32* %shift, align 4}-> N817
N817 -{%0 = load i32, i32* %a, align 4}-> N818
N818 -{%1 = load i32, i32* %shift, align 4}-> N819
N819 -{%2 = load i32, i32* %shift, align 4}-> N820
N820 -{%mul = mul i32 %1, %2}-> N821
N821 -{%add = add i32 %mul, 6}-> N822
N822 -{%shl = shl i32 %0, %add}-> N823
N823 -{store i32 %shl, i32* %ret, align 4}-> N824
N824 -{ret void}-> N807
N807 -{Return edge from bit_shift_011_good to main}-> N831
N831 -{call bit_shift_011_bad}-> N789
N789 -{%a = alloca i32, align 4}-> N791
N791 -{%shift = alloca i32, align 4}-> N792
N792 -{%ret = alloca i32, align 4}-> N794
N794 -{store i32 1, i32* %a, align 4}-> N796
N796 -{store i32 5, i32* %shift, align 4}-> N798
N798 -{%0 = load i32, i32* %a, align 4}-> N799
N799 -{%1 = load i32, i32* %shift, align 4}-> N800
N800 -{%2 = load i32, i32* %shift, align 4}-> N801
N801 -{%mul = mul i32 %1, %2}-> N802
N802 -{%add = add i32 %mul, 7}-> N803
N803 -{%shl = shl i32 %0, %add}-> N804
N804 -{store i32 %shl, i32* %ret, align 4}-> N805
N805 -{ret void}-> N788
N788 -{Return edge from bit_shift_011_bad to main}-> N832
N832 -{ret i32 0}-> N826
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N803
On edge  : N803 -{%shl = shl i32 %0, %add}-> N804
Message  : integer overflow
> Start from entry function: main, At N827 of Function main
> Entering function: bit_shift_011_good, On N830 -> N808 (call bit_shift_011_good)
> Leaving function: bit_shift_011_good, On N807 -> N831 (Return edge from bit_shift_011_good to main)
> Entering function: bit_shift_011_bad, On N831 -> N789 (call bit_shift_011_bad)
<Defect> : N803 -> N804: [%shl = shl i32 %0, %add]
N803 -> N804: [%shl = shl i32 %0, %add] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_8.c 10] bit_shift_011_bad 		[N803 -{%shl = shl i32 %0, %add}-> N804]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_bit_shift_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [bit_shift_012_func_001_bad]
 +bit_shift_012_func_001_bad
SCC(1): [bit_shift_012_bad]
 +bit_shift_012_bad
SCC(1): [bit_shift_012_func_001_good]
 +bit_shift_012_func_001_good
SCC(1): [bit_shift_012_good]
 +bit_shift_012_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, bit_shift_012_bad, bit_shift_012_func_001_bad, bit_shift_012_func_001_good, bit_shift_012_good]
Loops     []
----
function: bit_shift_012_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: bit_shift_012_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: bit_shift_012_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: bit_shift_012_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N869): +oo]
> [1/1] entry: main ()
N869 -{%retval = alloca i32, align 4}-> N871
N871 -{store i32 0, i32* %retval, align 4}-> N872
N872 -{call bit_shift_012_good}-> N856
N856 -{%a = alloca i32, align 4}-> N858
N858 -{%ret = alloca i32, align 4}-> N860
N860 -{store i32 1, i32* %a, align 4}-> N862
N862 -{%0 = load i32, i32* %a, align 4}-> N863
N863 -{call bit_shift_012_func_001_good}-> N852
N852 -{ret i32 10}-> N851
N851 -{Return edge from bit_shift_012_func_001_good to bit_shift_012_good}-> N864
N864 -{%shl = shl i32 %0, %call}-> N865
N865 -{store i32 %shl, i32* %ret, align 4}-> N866
N866 -{ret void}-> N855
N855 -{Return edge from bit_shift_012_good to main}-> N873
N873 -{call bit_shift_012_bad}-> N835
N835 -{%a = alloca i32, align 4}-> N837
N837 -{%ret = alloca i32, align 4}-> N839
N839 -{store i32 1, i32* %a, align 4}-> N841
N841 -{%0 = load i32, i32* %a, align 4}-> N842
N842 -{call bit_shift_012_func_001_bad}-> N848
N848 -{ret i32 32}-> N847
N847 -{Return edge from bit_shift_012_func_001_bad to bit_shift_012_bad}-> N843
N843 -{%shl = shl i32 %0, %call}-> N844
N844 -{store i32 %shl, i32* %ret, align 4}-> N845
N845 -{ret void}-> N834
N834 -{Return edge from bit_shift_012_bad to main}-> N874
N874 -{ret i32 0}-> N868
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N843
On edge  : N843 -{%shl = shl i32 %0, %call}-> N844
Message  : integer overflow
> Start from entry function: main, At N869 of Function main
> Entering function: bit_shift_012_good, On N872 -> N856 (call bit_shift_012_good)
> Entering function: bit_shift_012_func_001_good, On N863 -> N852 (call bit_shift_012_func_001_good)
> Leaving function: bit_shift_012_func_001_good, On N851 -> N864 (Return edge from bit_shift_012_func_001_good to bit_shift_012_good)
> Leaving function: bit_shift_012_good, On N855 -> N873 (Return edge from bit_shift_012_good to main)
> Entering function: bit_shift_012_bad, On N873 -> N835 (call bit_shift_012_bad)
> Entering function: bit_shift_012_func_001_bad, On N842 -> N848 (call bit_shift_012_func_001_bad)
> Leaving function: bit_shift_012_func_001_bad, On N847 -> N843 (Return edge from bit_shift_012_func_001_bad to bit_shift_012_bad)
<Defect> : N843 -> N844: [%shl = shl i32 %0, %call]
N843 -> N844: [%shl = shl i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_bit_shift_9.c 14] bit_shift_012_bad 		[N843 -{%shl = shl i32 %0, %call}-> N844]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_016_bad]
 +data_overflow_016_bad
SCC(1): [data_overflow_016_good]
 +data_overflow_016_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_016_bad, data_overflow_016_good, main]
Loops     []
----
function: data_overflow_016_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_016_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N903): +oo]
> [1/1] entry: main ()
N903 -{%retval = alloca i32, align 4}-> N905
N905 -{store i32 0, i32* %retval, align 4}-> N906
N906 -{call data_overflow_016_good}-> N890
N890 -{%max = alloca i32, align 4}-> N892
N892 -{%ret = alloca i32, align 4}-> N894
N894 -{store i32 429496729, i32* %max, align 4}-> N896
N896 -{%0 = load i32, i32* %max, align 4}-> N897
N897 -{%mul = mul i32 5, %0}-> N898
N898 -{%add = add i32 %mul, 2}-> N899
N899 -{store i32 %add, i32* %ret, align 4}-> N900
N900 -{ret void}-> N889
N889 -{Return edge from data_overflow_016_good to main}-> N907
N907 -{call data_overflow_016_bad}-> N877
N877 -{%max = alloca i32, align 4}-> N879
N879 -{%ret = alloca i32, align 4}-> N881
N881 -{store i32 429496729, i32* %max, align 4}-> N883
N883 -{%0 = load i32, i32* %max, align 4}-> N884
N884 -{%mul = mul i32 5, %0}-> N885
N885 -{%add = add i32 %mul, 3}-> N886
N886 -{store i32 %add, i32* %ret, align 4}-> N887
N887 -{ret void}-> N876
N876 -{Return edge from data_overflow_016_bad to main}-> N908
N908 -{ret i32 0}-> N902
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N885
On edge  : N885 -{%add = add i32 %mul, 3}-> N886
Message  : integer overflow
> Start from entry function: main, At N903 of Function main
> Entering function: data_overflow_016_good, On N906 -> N890 (call data_overflow_016_good)
> Leaving function: data_overflow_016_good, On N889 -> N907 (Return edge from data_overflow_016_good to main)
> Entering function: data_overflow_016_bad, On N907 -> N877 (call data_overflow_016_bad)
<Defect> : N885 -> N886: [%add = add i32 %mul, 3]
N885 -> N886: [%add = add i32 %mul, 3] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_10.c 9] data_overflow_016_bad 		[N885 -{%add = add i32 %mul, 3}-> N886]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_017_bad]
 +data_overflow_017_bad
SCC(1): [data_overflow_017_good]
 +data_overflow_017_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, data_overflow_017_bad, data_overflow_017_good]
Loops     []
----
function: data_overflow_017_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_017_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.015s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N939): +oo]
> [1/1] entry: main ()
N939 -{%retval = alloca i32, align 4}-> N941
N941 -{store i32 0, i32* %retval, align 4}-> N942
N942 -{call data_overflow_017_good}-> N925
N925 -{%max = alloca i32, align 4}-> N927
N927 -{%ret = alloca i32, align 4}-> N929
N929 -{store i32 46340, i32* %max, align 4}-> N931
N931 -{%0 = load i32, i32* %max, align 4}-> N932
N932 -{%1 = load i32, i32* %max, align 4}-> N933
N933 -{%mul = mul i32 %0, %1}-> N934
N934 -{%add = add i32 %mul, 88047}-> N935
N935 -{store i32 %add, i32* %ret, align 4}-> N936
N936 -{ret void}-> N924
N924 -{Return edge from data_overflow_017_good to main}-> N943
N943 -{call data_overflow_017_bad}-> N911
N911 -{%max = alloca i32, align 4}-> N913
N913 -{%ret = alloca i32, align 4}-> N915
N915 -{store i32 46340, i32* %max, align 4}-> N917
N917 -{%0 = load i32, i32* %max, align 4}-> N918
N918 -{%1 = load i32, i32* %max, align 4}-> N919
N919 -{%mul = mul i32 %0, %1}-> N920
N920 -{%add = add i32 %mul, 88048}-> N921
N921 -{store i32 %add, i32* %ret, align 4}-> N922
N922 -{ret void}-> N910
N910 -{Return edge from data_overflow_017_bad to main}-> N944
N944 -{ret i32 0}-> N938
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N920
On edge  : N920 -{%add = add i32 %mul, 88048}-> N921
Message  : integer overflow
> Start from entry function: main, At N939 of Function main
> Entering function: data_overflow_017_good, On N942 -> N925 (call data_overflow_017_good)
> Leaving function: data_overflow_017_good, On N924 -> N943 (Return edge from data_overflow_017_good to main)
> Entering function: data_overflow_017_bad, On N943 -> N911 (call data_overflow_017_bad)
<Defect> : N920 -> N921: [%add = add i32 %mul, 88048]
N920 -> N921: [%add = add i32 %mul, 88048] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_11.c 9] data_overflow_017_bad 		[N920 -{%add = add i32 %mul, 88048}-> N921]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [data_overflow_018_func_001]
 +data_overflow_018_func_001
SCC(1): [data_overflow_018_bad]
 +data_overflow_018_bad
SCC(1): [data_overflow_018_good]
 +data_overflow_018_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_018_bad, data_overflow_018_func_001, data_overflow_018_good, main]
Loops     []
----
function: data_overflow_018_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_018_func_001
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: data_overflow_018_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N977): +oo]
> [1/1] entry: main ()
N977 -{%retval = alloca i32, align 4}-> N979
N979 -{store i32 0, i32* %retval, align 4}-> N980
N980 -{call data_overflow_018_good}-> N964
N964 -{%max = alloca i32, align 4}-> N966
N966 -{%ret = alloca i32, align 4}-> N968
N968 -{store i32 2147483646, i32* %max, align 4}-> N970
N970 -{%0 = load i32, i32* %max, align 4}-> N971
N971 -{call data_overflow_018_func_001}-> N960
N960 -{ret i32 1}-> N959
N959 -{Return edge from data_overflow_018_func_001 to data_overflow_018_good}-> N972
N972 -{%add = add i32 %0, %call}-> N973
N973 -{store i32 %add, i32* %ret, align 4}-> N974
N974 -{ret void}-> N963
N963 -{Return edge from data_overflow_018_good to main}-> N981
N981 -{call data_overflow_018_bad}-> N947
N947 -{%max = alloca i32, align 4}-> N949
N949 -{%ret = alloca i32, align 4}-> N951
N951 -{store i32 2147483647, i32* %max, align 4}-> N953
N953 -{%0 = load i32, i32* %max, align 4}-> N954
N954 -{call data_overflow_018_func_001}-> N960
N960 -{ret i32 1}-> N959
N959 -{Return edge from data_overflow_018_func_001 to data_overflow_018_bad}-> N955
N955 -{%add = add i32 %0, %call}-> N956
N956 -{store i32 %add, i32* %ret, align 4}-> N957
N957 -{ret void}-> N946
N946 -{Return edge from data_overflow_018_bad to main}-> N982
N982 -{ret i32 0}-> N976
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N955
On edge  : N955 -{%add = add i32 %0, %call}-> N956
Message  : integer overflow
> Start from entry function: main, At N977 of Function main
> Entering function: data_overflow_018_good, On N980 -> N964 (call data_overflow_018_good)
> Entering function: data_overflow_018_func_001, On N971 -> N960 (call data_overflow_018_func_001)
> Leaving function: data_overflow_018_func_001, On N959 -> N972 (Return edge from data_overflow_018_func_001 to data_overflow_018_good)
> Leaving function: data_overflow_018_good, On N963 -> N981 (Return edge from data_overflow_018_good to main)
> Entering function: data_overflow_018_bad, On N981 -> N947 (call data_overflow_018_bad)
> Entering function: data_overflow_018_func_001, On N954 -> N960 (call data_overflow_018_func_001)
> Leaving function: data_overflow_018_func_001, On N959 -> N955 (Return edge from data_overflow_018_func_001 to data_overflow_018_bad)
<Defect> : N955 -> N956: [%add = add i32 %0, %call]
N955 -> N956: [%add = add i32 %0, %call] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_12.c 14] data_overflow_018_bad 		[N955 -{%add = add i32 %0, %call}-> N956]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [data_overflow_019_func_001_bad]
 +data_overflow_019_func_001_bad
SCC(1): [data_overflow_019_bad]
 +data_overflow_019_bad
SCC(1): [data_overflow_019_func_001_good]
 +data_overflow_019_func_001_good
SCC(1): [data_overflow_019_good]
 +data_overflow_019_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_019_func_001_good, data_overflow_019_good, main, data_overflow_019_bad, data_overflow_019_func_001_bad]
Loops     []
----
function: data_overflow_019_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_019_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_019_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_019_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1027): +oo]
> [1/1] entry: main ()
N1027 -{%retval = alloca i32, align 4}-> N1029
N1029 -{store i32 0, i32* %retval, align 4}-> N1030
N1030 -{call data_overflow_019_good}-> N1022
N1022 -{call data_overflow_019_func_001_good}-> N1006
N1006 -{%d.addr = alloca i32, align 4}-> N1008
N1008 -{%max = alloca i32, align 4}-> N1009
N1009 -{%ret = alloca i32, align 4}-> N1010
N1010 -{store i32 %d, i32* %d.addr, align 4}-> N1013
N1013 -{store i32 2147483646, i32* %max, align 4}-> N1015
N1015 -{%0 = load i32, i32* %max, align 4}-> N1016
N1016 -{%1 = load i32, i32* %d.addr, align 4}-> N1017
N1017 -{%add = add i32 %0, %1}-> N1018
N1018 -{store i32 %add, i32* %ret, align 4}-> N1019
N1019 -{ret void}-> N1005
N1005 -{Return edge from data_overflow_019_func_001_good to data_overflow_019_good}-> N1024
N1024 -{ret void}-> N1021
N1021 -{Return edge from data_overflow_019_good to main}-> N1031
N1031 -{call data_overflow_019_bad}-> N985
N985 -{call data_overflow_019_func_001_bad}-> N990
N990 -{%d.addr = alloca i32, align 4}-> N992
N992 -{%max = alloca i32, align 4}-> N993
N993 -{%ret = alloca i32, align 4}-> N994
N994 -{store i32 %d, i32* %d.addr, align 4}-> N997
N997 -{store i32 2147483647, i32* %max, align 4}-> N999
N999 -{%0 = load i32, i32* %max, align 4}-> N1000
N1000 -{%1 = load i32, i32* %d.addr, align 4}-> N1001
N1001 -{%add = add i32 %0, %1}-> N1002
N1002 -{store i32 %add, i32* %ret, align 4}-> N1003
N1003 -{ret void}-> N989
N989 -{Return edge from data_overflow_019_func_001_bad to data_overflow_019_bad}-> N987
N987 -{ret void}-> N984
N984 -{Return edge from data_overflow_019_bad to main}-> N1032
N1032 -{ret i32 0}-> N1026
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1001
On edge  : N1001 -{%add = add i32 %0, %1}-> N1002
Message  : integer overflow
> Start from entry function: main, At N1027 of Function main
> Entering function: data_overflow_019_good, On N1030 -> N1022 (call data_overflow_019_good)
> Entering function: data_overflow_019_func_001_good, On N1022 -> N1006 (call data_overflow_019_func_001_good)
> Leaving function: data_overflow_019_func_001_good, On N1005 -> N1024 (Return edge from data_overflow_019_func_001_good to data_overflow_019_good)
> Leaving function: data_overflow_019_good, On N1021 -> N1031 (Return edge from data_overflow_019_good to main)
> Entering function: data_overflow_019_bad, On N1031 -> N985 (call data_overflow_019_bad)
> Entering function: data_overflow_019_func_001_bad, On N985 -> N990 (call data_overflow_019_func_001_bad)
<Defect> : N1001 -> N1002: [%add = add i32 %0, %1]
N1001 -> N1002: [%add = add i32 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_13.c 9] data_overflow_019_func_001_bad 		[N1001 -{%add = add i32 %0, %1}-> N1002]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_021_bad]
 +data_overflow_021_bad
SCC(1): [data_overflow_021_good]
 +data_overflow_021_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, data_overflow_021_bad, data_overflow_021_good]
Loops     []
----
function: data_overflow_021_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_021_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.002s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1075): +oo]
> [1/1] entry: main ()
N1075 -{%retval = alloca i32, align 4}-> N1077
N1077 -{store i32 0, i32* %retval, align 4}-> N1078
N1078 -{call data_overflow_021_good}-> N1055
N1055 -{%max = alloca i32, align 4}-> N1057
N1057 -{%d = alloca i32, align 4}-> N1058
N1058 -{%d1 = alloca i32, align 4}-> N1059
N1059 -{%ret = alloca i32, align 4}-> N1061
N1061 -{store i32 2147483646, i32* %max, align 4}-> N1063
N1063 -{store i32 1, i32* %d, align 4}-> N1066
N1066 -{%0 = load i32, i32* %d, align 4}-> N1067
N1067 -{store i32 %0, i32* %d1, align 4}-> N1068
N1068 -{%1 = load i32, i32* %max, align 4}-> N1069
N1069 -{%2 = load i32, i32* %d1, align 4}-> N1070
N1070 -{%add = add i32 %1, %2}-> N1071
N1071 -{store i32 %add, i32* %ret, align 4}-> N1072
N1072 -{ret void}-> N1054
N1054 -{Return edge from data_overflow_021_good to main}-> N1079
N1079 -{call data_overflow_021_bad}-> N1035
N1035 -{%max = alloca i32, align 4}-> N1037
N1037 -{%d = alloca i32, align 4}-> N1038
N1038 -{%d1 = alloca i32, align 4}-> N1039
N1039 -{%ret = alloca i32, align 4}-> N1041
N1041 -{store i32 2147483647, i32* %max, align 4}-> N1043
N1043 -{store i32 1, i32* %d, align 4}-> N1046
N1046 -{%0 = load i32, i32* %d, align 4}-> N1047
N1047 -{store i32 %0, i32* %d1, align 4}-> N1048
N1048 -{%1 = load i32, i32* %max, align 4}-> N1049
N1049 -{%2 = load i32, i32* %d1, align 4}-> N1050
N1050 -{%add = add i32 %1, %2}-> N1051
N1051 -{store i32 %add, i32* %ret, align 4}-> N1052
N1052 -{ret void}-> N1034
N1034 -{Return edge from data_overflow_021_bad to main}-> N1080
N1080 -{ret i32 0}-> N1074
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1050
On edge  : N1050 -{%add = add i32 %1, %2}-> N1051
Message  : integer overflow
> Start from entry function: main, At N1075 of Function main
> Entering function: data_overflow_021_good, On N1078 -> N1055 (call data_overflow_021_good)
> Leaving function: data_overflow_021_good, On N1054 -> N1079 (Return edge from data_overflow_021_good to main)
> Entering function: data_overflow_021_bad, On N1079 -> N1035 (call data_overflow_021_bad)
<Defect> : N1050 -> N1051: [%add = add i32 %1, %2]
N1050 -> N1051: [%add = add i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_14.c 12] data_overflow_021_bad 		[N1050 -{%add = add i32 %1, %2}-> N1051]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_022_bad]
 +data_overflow_022_bad
SCC(1): [data_overflow_022_good]
 +data_overflow_022_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, data_overflow_022_bad, data_overflow_022_good]
Loops     []
----
function: data_overflow_022_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_022_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.035s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1131): +oo]
> [1/1] entry: main ()
N1131 -{%retval = alloca i32, align 4}-> N1133
N1133 -{store i32 0, i32* %retval, align 4}-> N1134
N1134 -{call data_overflow_022_good}-> N1107
N1107 -{%max = alloca i32, align 4}-> N1109
N1109 -{%d = alloca i32, align 4}-> N1110
N1110 -{%d1 = alloca i32, align 4}-> N1111
N1111 -{%d2 = alloca i32, align 4}-> N1112
N1112 -{%ret = alloca i32, align 4}-> N1114
N1114 -{store i32 2147483646, i32* %max, align 4}-> N1116
N1116 -{store i32 1, i32* %d, align 4}-> N1120
N1120 -{%0 = load i32, i32* %d, align 4}-> N1121
N1121 -{store i32 %0, i32* %d1, align 4}-> N1122
N1122 -{%1 = load i32, i32* %d1, align 4}-> N1123
N1123 -{store i32 %1, i32* %d2, align 4}-> N1124
N1124 -{%2 = load i32, i32* %max, align 4}-> N1125
N1125 -{%3 = load i32, i32* %d2, align 4}-> N1126
N1126 -{%add = add i32 %2, %3}-> N1127
N1127 -{store i32 %add, i32* %ret, align 4}-> N1128
N1128 -{ret void}-> N1106
N1106 -{Return edge from data_overflow_022_good to main}-> N1135
N1135 -{call data_overflow_022_bad}-> N1083
N1083 -{%max = alloca i32, align 4}-> N1085
N1085 -{%d = alloca i32, align 4}-> N1086
N1086 -{%d1 = alloca i32, align 4}-> N1087
N1087 -{%d2 = alloca i32, align 4}-> N1088
N1088 -{%ret = alloca i32, align 4}-> N1090
N1090 -{store i32 2147483647, i32* %max, align 4}-> N1092
N1092 -{store i32 1, i32* %d, align 4}-> N1096
N1096 -{%0 = load i32, i32* %d, align 4}-> N1097
N1097 -{store i32 %0, i32* %d1, align 4}-> N1098
N1098 -{%1 = load i32, i32* %d1, align 4}-> N1099
N1099 -{store i32 %1, i32* %d2, align 4}-> N1100
N1100 -{%2 = load i32, i32* %max, align 4}-> N1101
N1101 -{%3 = load i32, i32* %d2, align 4}-> N1102
N1102 -{%add = add i32 %2, %3}-> N1103
N1103 -{store i32 %add, i32* %ret, align 4}-> N1104
N1104 -{ret void}-> N1082
N1082 -{Return edge from data_overflow_022_bad to main}-> N1136
N1136 -{ret i32 0}-> N1130
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1102
On edge  : N1102 -{%add = add i32 %2, %3}-> N1103
Message  : integer overflow
> Start from entry function: main, At N1131 of Function main
> Entering function: data_overflow_022_good, On N1134 -> N1107 (call data_overflow_022_good)
> Leaving function: data_overflow_022_good, On N1106 -> N1135 (Return edge from data_overflow_022_good to main)
> Entering function: data_overflow_022_bad, On N1135 -> N1083 (call data_overflow_022_bad)
<Defect> : N1102 -> N1103: [%add = add i32 %2, %3]
N1102 -> N1103: [%add = add i32 %2, %3] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_15.c 14] data_overflow_022_bad 		[N1102 -{%add = add i32 %2, %3}-> N1103]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/190/190_data_overflow_16.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [data_overflow_020_bad]
 +data_overflow_020_bad
SCC(1): [data_overflow_020_good]
 +data_overflow_020_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [data_overflow_020_bad, data_overflow_020_good, main]
Loops     []
----
function: data_overflow_020_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: data_overflow_020_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1175): +oo]
> [1/1] entry: main ()
N1175 -{global: data_overflow_020_bad.dlist}-> N1183
N1183 -{global: data_overflow_020_good.dlist}-> N1182
N1182 -{%retval = alloca i32, align 4}-> N1177
N1177 -{store i32 0, i32* %retval, align 4}-> N1178
N1178 -{call data_overflow_020_good}-> N1157
N1157 -{%max = alloca i32, align 4}-> N1159
N1159 -{%dlist = alloca [4 x i32], align 16}-> N1160
N1160 -{%ret = alloca i32, align 4}-> N1162
N1162 -{store i32 2147483646, i32* %max, align 4}-> N1164
N1164 -{%0 = bitcast [4 x i32]* %dlist to i8*}-> N1165
N1165 -{call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([4 x i32]* @data_overflow_020_good.dlist to i8*), i8* 16, i8* 16, i8* false, i8* @llvm.memcpy.p0i8.p0i8.i64)}-> N1167
N1167 -{%1 = load i32, i32* %max, align 4}-> N1168
N1168 -{%arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %dlist, i64 0, i64 1}-> N1169
N1169 -{%2 = load i32, i32* %arrayidx, align 4}-> N1170
N1170 -{%add = add i32 %1, %2}-> N1171
N1171 -{store i32 %add, i32* %ret, align 4}-> N1172
N1172 -{ret void}-> N1156
N1156 -{Return edge from data_overflow_020_good to main}-> N1179
N1179 -{call data_overflow_020_bad}-> N1139
N1139 -{%max = alloca i32, align 4}-> N1141
N1141 -{%dlist = alloca [4 x i32], align 16}-> N1142
N1142 -{%ret = alloca i32, align 4}-> N1144
N1144 -{store i32 2147483647, i32* %max, align 4}-> N1146
N1146 -{%0 = bitcast [4 x i32]* %dlist to i8*}-> N1147
N1147 -{call void @llvm.memcpy.p0i8.p0i8.i64(i8* %0, i8* bitcast ([4 x i32]* @data_overflow_020_bad.dlist to i8*), i8* 16, i8* 16, i8* false, i8* @llvm.memcpy.p0i8.p0i8.i64)}-> N1149
N1149 -{%1 = load i32, i32* %max, align 4}-> N1150
N1150 -{%arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %dlist, i64 0, i64 1}-> N1151
N1151 -{%2 = load i32, i32* %arrayidx, align 4}-> N1152
N1152 -{%add = add i32 %1, %2}-> N1153
N1153 -{store i32 %add, i32* %ret, align 4}-> N1154
N1154 -{ret void}-> N1138
N1138 -{Return edge from data_overflow_020_bad to main}-> N1180
N1180 -{ret i32 0}-> N1174
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1152
On edge  : N1152 -{%add = add i32 %1, %2}-> N1153
Message  : integer overflow
> Start from entry function: main, At N1175 of Function main
> Entering function: data_overflow_020_good, On N1178 -> N1157 (call data_overflow_020_good)
> Leaving function: data_overflow_020_good, On N1156 -> N1179 (Return edge from data_overflow_020_good to main)
> Entering function: data_overflow_020_bad, On N1179 -> N1139 (call data_overflow_020_bad)
<Defect> : N1152 -> N1153: [%add = add i32 %1, %2]
N1152 -> N1153: [%add = add i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_data_overflow_16.c 10] data_overflow_020_bad 		[N1152 -{%add = add i32 %1, %2}-> N1153]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 0
