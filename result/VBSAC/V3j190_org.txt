/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=41888:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.Juliet_190_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
4 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad1]
 +bad1
SCC(1): [good1]
 +good1
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, bad1, good1]
Loops     []
----
function: bad1
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good1
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.207s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N36): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N12
On edge  : N12 -{%conv1 = trunc i32 %add to i8}-> N13
Message  : integer overflow
> Start from entry function: main, At N36 of Function main
> Entering function: good1, On N51 -> N19 (call good1)
> Entering function: printHexCharLine, On N32 -> N42 (call printHexCharLine)
> Leaving function: printHexCharLine, On N41 -> N33 (Return edge from printHexCharLine to good1)
> Leaving function: good1, On N18 -> N38 (Return edge from good1 to main)
> Entering function: bad1, On N38 -> N1 (call bad1)
<Defect> : N12 -> N13: [%conv1 = trunc i32 %add to i8]
N12 -> N13: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_1.c 26] bad1 		[N12 -{%conv1 = trunc i32 %add to i8}-> N13]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad2]
 +bad2
SCC(1): [printLine]
 +printLine
SCC(1): [good2]
 +good2
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad2, good2]
Loops     []
----
function: bad2
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good2
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.125s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N114): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N70
On edge  : N70 -{%conv3 = trunc i32 %mul to i8}-> N71
Message  : integer overflow
> Start from entry function: main, At N114 of Function main
> Entering function: good2, On N162 -> N80 (call good2)
> takes the false branch, At N90 of Function good2
> Leaving function: good2, On N79 -> N116 (Return edge from good2 to main)
> Entering function: bad2, On N116 -> N55 (call bad2)
> takes the true branch, At N65 of Function bad2
<Defect> : N70 -> N71: [%conv3 = trunc i32 %mul to i8]
N70 -> N71: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_2.c 51] bad2 		[N70 -{%conv3 = trunc i32 %mul to i8}-> N71]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad3]
 +bad3
SCC(1): [printLine]
 +printLine
SCC(1): [good3]
 +good3
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printHexCharLine, printIntLine, printLine, printLongLine, bad3, good3, main]
Loops     []
----
function: bad3
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good3
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.016s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N221): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N182
On edge  : N182 -{%conv2 = trunc i32 %mul to i8}-> N183
Message  : integer overflow
> Start from entry function: main, At N221 of Function main
> Entering function: good3, On N269 -> N189 (call good3)
> takes the false branch, At N202 of Function good3
> Entering function: printLine, On N219 -> N246 (call printLine)
> takes the true branch, At N252 of Function printLine
> Leaving function: printLine, On N245 -> N216 (Return edge from printLine to good3)
> Leaving function: good3, On N188 -> N223 (Return edge from good3 to main)
> Entering function: bad3, On N223 -> N169 (call bad3)
<Defect> : N182 -> N183: [%conv2 = trunc i32 %mul to i8]
N182 -> N183: [%conv2 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_3.c 50] bad3 		[N182 -{%conv2 = trunc i32 %mul to i8}-> N183]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad4]
 +bad4
SCC(1): [printLine]
 +printLine
SCC(1): [good4]
 +good4
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad4, good4, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad4
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good4
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.016s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N319): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N286
On edge  : N286 -{%conv1 = trunc i32 %add to i8}-> N287
Message  : integer overflow
> Start from entry function: main, At N319 of Function main
> Entering function: good4, On N367 -> N293 (call good4)
> takes the false branch, At N302 of Function good4
> Entering function: printLine, On N317 -> N344 (call printLine)
> takes the true branch, At N350 of Function printLine
> Leaving function: printLine, On N343 -> N314 (Return edge from printLine to good4)
> Leaving function: good4, On N292 -> N321 (Return edge from good4 to main)
> Entering function: bad4, On N321 -> N276 (call bad4)
<Defect> : N286 -> N287: [%conv1 = trunc i32 %add to i8]
N286 -> N287: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_4.c 53] bad4 		[N286 -{%conv1 = trunc i32 %add to i8}-> N287]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad5]
 +bad5
SCC(1): [printLine]
 +printLine
SCC(1): [good5]
 +good5
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad5, good5, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad5
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good5
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.013s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N455): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N393
On edge  : N393 -{%conv6 = trunc i32 %mul to i8}-> N394
Message  : integer overflow
> Start from entry function: main, At N455 of Function main
> Entering function: good5, On N503 -> N408 (call good5)
> takes the true branch, At N415 of Function good5
> takes the false branch, At N420 of Function good5
> takes the true branch, At N426 of Function good5
> takes the false branch, At N430 of Function good5
> Entering function: printLine, On N453 -> N480 (call printLine)
> takes the true branch, At N486 of Function printLine
> Leaving function: printLine, On N479 -> N444 (Return edge from printLine to good5)
> Leaving function: good5, On N407 -> N457 (Return edge from good5 to main)
> Entering function: bad5, On N457 -> N372 (call bad5)
> takes the true branch, At N379 of Function bad5
> takes the true branch, At N384 of Function bad5
> takes the true branch, At N388 of Function bad5
<Defect> : N393 -> N394: [%conv6 = trunc i32 %mul to i8]
N393 -> N394: [%conv6 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_5.c 54] bad5 		[N393 -{%conv6 = trunc i32 %mul to i8}-> N394]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad6]
 +bad6
SCC(1): [printLine]
 +printLine
SCC(1): [good6]
 +good6
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad6, good6, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad6
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good6
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.016s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N561): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N523
On edge  : N523 -{%conv2 = trunc i32 %mul to i8}-> N524
Message  : integer overflow
> Start from entry function: main, At N561 of Function main
> Entering function: good6, On N609 -> N530 (call good6)
> takes the false branch, At N542 of Function good6
> Entering function: printLine, On N559 -> N586 (call printLine)
> takes the true branch, At N592 of Function printLine
> Leaving function: printLine, On N585 -> N556 (Return edge from printLine to good6)
> Leaving function: good6, On N529 -> N563 (Return edge from good6 to main)
> Entering function: bad6, On N563 -> N511 (call bad6)
<Defect> : N523 -> N524: [%conv2 = trunc i32 %mul to i8]
N523 -> N524: [%conv2 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_6.c 52] bad6 		[N523 -{%conv2 = trunc i32 %mul to i8}-> N524]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad7]
 +bad7
SCC(1): [printLine]
 +printLine
SCC(1): [good7]
 +good7
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad7, good7, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad7
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good7
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N715): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N645
On edge  : N645 -{%conv12 = trunc i32 %add to i8}-> N646
Message  : integer overflow
> Start from entry function: main, At N715 of Function main
> Entering function: good7, On N763 -> N659 (call good7)
> takes the true branch, At N666 of Function good7
> takes the false branch, At N673 of Function good7
> Entering function: printHexCharLine, On N681 -> N721 (call printHexCharLine)
> Leaving function: printHexCharLine, On N720 -> N683 (Return edge from printHexCharLine to good7)
> takes the false branch, At N685 of Function good7
> takes the false branch, At N691 of Function good7
> Entering function: printLine, On N713 -> N740 (call printLine)
> takes the true branch, At N746 of Function printLine
> Leaving function: printLine, On N739 -> N704 (Return edge from printLine to good7)
> Leaving function: good7, On N658 -> N717 (Return edge from good7 to main)
> Entering function: bad7, On N717 -> N614 (call bad7)
> takes the true branch, At N621 of Function bad7
> takes the false branch, At N628 of Function bad7
> Entering function: printHexCharLine, On N636 -> N721 (call printHexCharLine)
> Leaving function: printHexCharLine, On N720 -> N638 (Return edge from printHexCharLine to bad7)
> takes the true branch, At N640 of Function bad7
<Defect> : N645 -> N646: [%conv12 = trunc i32 %add to i8]
N645 -> N646: [%conv12 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_7.c 57] bad7 		[N645 -{%conv12 = trunc i32 %add to i8}-> N646]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad8]
 +bad8
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good8]
 +good8
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad8, good8, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue]
Loops     []
----
function: bad8
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good8
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N881): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N803
On edge  : N803 -{%conv16 = trunc i32 %mul to i8}-> N804
Message  : integer overflow
> Start from entry function: main, At N881 of Function main
> Entering function: good8, On N937 -> N820 (call good8)
> Entering function: staticReturnsTrue, On N825 -> N934 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N933 -> N826 (Return edge from staticReturnsTrue to good8)
> takes the true branch, At N827 of Function good8
> takes the false branch, At N834 of Function good8
> Entering function: staticReturnsFalse, On N842 -> N930 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N929 -> N843 (Return edge from staticReturnsFalse to good8)
> takes the false branch, At N844 of Function good8
> takes the false branch, At N850 of Function good8
> Leaving function: good8, On N819 -> N883 (Return edge from good8 to main)
> Entering function: bad8, On N883 -> N770 (call bad8)
> Entering function: staticReturnsTrue, On N775 -> N934 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N933 -> N776 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N777 of Function bad8
> takes the false branch, At N784 of Function bad8
> Entering function: staticReturnsTrue, On N792 -> N934 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N933 -> N793 (Return edge from staticReturnsTrue to bad8)
> takes the true branch, At N794 of Function bad8
> takes the true branch, At N798 of Function bad8
<Defect> : N803 -> N804: [%conv16 = trunc i32 %mul to i8]
N803 -> N804: [%conv16 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_8.c 65] bad8 		[N803 -{%conv16 = trunc i32 %mul to i8}-> N804]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad9]
 +bad9
SCC(1): [printLine]
 +printLine
SCC(1): [good9]
 +good9
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad9, good9]
Loops     []
----
function: bad9
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good9
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.024s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1021): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N967
On edge  : N967 -{%conv7 = trunc i32 %mul to i8}-> N968
Message  : integer overflow
> Start from entry function: main, At N1021 of Function main
> Entering function: good9, On N1069 -> N976 (call good9)
> takes the false branch, At N987 of Function good9
> takes the false branch, At N1000 of Function good9
> Entering function: printLine, On N1019 -> N1046 (call printLine)
> takes the true branch, At N1052 of Function printLine
> Leaving function: printLine, On N1045 -> N1014 (Return edge from printLine to good9)
> Leaving function: good9, On N975 -> N1023 (Return edge from good9 to main)
> Entering function: bad9, On N1023 -> N943 (call bad9)
> takes the false branch, At N954 of Function bad9
<Defect> : N967 -> N968: [%conv7 = trunc i32 %mul to i8]
N967 -> N968: [%conv7 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_9.c 58] bad9 		[N967 -{%conv7 = trunc i32 %mul to i8}-> N968]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad10]
 +bad10
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good10]
 +good10
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [bad10, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good10, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad10
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good10
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1157): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1093
On edge  : N1093 -{%add = add i64 %3, 1}-> N1094
Message  : integer overflow
> Start from entry function: main, At N1157 of Function main
> Entering function: good10, On N1205 -> N1119 (call good10)
> takes the true branch, At N1126 of Function good10
> takes the false branch, At N1132 of Function good10
> takes the false branch, At N1137 of Function good10
> Entering function: printLine, On N1155 -> N1182 (call printLine)
> takes the true branch, At N1188 of Function printLine
> Leaving function: printLine, On N1181 -> N1148 (Return edge from printLine to good10)
> Leaving function: good10, On N1118 -> N1159 (Return edge from good10 to main)
> Entering function: bad10, On N1159 -> N1077 (call bad10)
> takes the true branch, At N1084 of Function bad10
> takes the true branch, At N1090 of Function bad10
<Defect> : N1093 -> N1094: [%add = add i64 %3, 1]
N1093 -> N1094: [%add = add i64 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_10.c 75] bad10 		[N1093 -{%add = add i64 %3, 1}-> N1094]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad11]
 +bad11
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good11]
 +good11
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good11, main, printHexCharLine, printIntLine, printLine, printLongLine, bad11]
Loops     []
----
function: bad11
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good11
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1311): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1238
On edge  : N1238 -{%mul = mul i64 %2, 2}-> N1239
Message  : integer overflow
> Start from entry function: main, At N1311 of Function main
> Entering function: good11, On N1359 -> N1267 (call good11)
> Entering function: globalReturnsTrue, On N1272 -> N1257 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N1256 -> N1273 (Return edge from globalReturnsTrue to good11)
> takes the true branch, At N1274 of Function good11
> Entering function: globalReturnsFalse, On N1278 -> N1253 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N1252 -> N1279 (Return edge from globalReturnsFalse to good11)
> takes the false branch, At N1280 of Function good11
> takes the false branch, At N1285 of Function good11
> Leaving function: good11, On N1266 -> N1313 (Return edge from good11 to main)
> Entering function: bad11, On N1313 -> N1219 (call bad11)
> Entering function: globalReturnsTrue, On N1224 -> N1257 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N1256 -> N1225 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N1226 of Function bad11
> Entering function: globalReturnsTrue, On N1230 -> N1257 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N1256 -> N1231 (Return edge from globalReturnsTrue to bad11)
> takes the true branch, At N1232 of Function bad11
> takes the true branch, At N1235 of Function bad11
<Defect> : N1238 -> N1239: [%mul = mul i64 %2, 2]
N1238 -> N1239: [%mul = mul i64 %2, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_11.c 77] bad11 		[N1238 -{%mul = mul i64 %2, 2}-> N1239]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad12]
 +bad12
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good12]
 +good12
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [printHexCharLine, printIntLine, printLine, printLongLine, bad12, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good12, main]
Loops     []
----
function: bad12
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good12
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1501): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N1482
On edge  : N1482 -{%mul20 = mul i64 %7, %8}-> N1483
Message  : integer underflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1455 of Function good12
> takes the true branch, At N1478 of Function good12
<Defect> : N1482 -> N1483: [%mul20 = mul i64 %7, %8]
N1482 -> N1483: [%mul20 = mul i64 %7, %8] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N1465
On edge  : N1465 -{%mul = mul i64 %3, %4}-> N1466
Message  : integer underflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the true branch, At N1455 of Function good12
> takes the true branch, At N1461 of Function good12
<Defect> : N1465 -> N1466: [%mul = mul i64 %3, %4]
N1465 -> N1466: [%mul = mul i64 %3, %4] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N1407
On edge  : N1407 -{%mul11 = mul i64 %5, %6}-> N1408
Message  : integer underflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1455 of Function good12
> takes the true branch, At N1478 of Function good12
> Entering function: printLongLine, On N1485 -> N1541 (call printLongLine)
> Leaving function: printLongLine, On N1540 -> N1490 (Return edge from printLongLine to good12)
> Leaving function: good12, On N1437 -> N1503 (Return edge from good12 to main)
> Entering function: bad12, On N1503 -> N1373 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N1379 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1380 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N1381 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N1387 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1388 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N1389 of Function bad12
> takes the true branch, At N1403 of Function bad12
<Defect> : N1407 -> N1408: [%mul11 = mul i64 %5, %6]
N1407 -> N1408: [%mul11 = mul i64 %5, %6] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N1393
On edge  : N1393 -{%mul = mul i64 %1, %2}-> N1394
Message  : integer underflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1455 of Function good12
> takes the true branch, At N1478 of Function good12
> Entering function: printLongLine, On N1485 -> N1541 (call printLongLine)
> Leaving function: printLongLine, On N1540 -> N1490 (Return edge from printLongLine to good12)
> Leaving function: good12, On N1437 -> N1503 (Return edge from good12 to main)
> Entering function: bad12, On N1503 -> N1373 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N1379 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1380 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N1381 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N1387 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1388 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N1389 of Function bad12
<Defect> : N1393 -> N1394: [%mul = mul i64 %1, %2]
N1393 -> N1394: [%mul = mul i64 %1, %2] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N1482
On edge  : N1482 -{%mul20 = mul i64 %7, %8}-> N1483
Message  : integer overflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1455 of Function good12
> takes the true branch, At N1478 of Function good12
<Defect> : N1482 -> N1483: [%mul20 = mul i64 %7, %8]
N1482 -> N1483: [%mul20 = mul i64 %7, %8] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N1465
On edge  : N1465 -{%mul = mul i64 %3, %4}-> N1466
Message  : integer overflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the true branch, At N1455 of Function good12
> takes the true branch, At N1461 of Function good12
<Defect> : N1465 -> N1466: [%mul = mul i64 %3, %4]
N1465 -> N1466: [%mul = mul i64 %3, %4] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N1407
On edge  : N1407 -{%mul11 = mul i64 %5, %6}-> N1408
Message  : integer overflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1455 of Function good12
> takes the true branch, At N1478 of Function good12
> Entering function: printLongLine, On N1485 -> N1541 (call printLongLine)
> Leaving function: printLongLine, On N1540 -> N1490 (Return edge from printLongLine to good12)
> Leaving function: good12, On N1437 -> N1503 (Return edge from good12 to main)
> Entering function: bad12, On N1503 -> N1373 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N1379 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1380 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N1381 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N1387 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1388 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N1389 of Function bad12
> takes the true branch, At N1403 of Function bad12
<Defect> : N1407 -> N1408: [%mul11 = mul i64 %5, %6]
N1407 -> N1408: [%mul11 = mul i64 %5, %6] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N1393
On edge  : N1393 -{%mul = mul i64 %1, %2}-> N1394
Message  : integer overflow
> Start from entry function: main, At N1501 of Function main
> Entering function: good12, On N1549 -> N1438 (call good12)
> Entering function: globalReturnsTrueOrFalse, On N1444 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1445 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1446 of Function good12
> Entering function: globalReturnsTrueOrFalse, On N1453 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1454 (Return edge from globalReturnsTrueOrFalse to good12)
> takes the false branch, At N1455 of Function good12
> takes the true branch, At N1478 of Function good12
> Entering function: printLongLine, On N1485 -> N1541 (call printLongLine)
> Leaving function: printLongLine, On N1540 -> N1490 (Return edge from printLongLine to good12)
> Leaving function: good12, On N1437 -> N1503 (Return edge from good12 to main)
> Entering function: bad12, On N1503 -> N1373 (call bad12)
> Entering function: globalReturnsTrueOrFalse, On N1379 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1380 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the false branch, At N1381 of Function bad12
> Entering function: globalReturnsTrueOrFalse, On N1387 -> N1432 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N1431 -> N1388 (Return edge from globalReturnsTrueOrFalse to bad12)
> takes the true branch, At N1389 of Function bad12
<Defect> : N1393 -> N1394: [%mul = mul i64 %1, %2]
N1393 -> N1394: [%mul = mul i64 %1, %2] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 4
	[./190_12.c 132] good12 		[N1482 -{%mul20 = mul i64 %7, %8}-> N1483]	(integer underflow)
	[./190_12.c 119] good12 		[N1465 -{%mul = mul i64 %3, %4}-> N1466]	(integer underflow)
	[./190_12.c 90] bad12 		[N1407 -{%mul11 = mul i64 %5, %6}-> N1408]	(integer underflow)
	[./190_12.c 81] bad12 		[N1393 -{%mul = mul i64 %1, %2}-> N1394]	(integer underflow)

CWE_190(Integer Overflow): 4
	[./190_12.c 132] good12 		[N1482 -{%mul20 = mul i64 %7, %8}-> N1483]	(integer overflow)
	[./190_12.c 119] good12 		[N1465 -{%mul = mul i64 %3, %4}-> N1466]	(integer overflow)
	[./190_12.c 90] bad12 		[N1407 -{%mul11 = mul i64 %5, %6}-> N1408]	(integer overflow)
	[./190_12.c 81] bad12 		[N1393 -{%mul = mul i64 %1, %2}-> N1394]	(integer overflow)

Found 8 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :4
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.lambda$juliet_190_12$11(Juliet_190_Test.java:178)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.juliet_190_12(Juliet_190_Test.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad13]
 +bad13
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good13]
 +good13
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [printLine, printLongLine, bad13, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good13, main, printHexCharLine, printIntLine]
Loops     []
----
function: bad13
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good13
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1614): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1570
On edge  : N1570 -{%add = add i64 %0, 1}-> N1571
Message  : integer overflow
> Start from entry function: main, At N1614 of Function main
> Entering function: good13, On N1662 -> N1591 (call good13)
> takes the false branch, At N1599 of Function good13
> Entering function: printLine, On N1612 -> N1639 (call printLine)
> takes the true branch, At N1645 of Function printLine
> Leaving function: printLine, On N1638 -> N1609 (Return edge from printLine to good13)
> Leaving function: good13, On N1590 -> N1616 (Return edge from good13 to main)
> Entering function: bad13, On N1616 -> N1562 (call bad13)
<Defect> : N1570 -> N1571: [%add = add i64 %0, 1]
N1570 -> N1571: [%add = add i64 %0, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_13.c 76] bad13 		[N1570 -{%add = add i64 %0, 1}-> N1571]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad14]
 +bad14
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good14]
 +good14
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad14, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good14]
Loops     []
----
function: bad14
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good14
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.049s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1763): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1691
On edge  : N1691 -{%mul = mul i64 %3, 2}-> N1692
Message  : integer overflow
> Start from entry function: main, At N1763 of Function main
> Entering function: good14, On N1811 -> N1720 (call good14)
> takes the true branch, At N1727 of Function good14
> takes the false branch, At N1732 of Function good14
> takes the true branch, At N1737 of Function good14
> takes the false branch, At N1740 of Function good14
> Entering function: printLine, On N1761 -> N1788 (call printLine)
> takes the true branch, At N1794 of Function printLine
> Leaving function: printLine, On N1787 -> N1752 (Return edge from printLine to good14)
> Leaving function: good14, On N1719 -> N1765 (Return edge from good14 to main)
> Entering function: bad14, On N1765 -> N1673 (call bad14)
> takes the true branch, At N1680 of Function bad14
> takes the true branch, At N1685 of Function bad14
> takes the true branch, At N1688 of Function bad14
<Defect> : N1691 -> N1692: [%mul = mul i64 %3, 2]
N1691 -> N1692: [%mul = mul i64 %3, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_14.c 77] bad14 		[N1691 -{%mul = mul i64 %3, 2}-> N1692]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printLongLine]
 +printLongLine
SCC(1): [bad15]
 +bad15
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good15]
 +good15
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printIntLine]
 +printIntLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad15, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good15, main, printHexCharLine]
Loops     []
----
function: bad15
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good15
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1880): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1868
On edge  : N1868 -{%mul = mul i64 %1, %2}-> N1869
Message  : integer overflow
> Start from entry function: main, At N1880 of Function main
> Entering function: good15, On N1928 -> N1853 (call good15)
> takes the true branch, At N1864 of Function good15
<Defect> : N1868 -> N1869: [%mul = mul i64 %1, %2]
N1868 -> N1869: [%mul = mul i64 %1, %2] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N1832
On edge  : N1832 -{%mul = mul i64 %0, %1}-> N1833
Message  : integer overflow
> Start from entry function: main, At N1880 of Function main
> Entering function: good15, On N1928 -> N1853 (call good15)
> takes the true branch, At N1864 of Function good15
> Entering function: printLongLine, On N1871 -> N1920 (call printLongLine)
> Leaving function: printLongLine, On N1919 -> N1875 (Return edge from printLongLine to good15)
> Leaving function: good15, On N1852 -> N1882 (Return edge from good15 to main)
> Entering function: bad15, On N1882 -> N1823 (call bad15)
<Defect> : N1832 -> N1833: [%mul = mul i64 %0, %1]
N1832 -> N1833: [%mul = mul i64 %0, %1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 2
	[./190_15.c 119] good15 		[N1868 -{%mul = mul i64 %1, %2}-> N1869]	(integer overflow)
	[./190_15.c 83] bad15 		[N1832 -{%mul = mul i64 %0, %1}-> N1833]	(integer overflow)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.lambda$juliet_190_15$14(Juliet_190_Test.java:214)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.juliet_190_15(Juliet_190_Test.java:213)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_16.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad16]
 +bad16
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good16]
 +good16
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad16, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good16, main, printHexCharLine]
Loops     []
----
function: bad16
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good16
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.027s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2001): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N1951
On edge  : N1951 -{%add = add i32 %1, 1}-> N1952
Message  : integer overflow
> Start from entry function: main, At N2001 of Function main
> Entering function: good16, On N2049 -> N1973 (call good16)
> takes the false branch, At N1985 of Function good16
> Entering function: printLine, On N1999 -> N2026 (call printLine)
> takes the true branch, At N2032 of Function printLine
> Leaving function: printLine, On N2025 -> N1996 (Return edge from printLine to good16)
> Leaving function: good16, On N1972 -> N2003 (Return edge from good16 to main)
> Entering function: bad16, On N2003 -> N1939 (call bad16)
<Defect> : N1951 -> N1952: [%add = add i32 %1, 1]
N1951 -> N1952: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_16.c 78] bad16 		[N1951 -{%add = add i32 %1, 1}-> N1952]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_17.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad17]
 +bad17
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good17]
 +good17
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad17, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good17, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     [N2099, N2164, N2137, N2073]
----
function: bad17
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good17
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N2073 in bad17: 
N2073 -> P+ = [], P- = [] Point-To: 
N2075 -> P+ = [], P- = [] Point-To: 
----
loop N2099 in bad17: 
N2085 -> P+ = [], P- = [] Point-To: 
N2087 -> P+ = [], P- = [] Point-To: 
----
loop N2137 in good17: 
N2137 -> P+ = [], P- = [] Point-To: 
N2139 -> P+ = [], P- = [] Point-To: 
----
loop N2164 in good17: 
N2149 -> P+ = [], P- = [] Point-To: 
N2151 -> P+ = [], P- = [] Point-To: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.053s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2177): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N2093
On edge  : N2093 -{%mul = mul i32 %5, 2}-> N2094
Message  : integer overflow
> Start from entry function: main, At N2177 of Function main
> Entering function: good17, On N2225 -> N2126 (call good17)
> takes the true branch, At N2139 of Function good17
> takes the false branch, At N2139 of Function good17
> takes the true branch, At N2151 of Function good17
> takes the true branch, At N2155 of Function good17
> Entering function: printIntLine, On N2161 -> N2193 (call printIntLine)
> Leaving function: printIntLine, On N2192 -> N2164 (Return edge from printIntLine to good17)
> takes the false branch, At N2151 of Function good17
> Leaving function: good17, On N2125 -> N2179 (Return edge from good17 to main)
> Entering function: bad17, On N2179 -> N2062 (call bad17)
> takes the true branch, At N2075 of Function bad17
> takes the false branch, At N2075 of Function bad17
> takes the true branch, At N2087 of Function bad17
> takes the true branch, At N2090 of Function bad17
<Defect> : N2093 -> N2094: [%mul = mul i32 %5, 2]
N2093 -> N2094: [%mul = mul i32 %5, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_17.c 79] bad17 		[N2093 -{%mul = mul i32 %5, 2}-> N2094]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_18.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad18]
 +bad18
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good18]
 +good18
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad18, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good18]
Loops     []
----
function: bad18
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good18
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.022s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2301): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Underflow
At node  : N2289
On edge  : N2289 -{%mul = mul i32 %2, %3}-> N2290
Message  : integer underflow
> Start from entry function: main, At N2301 of Function main
> Entering function: good18, On N2349 -> N2270 (call good18)
> takes the true branch, At N2285 of Function good18
<Defect> : N2289 -> N2290: [%mul = mul i32 %2, %3]
N2289 -> N2290: [%mul = mul i32 %2, %3] <--
-- end of trace --
-- start of trace --
Weakness : Integer Underflow
At node  : N2249
On edge  : N2249 -{%mul = mul i32 %1, %2}-> N2250
Message  : integer underflow
> Start from entry function: main, At N2301 of Function main
> Entering function: good18, On N2349 -> N2270 (call good18)
> takes the true branch, At N2285 of Function good18
> Entering function: printIntLine, On N2292 -> N2317 (call printIntLine)
> Leaving function: printIntLine, On N2316 -> N2296 (Return edge from printIntLine to good18)
> Leaving function: good18, On N2269 -> N2303 (Return edge from good18 to main)
> Entering function: bad18, On N2303 -> N2237 (call bad18)
<Defect> : N2249 -> N2250: [%mul = mul i32 %1, %2]
N2249 -> N2250: [%mul = mul i32 %1, %2] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N2289
On edge  : N2289 -{%mul = mul i32 %2, %3}-> N2290
Message  : integer overflow
> Start from entry function: main, At N2301 of Function main
> Entering function: good18, On N2349 -> N2270 (call good18)
> takes the true branch, At N2285 of Function good18
<Defect> : N2289 -> N2290: [%mul = mul i32 %2, %3]
N2289 -> N2290: [%mul = mul i32 %2, %3] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N2249
On edge  : N2249 -{%mul = mul i32 %1, %2}-> N2250
Message  : integer overflow
> Start from entry function: main, At N2301 of Function main
> Entering function: good18, On N2349 -> N2270 (call good18)
> takes the true branch, At N2285 of Function good18
> Entering function: printIntLine, On N2292 -> N2317 (call printIntLine)
> Leaving function: printIntLine, On N2316 -> N2296 (Return edge from printIntLine to good18)
> Leaving function: good18, On N2269 -> N2303 (Return edge from good18 to main)
> Entering function: bad18, On N2303 -> N2237 (call bad18)
<Defect> : N2249 -> N2250: [%mul = mul i32 %1, %2]
N2249 -> N2250: [%mul = mul i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_191(Integer Underflow): 2
	[./190_18.c 95] good18 		[N2289 -{%mul = mul i32 %2, %3}-> N2290]	(integer underflow)
	[./190_18.c 76] bad18 		[N2249 -{%mul = mul i32 %1, %2}-> N2250]	(integer underflow)

CWE_190(Integer Overflow): 2
	[./190_18.c 95] good18 		[N2289 -{%mul = mul i32 %2, %3}-> N2290]	(integer overflow)
	[./190_18.c 76] bad18 		[N2249 -{%mul = mul i32 %1, %2}-> N2250]	(integer overflow)

Found 4 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.lambda$juliet_190_18$17(Juliet_190_Test.java:250)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.juliet_190_18(Juliet_190_Test.java:249)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_19.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
12 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad19]
 +bad19
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good19]
 +good19
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad19, badSink, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good19, goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad19
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good19
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2448): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N2383
On edge  : N2383 -{%add = add i32 %1, 1}-> N2384
Message  : integer overflow
> Start from entry function: main, At N2448 of Function main
> Entering function: good19, On N2496 -> N2407 (call good19)
> Entering function: goodSink, On N2414 -> N2418 (call goodSink)
> takes the false branch, At N2425 of Function goodSink
> takes the false branch, At N2430 of Function goodSink
> Entering function: printLine, On N2446 -> N2473 (call printLine)
> takes the true branch, At N2479 of Function printLine
> Leaving function: printLine, On N2472 -> N2441 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N2417 -> N2415 (Return edge from goodSink to good19)
> Leaving function: good19, On N2406 -> N2450 (Return edge from good19 to main)
> Entering function: bad19, On N2450 -> N2362 (call bad19)
> Entering function: badSink, On N2369 -> N2373 (call badSink)
> takes the true branch, At N2380 of Function badSink
<Defect> : N2383 -> N2384: [%add = add i32 %1, 1]
N2383 -> N2384: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_19.c 72] badSink 		[N2383 -{%add = add i32 %1, 1}-> N2384]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_20.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad20]
 +bad20
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good20]
 +good20
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good20, main, printHexCharLine, printIntLine, printLine, printLongLine, bad20]
Loops     []
----
function: bad20
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good20
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.025s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2590): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N2529
On edge  : N2529 -{%mul = mul i32 %3, 2}-> N2530
Message  : integer overflow
> Start from entry function: main, At N2590 of Function main
> Entering function: good20, On N2638 -> N2553 (call good20)
> takes the true branch, At N2569 of Function good20
> takes the false branch, At N2572 of Function good20
> Entering function: printLine, On N2588 -> N2615 (call printLine)
> takes the true branch, At N2621 of Function printLine
> Leaving function: printLine, On N2614 -> N2583 (Return edge from printLine to good20)
> Leaving function: good20, On N2552 -> N2592 (Return edge from good20 to main)
> Entering function: bad20, On N2592 -> N2510 (call bad20)
> takes the true branch, At N2526 of Function bad20
<Defect> : N2529 -> N2530: [%mul = mul i32 %3, 2]
N2529 -> N2530: [%mul = mul i32 %3, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_20.c 76] bad20 		[N2529 -{%mul = mul i32 %3, 2}-> N2530]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_21.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad21]
 +bad21
SCC(1): [good21]
 +good21
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad21, good21, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad21
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good21
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2719): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N2677
On edge  : N2677 -{%mul = mul i32 %6, %7}-> N2678
Message  : integer overflow
> Start from entry function: main, At N2719 of Function main
> Entering function: good21, On N2767 -> N2684 (call good21)
> Entering function: printIntLine, On N2715 -> N2735 (call printIntLine)
> Leaving function: printIntLine, On N2734 -> N2716 (Return edge from printIntLine to good21)
> Leaving function: good21, On N2683 -> N2721 (Return edge from good21 to main)
> Entering function: bad21, On N2721 -> N2649 (call bad21)
<Defect> : N2677 -> N2678: [%mul = mul i32 %6, %7]
N2677 -> N2678: [%mul = mul i32 %6, %7] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2693
On edge  : N2693 -{store i32* %data, i32** %dataPtr1, align 8}-> N2695
Message  : use of uninitialized variable
> Start from entry function: main, At N2719 of Function main
> Entering function: good21, On N2767 -> N2684 (call good21)
<Defect> : N2693 -> N2695: [store i32* %data, i32** %dataPtr1, align 8]
N2693 -> N2695: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2695
On edge  : N2695 -{store i32* %data, i32** %dataPtr2, align 8}-> N2696
Message  : use of uninitialized variable
> Start from entry function: main, At N2719 of Function main
> Entering function: good21, On N2767 -> N2684 (call good21)
<Defect> : N2695 -> N2696: [store i32* %data, i32** %dataPtr2, align 8]
N2695 -> N2696: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2658
On edge  : N2658 -{store i32* %data, i32** %dataPtr1, align 8}-> N2660
Message  : use of uninitialized variable
> Start from entry function: main, At N2719 of Function main
> Entering function: good21, On N2767 -> N2684 (call good21)
> Entering function: printIntLine, On N2715 -> N2735 (call printIntLine)
> Leaving function: printIntLine, On N2734 -> N2716 (Return edge from printIntLine to good21)
> Leaving function: good21, On N2683 -> N2721 (Return edge from good21 to main)
> Entering function: bad21, On N2721 -> N2649 (call bad21)
<Defect> : N2658 -> N2660: [store i32* %data, i32** %dataPtr1, align 8]
N2658 -> N2660: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N2660
On edge  : N2660 -{store i32* %data, i32** %dataPtr2, align 8}-> N2661
Message  : use of uninitialized variable
> Start from entry function: main, At N2719 of Function main
> Entering function: good21, On N2767 -> N2684 (call good21)
> Entering function: printIntLine, On N2715 -> N2735 (call printIntLine)
> Leaving function: printIntLine, On N2734 -> N2716 (Return edge from printIntLine to good21)
> Leaving function: good21, On N2683 -> N2721 (Return edge from good21 to main)
> Entering function: bad21, On N2721 -> N2649 (call bad21)
<Defect> : N2660 -> N2661: [store i32* %data, i32** %dataPtr2, align 8]
N2660 -> N2661: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_21.c 54] bad21 		[N2677 -{%mul = mul i32 %6, %7}-> N2678]	(integer overflow)

CWE_457(Use of Uninitialized Variable): 4
	[./190_21.c 63] good21 		[N2693 -{store i32* %data, i32** %dataPtr1, align 8}-> N2695]	(use of uninitialized variable)
	[./190_21.c 64] good21 		[N2695 -{store i32* %data, i32** %dataPtr2, align 8}-> N2696]	(use of uninitialized variable)
	[./190_21.c 40] bad21 		[N2658 -{store i32* %data, i32** %dataPtr1, align 8}-> N2660]	(use of uninitialized variable)
	[./190_21.c 41] bad21 		[N2660 -{store i32* %data, i32** %dataPtr2, align 8}-> N2661]	(use of uninitialized variable)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_22.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad22]
 +bad22
SCC(1): [printLine]
 +printLine
SCC(1): [good22]
 +good22
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good22, main, printHexCharLine, printIntLine, printLine, printLongLine, bad22]
Loops     []
----
function: bad22
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good22
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.014s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2831): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N2790
On edge  : N2790 -{%add = add i32 %2, 1}-> N2791
Message  : integer overflow
> Start from entry function: main, At N2831 of Function main
> Entering function: good22, On N2879 -> N2797 (call good22)
> takes the false branch, At N2816 of Function good22
> Entering function: printLine, On N2829 -> N2856 (call printLine)
> takes the true branch, At N2862 of Function printLine
> Leaving function: printLine, On N2855 -> N2826 (Return edge from printLine to good22)
> Leaving function: good22, On N2796 -> N2833 (Return edge from good22 to main)
> Entering function: bad22, On N2833 -> N2771 (call bad22)
<Defect> : N2790 -> N2791: [%add = add i32 %2, 1]
N2790 -> N2791: [%add = add i32 %2, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_22.c 56] bad22 		[N2790 -{%add = add i32 %2, 1}-> N2791]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_23.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad23]
 +bad23
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good23]
 +good23
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good23, goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine, bad23, badSink]
Loops     []
----
function: bad23
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good23
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N2954): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N2905
On edge  : N2905 -{%mul = mul i32 %1, 2}-> N2906
Message  : integer overflow
> Start from entry function: main, At N2954 of Function main
> Entering function: good23, On N3002 -> N2915 (call good23)
> Entering function: goodSink, On N2922 -> N2926 (call goodSink)
> takes the false branch, At N2933 of Function goodSink
> Leaving function: goodSink, On N2925 -> N2923 (Return edge from goodSink to good23)
> Leaving function: good23, On N2914 -> N2956 (Return edge from good23 to main)
> Entering function: bad23, On N2956 -> N2884 (call bad23)
> Entering function: badSink, On N2891 -> N2895 (call badSink)
> takes the true branch, At N2902 of Function badSink
<Defect> : N2905 -> N2906: [%mul = mul i32 %1, 2]
N2905 -> N2906: [%mul = mul i32 %1, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_23.c 42] badSink 		[N2905 -{%mul = mul i32 %1, 2}-> N2906]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_24.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
8 SCCs to deal with
SCC(1): [badSource]
 +badSource
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad24]
 +bad24
SCC(1): [printLine]
 +printLine
SCC(1): [good24]
 +good24
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad24, badSource, good24]
Loops     []
----
function: bad24
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSource
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good24
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.013s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3065): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3053
On edge  : N3053 -{%mul = mul i32 %2, %3}-> N3054
Message  : integer overflow
> Start from entry function: main, At N3065 of Function main
> Entering function: good24, On N3113 -> N3035 (call good24)
> Entering function: badSource, On N3041 -> N3025 (call badSource)
> Leaving function: badSource, On N3024 -> N3042 (Return edge from badSource to good24)
> takes the true branch, At N3049 of Function good24
<Defect> : N3053 -> N3054: [%mul = mul i32 %2, %3]
N3053 -> N3054: [%mul = mul i32 %2, %3] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N3018
On edge  : N3018 -{%mul = mul i32 %1, %2}-> N3019
Message  : integer overflow
> Start from entry function: main, At N3065 of Function main
> Entering function: good24, On N3113 -> N3035 (call good24)
> Entering function: badSource, On N3041 -> N3025 (call badSource)
> Leaving function: badSource, On N3024 -> N3042 (Return edge from badSource to good24)
> takes the true branch, At N3049 of Function good24
> Entering function: printIntLine, On N3056 -> N3081 (call printIntLine)
> Leaving function: printIntLine, On N3080 -> N3060 (Return edge from printIntLine to good24)
> Leaving function: good24, On N3034 -> N3067 (Return edge from good24 to main)
> Entering function: bad24, On N3067 -> N3007 (call bad24)
> Entering function: badSource, On N3013 -> N3025 (call badSource)
> Leaving function: badSource, On N3024 -> N3014 (Return edge from badSource to bad24)
<Defect> : N3018 -> N3019: [%mul = mul i32 %1, %2]
N3018 -> N3019: [%mul = mul i32 %1, %2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 2
	[./190_24.c 66] good24 		[N3053 -{%mul = mul i32 %2, %3}-> N3054]	(integer overflow)
	[./190_24.c 52] bad24 		[N3018 -{%mul = mul i32 %1, %2}-> N3019]	(integer overflow)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :2
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.lambda$juliet_190_24$23(Juliet_190_Test.java:322)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.juliet_190_24(Juliet_190_Test.java:321)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_25.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad25]
 +bad25
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good25]
 +good25
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad25, badSink, good25, goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad25
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good25
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.018s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3191): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3142
On edge  : N3142 -{%conv1 = trunc i32 %add to i16}-> N3143
Message  : integer overflow
> Start from entry function: main, At N3191 of Function main
> Entering function: good25, On N3239 -> N3150 (call good25)
> Entering function: goodSink, On N3156 -> N3160 (call goodSink)
> takes the false branch, At N3173 of Function goodSink
> Entering function: printLine, On N3189 -> N3216 (call printLine)
> takes the true branch, At N3222 of Function printLine
> Leaving function: printLine, On N3215 -> N3186 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N3159 -> N3157 (Return edge from goodSink to good25)
> Leaving function: good25, On N3149 -> N3193 (Return edge from good25 to main)
> Entering function: bad25, On N3193 -> N3118 (call bad25)
> Entering function: badSink, On N3124 -> N3128 (call badSink)
<Defect> : N3142 -> N3143: [%conv1 = trunc i32 %add to i16]
N3142 -> N3143: [%conv1 = trunc i32 %add to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_25.c 42] badSink 		[N3142 -{%conv1 = trunc i32 %add to i16}-> N3143]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_26.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad26]
 +bad26
SCC(1): [goodSink]
 +goodSink
SCC(1): [good26]
 +good26
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine, bad26, badSink, good26]
Loops     []
----
function: bad26
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good26
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3339): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3281
On edge  : N3281 -{%conv3 = trunc i32 %mul to i16}-> N3282
Message  : integer overflow
> Start from entry function: main, At N3339 of Function main
> Entering function: good26, On N3387 -> N3292 (call good26)
> Entering function: goodSink, On N3304 -> N3308 (call goodSink)
> takes the true branch, At N3323 of Function goodSink
> Entering function: printIntLine, On N3332 -> N3355 (call printIntLine)
> Leaving function: printIntLine, On N3354 -> N3334 (Return edge from printIntLine to goodSink)
> Leaving function: goodSink, On N3307 -> N3305 (Return edge from goodSink to good26)
> Leaving function: good26, On N3291 -> N3341 (Return edge from good26 to main)
> Entering function: bad26, On N3341 -> N3246 (call bad26)
> Entering function: badSink, On N3258 -> N3262 (call badSink)
> takes the true branch, At N3276 of Function badSink
<Defect> : N3281 -> N3282: [%conv3 = trunc i32 %mul to i16]
N3281 -> N3282: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_26.c 44] badSink 		[N3281 -{%conv3 = trunc i32 %mul to i16}-> N3282]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_27.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad27]
 +bad27
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good27]
 +good27
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad27, badSink, good27, goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad27
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good27
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3480): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3424
On edge  : N3424 -{%conv1 = trunc i32 %add to i16}-> N3425
Message  : integer overflow
> Start from entry function: main, At N3480 of Function main
> Entering function: good27, On N3528 -> N3432 (call good27)
> Entering function: goodSink, On N3444 -> N3448 (call goodSink)
> takes the false branch, At N3462 of Function goodSink
> Entering function: printLine, On N3478 -> N3505 (call printLine)
> takes the true branch, At N3511 of Function printLine
> Leaving function: printLine, On N3504 -> N3475 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N3447 -> N3445 (Return edge from goodSink to good27)
> Leaving function: good27, On N3431 -> N3482 (Return edge from good27 to main)
> Entering function: bad27, On N3482 -> N3393 (call bad27)
> Entering function: badSink, On N3405 -> N3409 (call badSink)
<Defect> : N3424 -> N3425: [%conv1 = trunc i32 %add to i16]
N3424 -> N3425: [%conv1 = trunc i32 %add to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_27.c 47] badSink 		[N3424 -{%conv1 = trunc i32 %add to i16}-> N3425]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_28.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad28]
 +bad28
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [good28]
 +good28
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good28, goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine, bad28, badSink]
Loops     []
----
function: bad28
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good28
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3630): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3566
On edge  : N3566 -{%conv3 = trunc i32 %mul to i16}-> N3567
Message  : integer overflow
> Start from entry function: main, At N3630 of Function main
> Entering function: good28, On N3678 -> N3577 (call good28)
> Entering function: goodSink, On N3583 -> N3587 (call goodSink)
> takes the true branch, At N3605 of Function goodSink
> takes the false branch, At N3609 of Function goodSink
> Entering function: printLine, On N3628 -> N3655 (call printLine)
> takes the true branch, At N3661 of Function printLine
> Leaving function: printLine, On N3654 -> N3623 (Return edge from printLine to goodSink)
> Leaving function: goodSink, On N3586 -> N3584 (Return edge from goodSink to good28)
> Leaving function: good28, On N3576 -> N3632 (Return edge from good28 to main)
> Entering function: bad28, On N3632 -> N3533 (call bad28)
> Entering function: badSink, On N3539 -> N3543 (call badSink)
> takes the true branch, At N3561 of Function badSink
<Defect> : N3566 -> N3567: [%conv3 = trunc i32 %mul to i16]
N3566 -> N3567: [%conv3 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_28.c 51] badSink 		[N3566 -{%conv3 = trunc i32 %mul to i16}-> N3567]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_29.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [bad29]
 +bad29
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [good29]
 +good29
SCC(1): [printLine]
 +printLine
SCC(1): [goodSink]
 +goodSink
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad29, badSink, good29, goodSink, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad29
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good29
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3761): +oo]
> [1/1] entry: main ()
Phase status: FAIL

java.lang.NullPointerException
	at cn.edu.thu.tsmart.cpa.checker.instance.ApBasedChecker.preCheckInstructionEdge(ApBasedChecker.java:249)
	at cn.edu.thu.tsmart.cpa.checker.instance.ApBasedChecker.preCheckEdge(ApBasedChecker.java:112)
	at cn.edu.thu.tsmart.cpa.checker.instance.ApBasedChecker.preEdge(ApBasedChecker.java:84)
	at cn.edu.thu.tsmart.cpa.checker.CheckerTransferRelation.getAbstractSuccessorsForEdge(CheckerTransferRelation.java:50)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.callTransferRelation(CompositeTransferRelation.java:181)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.getAbstractSuccessorForSimpleEdge(CompositeTransferRelation.java:147)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.getAbstractSuccessorForEdge(CompositeTransferRelation.java:120)
	at cn.edu.thu.tsmart.cpa.composite.CompositeTransferRelation.getAbstractSuccessors(CompositeTransferRelation.java:87)
	at cn.edu.thu.tsmart.cpa.arg.ARGTransferRelation.getAbstractSuccessors(ARGTransferRelation.java:79)
	at cn.edu.thu.tsmart.core.algorithm.CPAAlgorithm.handleState(CPAAlgorithm.java:151)
	at cn.edu.thu.tsmart.core.algorithm.CPAAlgorithm.run0(CPAAlgorithm.java:124)
	at cn.edu.thu.tsmart.core.algorithm.CPAAlgorithm.run(CPAAlgorithm.java:111)
	at cn.edu.thu.tsmart.core.phase.MultiEntryAlgorithmRunPhase.runPhase(MultiEntryAlgorithmRunPhase.java:220)
	at cn.edu.thu.tsmart.core.phase.framework.CPAPhase.run(CPAPhase.java:153)
	at cn.edu.thu.tsmart.core.phase.framework.SequentialExecStrategy.runPhase(SequentialExecStrategy.java:129)
	at cn.edu.thu.tsmart.core.phase.framework.SequentialExecStrategy.exec(SequentialExecStrategy.java:93)
	at cn.edu.thu.tsmart.core.phase.framework.PhaseManager.execute(PhaseManager.java:176)
	at cn.edu.thu.tsmart.core.TsmartCPAChecker.run(TsmartCPAChecker.java:87)
	at cn.edu.thu.tsmart.TsmartCheckerMain.main(TsmartCheckerMain.java:76)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.juliet_190_29(Juliet_190_Test.java:380)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Fail to execute 'basic' phase. Pending [result]. Completed [cfa,summary] (SequentialExecStrategy.exec, SEVERE)


java.lang.AssertionError: unexpected number of reports 
Expected :0
Actual   :1
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.lambda$juliet_190_29$28(Juliet_190_Test.java:382)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.Juliet_190_Test.juliet_190_29(Juliet_190_Test.java:381)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_30.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad30]
 +bad30
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [printLine]
 +printLine
SCC(1): [goodB2G]
 +goodB2G
SCC(1): [good30]
 +good30
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad30, good30, goodB2G, goodG2B, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad30
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good30
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodB2G
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodG2B
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.011s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N3882): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3825
On edge  : N3825 -{%conv1 = trunc i32 %add to i8}-> N3826
Message  : integer overflow
> Start from entry function: main, At N3882 of Function main
> Entering function: good30, On N3930 -> N3832 (call good30)
> Entering function: goodG2B, On N3832 -> N3865 (call goodG2B)
> Entering function: printHexCharLine, On N3878 -> N3888 (call printHexCharLine)
> Leaving function: printHexCharLine, On N3887 -> N3879 (Return edge from printHexCharLine to goodG2B)
> Leaving function: goodG2B, On N3864 -> N3834 (Return edge from goodG2B to good30)
> Entering function: goodB2G, On N3834 -> N3838 (call goodB2G)
> takes the false branch, At N3848 of Function goodB2G
> Entering function: printLine, On N3863 -> N3907 (call printLine)
> takes the true branch, At N3913 of Function printLine
> Leaving function: printLine, On N3906 -> N3860 (Return edge from printLine to goodB2G)
> Leaving function: goodB2G, On N3837 -> N3835 (Return edge from goodB2G to good30)
> Leaving function: good30, On N3831 -> N3884 (Return edge from good30 to main)
> Entering function: bad30, On N3884 -> N3814 (call bad30)
<Defect> : N3825 -> N3826: [%conv1 = trunc i32 %add to i8]
N3825 -> N3826: [%conv1 = trunc i32 %add to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_30.c 44] bad30 		[N3825 -{%conv1 = trunc i32 %add to i8}-> N3826]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_31.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad31]
 +bad31
SCC(1): [goodG2B]
 +goodG2B
SCC(1): [printLine]
 +printLine
SCC(1): [goodB2G]
 +goodB2G
SCC(1): [good31]
 +good31
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad31, good31, goodB2G, goodG2B, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad31
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good31
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodB2G
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: goodG2B
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4026): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N3952
On edge  : N3952 -{%conv3 = trunc i32 %mul to i8}-> N3953
Message  : integer overflow
> Start from entry function: main, At N4026 of Function main
> Entering function: good31, On N4074 -> N3962 (call good31)
> Entering function: goodG2B, On N3962 -> N4002 (call goodG2B)
> takes the true branch, At N4011 of Function goodG2B
> Entering function: printHexCharLine, On N4019 -> N4032 (call printHexCharLine)
> Leaving function: printHexCharLine, On N4031 -> N4021 (Return edge from printHexCharLine to goodG2B)
> Leaving function: goodG2B, On N4001 -> N3964 (Return edge from goodG2B to good31)
> Entering function: goodB2G, On N3964 -> N3968 (call goodB2G)
> takes the false branch, At N3978 of Function goodB2G
> Leaving function: goodB2G, On N3967 -> N3965 (Return edge from goodB2G to good31)
> Leaving function: good31, On N3961 -> N4028 (Return edge from good31 to main)
> Entering function: bad31, On N4028 -> N3937 (call bad31)
> takes the true branch, At N3947 of Function bad31
<Defect> : N3952 -> N3953: [%conv3 = trunc i32 %mul to i8]
N3952 -> N3953: [%conv3 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_31.c 45] bad31 		[N3952 -{%conv3 = trunc i32 %mul to i8}-> N3953]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_32.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad32]
 +bad32
SCC(1): [printLine]
 +printLine
SCC(1): [good32]
 +good32
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad32, good32, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad32
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good32
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.009s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4135): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Signed to Unsigned Conversion Error
At node  : N4110
On edge  : N4110 -{%conv1 = trunc i64 %conv to i32}-> N4111
Message  : Signed to Unsigned Conversion Error
> Start from entry function: main, At N4135 of Function main
> Entering function: good32, On N4183 -> N4101 (call good32)
<Defect> : N4110 -> N4111: [%conv1 = trunc i64 %conv to i32]
N4110 -> N4111: [%conv1 = trunc i64 %conv to i32] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N4094
On edge  : N4094 -{%conv2 = trunc i32 %mul to i8}-> N4095
Message  : integer overflow
> Start from entry function: main, At N4135 of Function main
> Entering function: good32, On N4183 -> N4101 (call good32)
> takes the false branch, At N4116 of Function good32
> Entering function: printLine, On N4133 -> N4160 (call printLine)
> takes the true branch, At N4166 of Function printLine
> Leaving function: printLine, On N4159 -> N4130 (Return edge from printLine to good32)
> Leaving function: good32, On N4100 -> N4137 (Return edge from good32 to main)
> Entering function: bad32, On N4137 -> N4081 (call bad32)
<Defect> : N4094 -> N4095: [%conv2 = trunc i32 %mul to i8]
N4094 -> N4095: [%conv2 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_195(Signed to Unsigned Conversion Error): 1
	[./190_32.c 56] good32 		[N4110 -{%conv1 = trunc i64 %conv to i32}-> N4111]	(Signed to Unsigned Conversion Error)

CWE_190(Integer Overflow): 1
	[./190_32.c 44] bad32 		[N4094 -{%conv2 = trunc i32 %mul to i8}-> N4095]	(integer overflow)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_33.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad33]
 +bad33
SCC(1): [printLine]
 +printLine
SCC(1): [good33]
 +good33
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good33, main, printHexCharLine, printIntLine, printLine, printLongLine, bad33]
Loops     []
----
function: bad33
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good33
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.018s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4254): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N4206
On edge  : N4206 -{%add = add i32 %3, 1}-> N4207
Message  : integer overflow
> Start from entry function: main, At N4254 of Function main
> Entering function: good33, On N4302 -> N4218 (call good33)
> takes the true branch, At N4225 of Function good33
> takes the true branch, At N4231 of Function good33
> takes the false branch, At N4234 of Function good33
> Entering function: printLine, On N4252 -> N4279 (call printLine)
> takes the true branch, At N4285 of Function printLine
> Leaving function: printLine, On N4278 -> N4245 (Return edge from printLine to good33)
> Leaving function: good33, On N4217 -> N4256 (Return edge from good33 to main)
> Entering function: bad33, On N4256 -> N4190 (call bad33)
> takes the true branch, At N4197 of Function bad33
> takes the true branch, At N4203 of Function bad33
<Defect> : N4206 -> N4207: [%add = add i32 %3, 1]
N4206 -> N4207: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_33.c 54] bad33 		[N4206 -{%add = add i32 %3, 1}-> N4207]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_34.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
9 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [staticReturnsTrue]
 +staticReturnsTrue
SCC(1): [bad34]
 +bad34
SCC(1): [printLine]
 +printLine
SCC(1): [staticReturnsFalse]
 +staticReturnsFalse
SCC(1): [good34]
 +good34
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good34, main, printHexCharLine, printIntLine, printLine, printLongLine, staticReturnsFalse, staticReturnsTrue, bad34]
Loops     []
----
function: bad34
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good34
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: staticReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: staticReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4376): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N4326
On edge  : N4326 -{%add = add i32 %1, 1}-> N4327
Message  : integer overflow
> Start from entry function: main, At N4376 of Function main
> Entering function: good34, On N4432 -> N4338 (call good34)
> Entering function: staticReturnsTrue, On N4343 -> N4429 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4428 -> N4344 (Return edge from staticReturnsTrue to good34)
> takes the true branch, At N4345 of Function good34
> Entering function: staticReturnsFalse, On N4349 -> N4425 (call staticReturnsFalse)
> Leaving function: staticReturnsFalse, On N4424 -> N4350 (Return edge from staticReturnsFalse to good34)
> takes the false branch, At N4351 of Function good34
> takes the false branch, At N4356 of Function good34
> Entering function: printLine, On N4374 -> N4401 (call printLine)
> takes the true branch, At N4407 of Function printLine
> Leaving function: printLine, On N4400 -> N4367 (Return edge from printLine to good34)
> Leaving function: good34, On N4337 -> N4378 (Return edge from good34 to main)
> Entering function: bad34, On N4378 -> N4310 (call bad34)
> Entering function: staticReturnsTrue, On N4315 -> N4429 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4428 -> N4316 (Return edge from staticReturnsTrue to bad34)
> takes the true branch, At N4317 of Function bad34
> Entering function: staticReturnsTrue, On N4321 -> N4429 (call staticReturnsTrue)
> Leaving function: staticReturnsTrue, On N4428 -> N4322 (Return edge from staticReturnsTrue to bad34)
> takes the true branch, At N4323 of Function bad34
<Defect> : N4326 -> N4327: [%add = add i32 %1, 1]
N4326 -> N4327: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_34.c 62] bad34 		[N4326 -{%add = add i32 %1, 1}-> N4327]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_35.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [bad35]
 +bad35
SCC(1): [printLine]
 +printLine
SCC(1): [good35]
 +good35
SCC(1): [main]
 +main
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad35, good35, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad35
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good35
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4518): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Signed to Unsigned Conversion Error
At node  : N4488
On edge  : N4488 -{%conv3 = trunc i64 %conv to i32}-> N4489
Message  : Signed to Unsigned Conversion Error
> Start from entry function: main, At N4518 of Function main
> Entering function: good35, On N4566 -> N4471 (call good35)
> takes the true branch, At N4478 of Function good35
> takes the false branch, At N4483 of Function good35
<Defect> : N4488 -> N4489: [%conv3 = trunc i64 %conv to i32]
N4488 -> N4489: [%conv3 = trunc i64 %conv to i32] <--
-- end of trace --
-- start of trace --
Weakness : Integer Overflow
At node  : N4459
On edge  : N4459 -{%conv4 = trunc i32 %mul to i8}-> N4460
Message  : integer overflow
> Start from entry function: main, At N4518 of Function main
> Entering function: good35, On N4566 -> N4471 (call good35)
> takes the true branch, At N4478 of Function good35
> takes the false branch, At N4483 of Function good35
> takes the false branch, At N4494 of Function good35
> Entering function: printLine, On N4516 -> N4543 (call printLine)
> takes the true branch, At N4549 of Function printLine
> Leaving function: printLine, On N4542 -> N4509 (Return edge from printLine to good35)
> Leaving function: good35, On N4470 -> N4520 (Return edge from good35 to main)
> Entering function: bad35, On N4520 -> N4440 (call bad35)
> takes the true branch, At N4447 of Function bad35
> takes the true branch, At N4452 of Function bad35
<Defect> : N4459 -> N4460: [%conv4 = trunc i32 %mul to i8]
N4459 -> N4460: [%conv4 = trunc i32 %mul to i8] <--
-- end of trace --
=====================================================
CWE_195(Signed to Unsigned Conversion Error): 1
	[./190_35.c 90] good35 		[N4488 -{%conv3 = trunc i64 %conv to i32}-> N4489]	(Signed to Unsigned Conversion Error)

CWE_190(Integer Overflow): 1
	[./190_35.c 63] bad35 		[N4459 -{%conv4 = trunc i32 %mul to i8}-> N4460]	(integer overflow)

Found 2 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_36.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad36]
 +bad36
SCC(1): [printLine]
 +printLine
SCC(1): [good36]
 +good36
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good36, main, printHexCharLine, printIntLine, printLine, printLongLine, bad36]
Loops     []
----
function: bad36
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good36
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4639): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N4589
On edge  : N4589 -{%add = add i32 %3, 1}-> N4590
Message  : integer overflow
> Start from entry function: main, At N4639 of Function main
> Entering function: good36, On N4687 -> N4601 (call good36)
> takes the true branch, At N4608 of Function good36
> takes the false branch, At N4614 of Function good36
> takes the false branch, At N4619 of Function good36
> Entering function: printLine, On N4637 -> N4664 (call printLine)
> takes the true branch, At N4670 of Function printLine
> Leaving function: printLine, On N4663 -> N4630 (Return edge from printLine to good36)
> Leaving function: good36, On N4600 -> N4641 (Return edge from good36 to main)
> Entering function: bad36, On N4641 -> N4573 (call bad36)
> takes the true branch, At N4580 of Function bad36
> takes the true branch, At N4586 of Function bad36
<Defect> : N4589 -> N4590: [%add = add i32 %3, 1]
N4589 -> N4590: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_36.c 61] bad36 		[N4589 -{%add = add i32 %3, 1}-> N4590]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_37.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [bad37]
 +bad37
SCC(1): [good37]
 +good37
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad37, good37, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad37
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good37
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4771): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N4723
On edge  : N4723 -{%add = add i32 %2, 1}-> N4724
Message  : integer overflow
> Start from entry function: main, At N4771 of Function main
> Entering function: good37, On N4819 -> N4732 (call good37)
> takes the true branch, At N4745 of Function good37
> takes the false branch, At N4754 of Function good37
> Entering function: printLine, On N4769 -> N4796 (call printLine)
> takes the true branch, At N4802 of Function printLine
> Leaving function: printLine, On N4795 -> N4764 (Return edge from printLine to good37)
> Leaving function: good37, On N4731 -> N4773 (Return edge from good37 to main)
> Entering function: bad37, On N4773 -> N4701 (call bad37)
> takes the true branch, At N4714 of Function bad37
<Defect> : N4723 -> N4724: [%add = add i32 %2, 1]
N4723 -> N4724: [%add = add i32 %2, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_37.c 74] bad37 		[N4723 -{%add = add i32 %2, 1}-> N4724]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_38.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad38]
 +bad38
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good38]
 +good38
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good38, main, printHexCharLine, printIntLine, printLine, printLongLine, bad38]
Loops     []
----
function: bad38
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good38
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N4912): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N4848
On edge  : N4848 -{%add = add i32 %1, 1}-> N4849
Message  : integer overflow
> Start from entry function: main, At N4912 of Function main
> Entering function: good38, On N4960 -> N4874 (call good38)
> Entering function: globalReturnsTrue, On N4879 -> N4864 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N4863 -> N4880 (Return edge from globalReturnsTrue to good38)
> takes the true branch, At N4881 of Function good38
> Entering function: globalReturnsFalse, On N4885 -> N4860 (call globalReturnsFalse)
> Leaving function: globalReturnsFalse, On N4859 -> N4886 (Return edge from globalReturnsFalse to good38)
> takes the false branch, At N4887 of Function good38
> takes the false branch, At N4892 of Function good38
> Entering function: printLine, On N4910 -> N4937 (call printLine)
> takes the true branch, At N4943 of Function printLine
> Leaving function: printLine, On N4936 -> N4903 (Return edge from printLine to good38)
> Leaving function: good38, On N4873 -> N4914 (Return edge from good38 to main)
> Entering function: bad38, On N4914 -> N4832 (call bad38)
> Entering function: globalReturnsTrue, On N4837 -> N4864 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N4863 -> N4838 (Return edge from globalReturnsTrue to bad38)
> takes the true branch, At N4839 of Function bad38
> Entering function: globalReturnsTrue, On N4843 -> N4864 (call globalReturnsTrue)
> Leaving function: globalReturnsTrue, On N4863 -> N4844 (Return edge from globalReturnsTrue to bad38)
> takes the true branch, At N4845 of Function bad38
<Defect> : N4848 -> N4849: [%add = add i32 %1, 1]
N4848 -> N4849: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_38.c 75] bad38 		[N4848 -{%add = add i32 %1, 1}-> N4849]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_39.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [bad39]
 +bad39
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [good39]
 +good39
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad39, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good39]
Loops     []
----
function: bad39
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good39
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5089): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N4993
On edge  : N4993 -{%add = add i32 %1, 1}-> N4994
Message  : integer overflow
> Start from entry function: main, At N5089 of Function main
> Entering function: good39, On N5137 -> N5034 (call good39)
> Entering function: globalReturnsTrueOrFalse, On N5040 -> N5028 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N5027 -> N5041 (Return edge from globalReturnsTrueOrFalse to good39)
> takes the false branch, At N5042 of Function good39
> Entering function: globalReturnsTrueOrFalse, On N5049 -> N5028 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N5027 -> N5050 (Return edge from globalReturnsTrueOrFalse to good39)
> takes the false branch, At N5051 of Function good39
> takes the false branch, At N5067 of Function good39
> Entering function: printLine, On N5087 -> N5114 (call printLine)
> takes the true branch, At N5120 of Function printLine
> Leaving function: printLine, On N5113 -> N5078 (Return edge from printLine to good39)
> Leaving function: good39, On N5033 -> N5091 (Return edge from good39 to main)
> Entering function: bad39, On N5091 -> N4974 (call bad39)
> Entering function: globalReturnsTrueOrFalse, On N4980 -> N5028 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N5027 -> N4981 (Return edge from globalReturnsTrueOrFalse to bad39)
> takes the false branch, At N4982 of Function bad39
> Entering function: globalReturnsTrueOrFalse, On N4988 -> N5028 (call globalReturnsTrueOrFalse)
> Leaving function: globalReturnsTrueOrFalse, On N5027 -> N4989 (Return edge from globalReturnsTrueOrFalse to bad39)
> takes the true branch, At N4990 of Function bad39
<Defect> : N4993 -> N4994: [%add = add i32 %1, 1]
N4993 -> N4994: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_39.c 80] bad39 		[N4993 -{%add = add i32 %1, 1}-> N4994]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_40.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad40]
 +bad40
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good40]
 +good40
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printIntLine, printLine, printLongLine, bad40, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good40, main, printHexCharLine]
Loops     []
----
function: bad40
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good40
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.006s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5204): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5159
On edge  : N5159 -{%add = add i32 %1, 1}-> N5160
Message  : integer overflow
> Start from entry function: main, At N5204 of Function main
> Entering function: good40, On N5252 -> N5180 (call good40)
> takes the false branch, At N5189 of Function good40
> Entering function: printLine, On N5202 -> N5229 (call printLine)
> takes the true branch, At N5235 of Function printLine
> Leaving function: printLine, On N5228 -> N5199 (Return edge from printLine to good40)
> Leaving function: good40, On N5179 -> N5206 (Return edge from good40 to main)
> Entering function: bad40, On N5206 -> N5150 (call bad40)
<Defect> : N5159 -> N5160: [%add = add i32 %1, 1]
N5159 -> N5160: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_40.c 75] bad40 		[N5159 -{%add = add i32 %1, 1}-> N5160]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_41.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [printLine]
 +printLine
SCC(1): [bad41]
 +bad41
SCC(1): [good41]
 +good41
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad41, good41]
Loops     []
----
function: bad41
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good41
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5373): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5297
On edge  : N5297 -{%mul = mul i32 %5, 2}-> N5298
Message  : integer overflow
> Start from entry function: main, At N5373 of Function main
> Entering function: good41, On N5421 -> N5314 (call good41)
> takes the true branch, At N5322 of Function good41
> takes the true branch, At N5330 of Function good41
> takes the false branch, At N5340 of Function good41
> takes the false branch, At N5345 of Function good41
> Leaving function: good41, On N5313 -> N5375 (Return edge from good41 to main)
> Entering function: bad41, On N5375 -> N5265 (call bad41)
> takes the true branch, At N5273 of Function bad41
> takes the true branch, At N5281 of Function bad41
> takes the true branch, At N5291 of Function bad41
> takes the true branch, At N5294 of Function bad41
<Defect> : N5297 -> N5298: [%mul = mul i32 %5, 2]
N5297 -> N5298: [%mul = mul i32 %5, 2] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_41.c 79] bad41 		[N5297 -{%mul = mul i32 %5, 2}-> N5298]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_42.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad42]
 +bad42
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good42]
 +good42
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad42, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good42, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad42
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good42
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5516): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5452
On edge  : N5452 -{%add = add i32 %3, 1}-> N5453
Message  : integer overflow
> Start from entry function: main, At N5516 of Function main
> Entering function: good42, On N5564 -> N5478 (call good42)
> takes the true branch, At N5485 of Function good42
> takes the false branch, At N5491 of Function good42
> takes the false branch, At N5496 of Function good42
> Entering function: printLine, On N5514 -> N5541 (call printLine)
> takes the true branch, At N5547 of Function printLine
> Leaving function: printLine, On N5540 -> N5507 (Return edge from printLine to good42)
> Leaving function: good42, On N5477 -> N5518 (Return edge from good42 to main)
> Entering function: bad42, On N5518 -> N5436 (call bad42)
> takes the true branch, At N5443 of Function bad42
> takes the true branch, At N5449 of Function bad42
<Defect> : N5452 -> N5453: [%add = add i32 %3, 1]
N5452 -> N5453: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_42.c 75] bad42 		[N5452 -{%add = add i32 %3, 1}-> N5453]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_43.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad43]
 +bad43
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good43]
 +good43
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsTrueOrFalse, good43, main, printHexCharLine, printIntLine, printLine, printLongLine, bad43, globalReturnsFalse, globalReturnsTrue]
Loops     []
----
function: bad43
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good43
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5632): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5587
On edge  : N5587 -{%add = add i32 %1, 1}-> N5588
Message  : integer overflow
> Start from entry function: main, At N5632 of Function main
> Entering function: good43, On N5680 -> N5608 (call good43)
> takes the false branch, At N5617 of Function good43
> Entering function: printLine, On N5630 -> N5657 (call printLine)
> takes the true branch, At N5663 of Function printLine
> Leaving function: printLine, On N5656 -> N5627 (Return edge from printLine to good43)
> Leaving function: good43, On N5607 -> N5634 (Return edge from good43 to main)
> Entering function: bad43, On N5634 -> N5578 (call bad43)
<Defect> : N5587 -> N5588: [%add = add i32 %1, 1]
N5587 -> N5588: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_43.c 82] bad43 		[N5587 -{%add = add i32 %1, 1}-> N5588]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_44.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad44]
 +bad44
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good44]
 +good44
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [main, printHexCharLine, printIntLine, printLine, printLongLine, bad44, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good44]
Loops     []
----
function: bad44
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good44
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.01s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5755): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5705
On edge  : N5705 -{%add = add i32 %1, 1}-> N5706
Message  : integer overflow
> Start from entry function: main, At N5755 of Function main
> Entering function: good44, On N5803 -> N5727 (call good44)
> takes the false branch, At N5739 of Function good44
> Entering function: printLine, On N5753 -> N5780 (call printLine)
> takes the true branch, At N5786 of Function printLine
> Leaving function: printLine, On N5779 -> N5750 (Return edge from printLine to good44)
> Leaving function: good44, On N5726 -> N5757 (Return edge from good44 to main)
> Entering function: bad44, On N5757 -> N5693 (call bad44)
<Defect> : N5705 -> N5706: [%add = add i32 %1, 1]
N5705 -> N5706: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_44.c 79] bad44 		[N5705 -{%add = add i32 %1, 1}-> N5706]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_45.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad45]
 +bad45
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good45]
 +good45
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good45, main, printHexCharLine, printIntLine, printLine, printLongLine, bad45]
Loops     [N5827, N5913, N5885, N5839]
----
function: bad45
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good45
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
loop N5827 in bad45: 
N5827 -> P+ = [], P- = [] Point-To: 
N5829 -> P+ = [], P- = [] Point-To: 
----
loop N5839 in bad45: 
N5839 -> P+ = [], P- = [] Point-To: 
N5841 -> P+ = [], P- = [] Point-To: 
----
loop N5885 in good45: 
N5885 -> P+ = [], P- = [] Point-To: 
N5887 -> P+ = [], P- = [] Point-To: 
----
loop N5913 in good45: 
N5897 -> P+ = [], P- = [] Point-To: 
N5899 -> P+ = [], P- = [] Point-To: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.007s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N5926): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5844
On edge  : N5844 -{%add = add i32 %4, 1}-> N5845
Message  : integer overflow
> Start from entry function: main, At N5926 of Function main
> Entering function: good45, On N5974 -> N5874 (call good45)
> takes the true branch, At N5887 of Function good45
> takes the false branch, At N5887 of Function good45
> takes the true branch, At N5899 of Function good45
> takes the true branch, At N5902 of Function good45
> Entering function: printIntLine, On N5908 -> N5942 (call printIntLine)
> Leaving function: printIntLine, On N5941 -> N5913 (Return edge from printIntLine to good45)
> takes the false branch, At N5899 of Function good45
> Leaving function: good45, On N5873 -> N5928 (Return edge from good45 to main)
> Entering function: bad45, On N5928 -> N5816 (call bad45)
> takes the true branch, At N5829 of Function bad45
> takes the false branch, At N5829 of Function bad45
> takes the true branch, At N5841 of Function bad45
<Defect> : N5844 -> N5845: [%add = add i32 %4, 1]
N5844 -> N5845: [%add = add i32 %4, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_45.c 76] bad45 		[N5844 -{%add = add i32 %4, 1}-> N5845]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_46.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad46]
 +bad46
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good46]
 +good46
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad46, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good46, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad46
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good46
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.005s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6045): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N5998
On edge  : N5998 -{%add = add i32 %1, 1}-> N5999
Message  : integer overflow
> Start from entry function: main, At N6045 of Function main
> Entering function: good46, On N6093 -> N6019 (call good46)
> takes the false branch, At N6030 of Function good46
> Entering function: printLine, On N6043 -> N6070 (call printLine)
> takes the true branch, At N6076 of Function printLine
> Leaving function: printLine, On N6069 -> N6040 (Return edge from printLine to good46)
> Leaving function: good46, On N6018 -> N6047 (Return edge from good46 to main)
> Entering function: bad46, On N6047 -> N5987 (call bad46)
<Defect> : N5998 -> N5999: [%add = add i32 %1, 1]
N5998 -> N5999: [%add = add i32 %1, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_46.c 74] bad46 		[N5998 -{%add = add i32 %1, 1}-> N5999]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_47.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
7 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad47]
 +bad47
SCC(1): [printLine]
 +printLine
SCC(1): [good47]
 +good47
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [good47, main, printHexCharLine, printIntLine, printLine, printLongLine, bad47]
Loops     []
----
function: bad47
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: good47
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6193): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N6128
On edge  : N6128 -{%conv6 = trunc i32 %mul to i16}-> N6129
Message  : integer overflow
> Start from entry function: main, At N6193 of Function main
> Entering function: good47, On N6241 -> N6144 (call good47)
> takes the true branch, At N6151 of Function good47
> takes the false branch, At N6157 of Function good47
> takes the false branch, At N6163 of Function good47
> Leaving function: good47, On N6143 -> N6195 (Return edge from good47 to main)
> Entering function: bad47, On N6195 -> N6106 (call bad47)
> takes the true branch, At N6113 of Function bad47
> takes the true branch, At N6119 of Function bad47
> takes the true branch, At N6123 of Function bad47
<Defect> : N6128 -> N6129: [%conv6 = trunc i32 %mul to i16]
N6128 -> N6129: [%conv6 = trunc i32 %mul to i16] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_47.c 60] bad47 		[N6128 -{%conv6 = trunc i32 %mul to i16}-> N6129]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_48.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
11 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [badSink]
 +badSink
SCC(1): [bad48]
 +bad48
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [printLine]
 +printLine
SCC(1): [good48]
 +good48
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad48, badSink, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good48, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad48
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: badSink
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good48
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6330): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N6277
On edge  : N6277 -{%add = add i32 %1, 1}-> N6278
Message  : integer overflow
> Start from entry function: main, At N6330 of Function main
> Entering function: good48, On N6378 -> N6301 (call good48)
> takes the false branch, At N6307 of Function good48
> takes the true branch, At N6312 of Function good48
> Entering function: printIntLine, On N6318 -> N6346 (call printIntLine)
> Leaving function: printIntLine, On N6345 -> N6323 (Return edge from printIntLine to good48)
> Leaving function: good48, On N6300 -> N6332 (Return edge from good48 to main)
> Entering function: bad48, On N6332 -> N6255 (call bad48)
> Entering function: badSink, On N6263 -> N6267 (call badSink)
> takes the true branch, At N6274 of Function badSink
<Defect> : N6277 -> N6278: [%add = add i32 %1, 1]
N6277 -> N6278: [%add = add i32 %1, 1] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6326
On edge  : N6326 -{%1 = load i32, i32* %data, align 4}-> N6311
Message  : use of uninitialized variable
> Start from entry function: main, At N6330 of Function main
> Entering function: good48, On N6378 -> N6301 (call good48)
> takes the false branch, At N6307 of Function good48
<Defect> : N6326 -> N6311: [%1 = load i32, i32* %data, align 4]
N6326 -> N6311: [%1 = load i32, i32* %data, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6327
On edge  : N6327 -{%2 = load i32, i32* %data, align 4}-> N6315
Message  : use of uninitialized variable
> Start from entry function: main, At N6330 of Function main
> Entering function: good48, On N6378 -> N6301 (call good48)
> takes the false branch, At N6307 of Function good48
> takes the true branch, At N6312 of Function good48
<Defect> : N6327 -> N6315: [%2 = load i32, i32* %data, align 4]
N6327 -> N6315: [%2 = load i32, i32* %data, align 4] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_48.c 70] badSink 		[N6277 -{%add = add i32 %1, 1}-> N6278]	(integer overflow)

CWE_457(Use of Uninitialized Variable): 2
	[./190_48.c 107] good48 		[N6326 -{%1 = load i32, i32* %data, align 4}-> N6311]	(use of uninitialized variable)
	[./190_48.c 109] good48 		[N6327 -{%2 = load i32, i32* %data, align 4}-> N6315]	(use of uninitialized variable)

Found 3 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_49.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad49]
 +bad49
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good49]
 +good49
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [bad49, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good49, main, printHexCharLine, printIntLine, printLine, printLongLine]
Loops     []
----
function: bad49
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good49
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6455): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N6411
On edge  : N6411 -{%add = add i32 %3, 1}-> N6412
Message  : integer overflow
> Start from entry function: main, At N6455 of Function main
> Entering function: good49, On N6503 -> N6432 (call good49)
> Entering function: printIntLine, On N6451 -> N6471 (call printIntLine)
> Leaving function: printIntLine, On N6470 -> N6452 (Return edge from printIntLine to good49)
> Leaving function: good49, On N6431 -> N6457 (Return edge from good49 to main)
> Entering function: bad49, On N6457 -> N6394 (call bad49)
<Defect> : N6411 -> N6412: [%add = add i32 %3, 1]
N6411 -> N6412: [%add = add i32 %3, 1] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_49.c 73] bad49 		[N6411 -{%add = add i32 %3, 1}-> N6412]	(integer overflow)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/Juliet_Test_Suite/190/190_50.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
10 SCCs to deal with
SCC(1): [printIntLine]
 +printIntLine
SCC(1): [bad50]
 +bad50
SCC(1): [globalReturnsFalse]
 +globalReturnsFalse
SCC(1): [globalReturnsTrue]
 +globalReturnsTrue
SCC(1): [globalReturnsTrueOrFalse]
 +globalReturnsTrueOrFalse
SCC(1): [good50]
 +good50
SCC(1): [main]
 +main
SCC(1): [printHexCharLine]
 +printHexCharLine
SCC(1): [printLine]
 +printLine
SCC(1): [printLongLine]
 +printLongLine
<begin of summary store (POINTER_AP)>
Functions [printLongLine, bad50, globalReturnsFalse, globalReturnsTrue, globalReturnsTrueOrFalse, good50, main, printHexCharLine, printIntLine, printLine]
Loops     []
----
function: bad50
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: globalReturnsFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrue
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: globalReturnsTrueOrFalse
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: good50
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: main
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: printHexCharLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printIntLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: printLongLine
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N6598): +oo]
> [1/1] entry: main ()
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Integer Overflow
At node  : N6543
On edge  : N6543 -{%add = add i32 %7, 1}-> N6544
Message  : integer overflow
> Start from entry function: main, At N6598 of Function main
> Entering function: good50, On N6646 -> N6564 (call good50)
> Entering function: printIntLine, On N6594 -> N6614 (call printIntLine)
> Leaving function: printIntLine, On N6613 -> N6595 (Return edge from printIntLine to good50)
> Leaving function: good50, On N6563 -> N6600 (Return edge from good50 to main)
> Entering function: bad50, On N6600 -> N6515 (call bad50)
<Defect> : N6543 -> N6544: [%add = add i32 %7, 1]
N6543 -> N6544: [%add = add i32 %7, 1] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6573
On edge  : N6573 -{store i32* %data, i32** %dataPtr1, align 8}-> N6575
Message  : use of uninitialized variable
> Start from entry function: main, At N6598 of Function main
> Entering function: good50, On N6646 -> N6564 (call good50)
<Defect> : N6573 -> N6575: [store i32* %data, i32** %dataPtr1, align 8]
N6573 -> N6575: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6575
On edge  : N6575 -{store i32* %data, i32** %dataPtr2, align 8}-> N6576
Message  : use of uninitialized variable
> Start from entry function: main, At N6598 of Function main
> Entering function: good50, On N6646 -> N6564 (call good50)
<Defect> : N6575 -> N6576: [store i32* %data, i32** %dataPtr2, align 8]
N6575 -> N6576: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6524
On edge  : N6524 -{store i32* %data, i32** %dataPtr1, align 8}-> N6526
Message  : use of uninitialized variable
> Start from entry function: main, At N6598 of Function main
> Entering function: good50, On N6646 -> N6564 (call good50)
> Entering function: printIntLine, On N6594 -> N6614 (call printIntLine)
> Leaving function: printIntLine, On N6613 -> N6595 (Return edge from printIntLine to good50)
> Leaving function: good50, On N6563 -> N6600 (Return edge from good50 to main)
> Entering function: bad50, On N6600 -> N6515 (call bad50)
<Defect> : N6524 -> N6526: [store i32* %data, i32** %dataPtr1, align 8]
N6524 -> N6526: [store i32* %data, i32** %dataPtr1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N6526
On edge  : N6526 -{store i32* %data, i32** %dataPtr2, align 8}-> N6527
Message  : use of uninitialized variable
> Start from entry function: main, At N6598 of Function main
> Entering function: good50, On N6646 -> N6564 (call good50)
> Entering function: printIntLine, On N6594 -> N6614 (call printIntLine)
> Leaving function: printIntLine, On N6613 -> N6595 (Return edge from printIntLine to good50)
> Leaving function: good50, On N6563 -> N6600 (Return edge from good50 to main)
> Entering function: bad50, On N6600 -> N6515 (call bad50)
<Defect> : N6526 -> N6527: [store i32* %data, i32** %dataPtr2, align 8]
N6526 -> N6527: [store i32* %data, i32** %dataPtr2, align 8] <--
-- end of trace --
=====================================================
CWE_190(Integer Overflow): 1
	[./190_50.c 78] bad50 		[N6543 -{%add = add i32 %7, 1}-> N6544]	(integer overflow)

CWE_457(Use of Uninitialized Variable): 4
	[./190_50.c 91] good50 		[N6573 -{store i32* %data, i32** %dataPtr1, align 8}-> N6575]	(use of uninitialized variable)
	[./190_50.c 92] good50 		[N6575 -{store i32* %data, i32** %dataPtr2, align 8}-> N6576]	(use of uninitialized variable)
	[./190_50.c 64] bad50 		[N6524 -{store i32* %data, i32** %dataPtr1, align 8}-> N6526]	(use of uninitialized variable)
	[./190_50.c 65] bad50 		[N6526 -{store i32* %data, i32** %dataPtr2, align 8}-> N6527]	(use of uninitialized variable)

Found 5 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 255
