/usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java -ea -Didea.test.cyclic.buffer.size=1048576 -javaagent:/home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar=32788:/home/guzuxing/Downloads/idea-IU-171.4424.56/bin -Dfile.encoding=UTF-8 -classpath /home/guzuxing/Downloads/idea-IU-171.4424.56/lib/idea_rt.jar:/home/guzuxing/Downloads/idea-IU-171.4424.56/plugins/junit/lib/junit-rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/icedtea-sound.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/management-agent.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre/lib/rt.jar:/home/guzuxing/Documents/tsmart-v3/engine/out/test/classes:/home/guzuxing/Documents/tsmart-v3/engine/build/resources/test:/home/guzuxing/Documents/tsmart-v3/engine/out/production/classes:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-macosx-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/guava.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/java-cup-runtime.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86_64.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.core.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/com.microsoft.z3.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jopt-simple.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javasmt.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javacpp.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/scala-library.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/princess-assertionless.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/org.osgi.compendium.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smtinterpol.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-linux-x86.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/llvm-platform.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/smt-parser.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/common.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/javolution-core-java.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/runtime/jsr305.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/XMLReport.jar:/home/guzuxing/Documents/tsmart-v3/engine/libs/build-capture.jar:/home/guzuxing/Documents/tsmart-v3/mod-commons/out/production/classes:/home/guzuxing/.gradle/caches/modules-2/files-2.1/junit/junit/4.11/4e031bb61df09069aeb2bffb4019e7a5034a4ee0/junit-4.11.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.guava/guava/19.0/6ce200f6b23222af3d8abb6b6459e6c44f4bb0e9/guava-19.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.code.findbugs/jsr305/3.0.0/5871fb60dc68d67da54a663c3fd636a10a532948/jsr305-3.0.0.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.truth/truth/0.30/9d591b5a66eda81f0b88cf1c748ab8853d99b18b/truth-0.30.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar:/home/guzuxing/.gradle/caches/modules-2/files-2.1/com.google.errorprone/error_prone_annotations/2.0.8/54e2d56cb157df08cbf183149bcf50c9f5151ed4/error_prone_annotations-2.0.8.jar com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 cn.edu.thu.tsmart.integrated.ITC_401_Test
<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_10.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0010_bad]
 +memory_leak_0010_bad
SCC(1): [memory_leak_0010_good]
 +memory_leak_0010_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_0010_bad, memory_leak_0010_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0010_bad::call), H(memory_leak_0010_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0010_bad
P+ = [] 
P- = [H(memory_leak_0010_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_0010_good
P+ = [] 
P- = [H(memory_leak_0010_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.34s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1): +oo]
> [1/1] entry: main ()
N1 -{%retval = alloca i32, align 4}-> N3
N3 -{store i32 0, i32* %retval, align 4}-> N4
N4 -{call memory_leak_0010_good}-> N43
N43 -{%ptr = alloca i32*, align 8}-> N45
N45 -{%p1 = alloca i32*, align 8}-> N46
N46 -{%p2 = alloca i32*, align 8}-> N48
N48 -{%call = call i8* @calloc(i64 5, i64 4, i64 @calloc)}-> N49
N48 -{%call = call i8* @calloc(i64 5, i64 4, i64 @calloc)}-> N49
N49 -{%0 = bitcast i8* %call to i32*}-> N50
N49 -{%0 = bitcast i8* %call to i32*}-> N50
N50 -{store i32* %0, i32** %ptr, align 8}-> N52
N50 -{store i32* %0, i32** %ptr, align 8}-> N52
N52 -{store i32* null, i32** %p1, align 8}-> N54
N52 -{store i32* null, i32** %p1, align 8}-> N54
N54 -{store i32* null, i32** %p2, align 8}-> N55
N54 -{store i32* null, i32** %p2, align 8}-> N55
N55 -{%1 = load i32*, i32** %ptr, align 8}-> N56
N55 -{%1 = load i32*, i32** %ptr, align 8}-> N56
N56 -{%cmp = icmp ne i32* %1, null}-> N57
N56 -{%cmp = icmp ne i32* %1, null}-> N57
N57 -{[%cmp = icmp ne i32* %1, null]}-> N71
N57 -{[!(%cmp = icmp ne i32* %1, null)]}-> N69
N57 -{[%cmp = icmp ne i32* %1, null]}-> N71
N57 -{[!(%cmp = icmp ne i32* %1, null)]}-> N69
N71 -{%2 = load i32*, i32** %ptr, align 8}-> N59
N59 -{store i32* %2, i32** %p1, align 8}-> N60
N60 -{%3 = load i32*, i32** %p1, align 8}-> N61
N61 -{store i32* %3, i32** %p2, align 8}-> N62
N62 -{%4 = load i32*, i32** %p2, align 8}-> N63
N63 -{%add.ptr = getelementptr inbounds i32, i32* %4, i64 4}-> N64
N64 -{store i32 1, i32* %add.ptr, align 4}-> N65
N65 -{%5 = load i32*, i32** %ptr, align 8}-> N66
N66 -{%6 = bitcast i32* %5 to i8*}-> N67
N67 -{call void @free(i8* %6, i8* @free)}-> N69
N69 -{ret void}-> N42
N42 -{Return edge from memory_leak_0010_good to main}-> N5
N5 -{call memory_leak_0010_bad}-> N9
N9 -{%ptr = alloca i32*, align 8}-> N11
N11 -{%p1 = alloca i32*, align 8}-> N12
N12 -{%p2 = alloca i32*, align 8}-> N14
N14 -{%call = call i8* @calloc(i64 5, i64 4, i64 @calloc)}-> N15
N14 -{%call = call i8* @calloc(i64 5, i64 4, i64 @calloc)}-> N15
N15 -{%0 = bitcast i8* %call to i32*}-> N16
N15 -{%0 = bitcast i8* %call to i32*}-> N16
N16 -{store i32* %0, i32** %ptr, align 8}-> N17
N16 -{store i32* %0, i32** %ptr, align 8}-> N17
N17 -{%1 = load i32*, i32** %ptr, align 8}-> N18
N17 -{%1 = load i32*, i32** %ptr, align 8}-> N18
N18 -{%cmp = icmp eq i32* %1, null}-> N19
N18 -{%cmp = icmp eq i32* %1, null}-> N19
N19 -{[!(%cmp = icmp eq i32* %1, null)]}-> N41
N19 -{[%cmp = icmp eq i32* %1, null]}-> N38
N19 -{[!(%cmp = icmp eq i32* %1, null)]}-> N41
N19 -{[%cmp = icmp eq i32* %1, null]}-> N38
N41 -{%call1 = call i8* @calloc(i64 5, i64 4, i64 @calloc)}-> N23
N41 -{%call1 = call i8* @calloc(i64 5, i64 4, i64 @calloc)}-> N23
N23 -{%2 = bitcast i8* %call1 to i32*}-> N24
N23 -{%2 = bitcast i8* %call1 to i32*}-> N24
N24 -{store i32* %2, i32** %p1, align 8}-> N26
N24 -{store i32* %2, i32** %p1, align 8}-> N26
N26 -{store i32* null, i32** %p2, align 8}-> N27
N26 -{store i32* null, i32** %p2, align 8}-> N27
N27 -{%3 = load i32*, i32** %ptr, align 8}-> N28
N27 -{%3 = load i32*, i32** %ptr, align 8}-> N28
N28 -{store i32* %3, i32** %p1, align 8}-> N29
N28 -{store i32* %3, i32** %p1, align 8}-> N29
N29 -{%4 = load i32*, i32** %p1, align 8}-> N30
N29 -{%4 = load i32*, i32** %p1, align 8}-> N30
N30 -{store i32* %4, i32** %p2, align 8}-> N31
N30 -{store i32* %4, i32** %p2, align 8}-> N31
N31 -{%5 = load i32*, i32** %p2, align 8}-> N32
N31 -{%5 = load i32*, i32** %p2, align 8}-> N32
N32 -{%add.ptr = getelementptr inbounds i32, i32* %5, i64 4}-> N33
N32 -{%add.ptr = getelementptr inbounds i32, i32* %5, i64 4}-> N33
N33 -{store i32 1, i32* %add.ptr, align 4}-> N34
N33 -{store i32 1, i32* %add.ptr, align 4}-> N34
N34 -{%6 = load i32*, i32** %ptr, align 8}-> N35
N34 -{%6 = load i32*, i32** %ptr, align 8}-> N35
N35 -{%7 = bitcast i32* %6 to i8*}-> N36
N35 -{%7 = bitcast i32* %6 to i8*}-> N36
N36 -{call void @free(i8* %7, i8* @free)}-> N38
N36 -{call void @free(i8* %7, i8* @free)}-> N38
N38 -{ret void}-> N8
N38 -{ret void}-> N8
N8 -{Return edge from memory_leak_0010_bad to main}-> N6
N8 -{Return edge from memory_leak_0010_bad to main}-> N6
N6 -{ret i32 0}-> N0
N6 -{ret i32 0}-> N0
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N8
On edge  : N8 -{Return edge from memory_leak_0010_bad to main}-> N6
Message  : the heap object @H(memory_leak_0010_bad::call1) is not referenced any more
> Start from entry function: main, At N1 of Function main
> Entering function: memory_leak_0010_good, On N4 -> N43 (call memory_leak_0010_good)
> takes the false branch, At N57 of Function memory_leak_0010_good
> Leaving function: memory_leak_0010_good, On N42 -> N5 (Return edge from memory_leak_0010_good to main)
> Entering function: memory_leak_0010_bad, On N5 -> N9 (call memory_leak_0010_bad)
> takes the false branch, At N19 of Function memory_leak_0010_bad
<Defect> : N8 -> N6: [Return edge from memory_leak_0010_bad to main]
N8 -> N6: [Return edge from memory_leak_0010_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_10.c 58] memory_leak_0010_bad 		[N8 -{Return edge from memory_leak_0010_bad to main}-> N6]	(the heap object @H(memory_leak_0010_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_11.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0011_good]
 +memory_leak_0011_good
SCC(1): [memory_leak_0011_bad]
 +memory_leak_0011_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_0011_good, main, memory_leak_0011_bad]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0011_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0011_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_0011_good
P+ = [] 
P- = [H(memory_leak_0011_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.039s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N74): +oo]
> [1/1] entry: main ()
N74 -{global: .str}-> N139
N139 -{%retval = alloca i32, align 4}-> N76
N76 -{store i32 0, i32* %retval, align 4}-> N77
N77 -{call memory_leak_0011_good}-> N104
N104 -{%buf = alloca i8*, align 8}-> N106
N106 -{%un = alloca %union.memory_leak_0011_uni_001, align 8}-> N107
N107 -{%buf2 = alloca i8*, align 8}-> N109
N109 -{store i8* null, i8** %buf, align 8}-> N111
N111 -{%call = call i8* @calloc(i64 50, i64 1, i64 @calloc)}-> N112
N111 -{%call = call i8* @calloc(i64 50, i64 1, i64 @calloc)}-> N112
N112 -{store i8* %call, i8** %buf, align 8}-> N113
N112 -{store i8* %call, i8** %buf, align 8}-> N113
N113 -{%0 = load i8*, i8** %buf, align 8}-> N114
N113 -{%0 = load i8*, i8** %buf, align 8}-> N114
N114 -{%cmp = icmp ne i8* %0, null}-> N115
N114 -{%cmp = icmp ne i8* %0, null}-> N115
N115 -{[%cmp = icmp ne i8* %0, null]}-> N135
N115 -{[!(%cmp = icmp ne i8* %0, null)]}-> N133
N115 -{[%cmp = icmp ne i8* %0, null]}-> N135
N115 -{[!(%cmp = icmp ne i8* %0, null)]}-> N133
N135 -{%1 = load i8*, i8** %buf, align 8}-> N117
N117 -{%call1 = call i8* @strcpy(i8* %1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8* @strcpy)}-> N118
N118 -{%2 = load i8*, i8** %buf, align 8}-> N119
N119 -{%u1 = bitcast %union.memory_leak_0011_uni_001* %un to i8**}-> N120
N120 -{store i8* %2, i8** %u1, align 8}-> N122
N122 -{%u13 = bitcast %union.memory_leak_0011_uni_001* %un to i8**}-> N123
N123 -{%3 = load i8*, i8** %u13, align 8}-> N124
N124 -{store i8* %3, i8** %buf2, align 8}-> N125
N125 -{%4 = load i8*, i8** %buf2, align 8}-> N126
N126 -{%tobool = icmp ne i8* %4, null}-> N127
N127 -{[%tobool = icmp ne i8* %4, null]}-> N137
N127 -{[!(%tobool = icmp ne i8* %4, null)]}-> N131
N137 -{%5 = load i8*, i8** %buf2, align 8}-> N129
N129 -{call void @free(i8* %5, i8* @free)}-> N131
N131 -{store i8* null, i8** %buf2, align 8}-> N133
N133 -{ret void}-> N103
N133 -{ret void}-> N103
N103 -{Return edge from memory_leak_0011_good to main}-> N78
N103 -{Return edge from memory_leak_0011_good to main}-> N78
N78 -{call memory_leak_0011_bad}-> N82
N82 -{%buf = alloca i8*, align 8}-> N84
N84 -{%un = alloca %union.memory_leak_0011_uni_001, align 8}-> N86
N86 -{store i8* null, i8** %buf, align 8}-> N88
N88 -{%call = call i8* @calloc(i64 50, i64 1, i64 @calloc)}-> N89
N88 -{%call = call i8* @calloc(i64 50, i64 1, i64 @calloc)}-> N89
N89 -{store i8* %call, i8** %buf, align 8}-> N90
N89 -{store i8* %call, i8** %buf, align 8}-> N90
N90 -{%0 = load i8*, i8** %buf, align 8}-> N91
N90 -{%0 = load i8*, i8** %buf, align 8}-> N91
N91 -{%cmp = icmp ne i8* %0, null}-> N92
N91 -{%cmp = icmp ne i8* %0, null}-> N92
N92 -{[%cmp = icmp ne i8* %0, null]}-> N101
N92 -{[!(%cmp = icmp ne i8* %0, null)]}-> N99
N92 -{[%cmp = icmp ne i8* %0, null]}-> N101
N92 -{[!(%cmp = icmp ne i8* %0, null)]}-> N99
N101 -{%1 = load i8*, i8** %buf, align 8}-> N94
N94 -{%call1 = call i8* @strcpy(i8* %1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8* @strcpy)}-> N95
N95 -{%2 = load i8*, i8** %buf, align 8}-> N96
N96 -{%u1 = bitcast %union.memory_leak_0011_uni_001* %un to i8**}-> N97
N97 -{store i8* %2, i8** %u1, align 8}-> N99
N99 -{ret void}-> N81
N99 -{ret void}-> N81
N81 -{Return edge from memory_leak_0011_bad to main}-> N79
N81 -{Return edge from memory_leak_0011_bad to main}-> N79
N79 -{ret i32 0}-> N73
N79 -{ret i32 0}-> N73
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N81
On edge  : N81 -{Return edge from memory_leak_0011_bad to main}-> N79
Message  : the heap object @H(memory_leak_0011_bad::call) is not referenced any more
> Start from entry function: main, At N74 of Function main
> Entering function: memory_leak_0011_good, On N77 -> N104 (call memory_leak_0011_good)
> takes the false branch, At N115 of Function memory_leak_0011_good
> Leaving function: memory_leak_0011_good, On N103 -> N78 (Return edge from memory_leak_0011_good to main)
> Entering function: memory_leak_0011_bad, On N78 -> N82 (call memory_leak_0011_bad)
> takes the true branch, At N92 of Function memory_leak_0011_bad
<Defect> : N81 -> N79: [Return edge from memory_leak_0011_bad to main]
N81 -> N79: [Return edge from memory_leak_0011_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_11.c 64] memory_leak_0011_bad 		[N81 -{Return edge from memory_leak_0011_bad to main}-> N79]	(the heap object @H(memory_leak_0011_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_12.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0012_good]
 +memory_leak_0012_good
SCC(1): [memory_leak_0012_bad]
 +memory_leak_0012_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_0012_bad, memory_leak_0012_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0012_bad::call), H(memory_leak_0012_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0012_bad
P+ = [] 
P- = [H(memory_leak_0012_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_0012_good
P+ = [] 
P- = [H(memory_leak_0012_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.017s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N141): +oo]
> [1/1] entry: main ()
N141 -{%retval = alloca i32, align 4}-> N143
N143 -{store i32 0, i32* %retval, align 4}-> N144
N144 -{call memory_leak_0012_good}-> N179
N179 -{%u = alloca %union.memory_leak_0012_uni_001*, align 8}-> N181
N181 -{%p = alloca %union.memory_leak_0012_uni_001*, align 8}-> N183
N183 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N184
N183 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N184
N184 -{%0 = bitcast i8* %call to %union.memory_leak_0012_uni_001*}-> N185
N184 -{%0 = bitcast i8* %call to %union.memory_leak_0012_uni_001*}-> N185
N185 -{store %union.memory_leak_0012_uni_001* %0, %union.memory_leak_0012_uni_001** %u, align 8}-> N187
N185 -{store %union.memory_leak_0012_uni_001* %0, %union.memory_leak_0012_uni_001** %u, align 8}-> N187
N187 -{store %union.memory_leak_0012_uni_001* null, %union.memory_leak_0012_uni_001** %p, align 8}-> N188
N187 -{store %union.memory_leak_0012_uni_001* null, %union.memory_leak_0012_uni_001** %p, align 8}-> N188
N188 -{%1 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N189
N188 -{%1 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N189
N189 -{store %union.memory_leak_0012_uni_001* %1, %union.memory_leak_0012_uni_001** %p, align 8}-> N190
N189 -{store %union.memory_leak_0012_uni_001* %1, %union.memory_leak_0012_uni_001** %p, align 8}-> N190
N190 -{%2 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N191
N190 -{%2 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N191
N191 -{%cmp = icmp ne %union.memory_leak_0012_uni_001* %2, null}-> N192
N191 -{%cmp = icmp ne %union.memory_leak_0012_uni_001* %2, null}-> N192
N192 -{[%cmp = icmp ne %union.memory_leak_0012_uni_001* %2, null]}-> N203
N192 -{[!(%cmp = icmp ne %union.memory_leak_0012_uni_001* %2, null)]}-> N201
N192 -{[%cmp = icmp ne %union.memory_leak_0012_uni_001* %2, null]}-> N203
N192 -{[!(%cmp = icmp ne %union.memory_leak_0012_uni_001* %2, null)]}-> N201
N203 -{%3 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %p, align 8}-> N194
N194 -{%s1 = bitcast %union.memory_leak_0012_uni_001* %3 to %struct.memory_leak_0012_s_001*}-> N195
N195 -{%a = getelementptr inbounds %struct.memory_leak_0012_s_001, %struct.memory_leak_0012_s_001* %s1, i32 0, i32 0}-> N196
N196 -{store i32 1, i32* %a, align 4}-> N197
N197 -{%4 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N198
N198 -{%5 = bitcast %union.memory_leak_0012_uni_001* %4 to i8*}-> N199
N199 -{call void @free(i8* %5, i8* @free)}-> N201
N201 -{ret void}-> N178
N178 -{Return edge from memory_leak_0012_good to main}-> N145
N145 -{call memory_leak_0012_bad}-> N149
N149 -{%u = alloca %union.memory_leak_0012_uni_001*, align 8}-> N151
N151 -{%p = alloca %union.memory_leak_0012_uni_001*, align 8}-> N153
N153 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N154
N153 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N154
N154 -{%0 = bitcast i8* %call to %union.memory_leak_0012_uni_001*}-> N155
N154 -{%0 = bitcast i8* %call to %union.memory_leak_0012_uni_001*}-> N155
N155 -{store %union.memory_leak_0012_uni_001* %0, %union.memory_leak_0012_uni_001** %u, align 8}-> N156
N155 -{store %union.memory_leak_0012_uni_001* %0, %union.memory_leak_0012_uni_001** %u, align 8}-> N156
N156 -{%1 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N157
N156 -{%1 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N157
N157 -{%cmp = icmp eq %union.memory_leak_0012_uni_001* %1, null}-> N158
N157 -{%cmp = icmp eq %union.memory_leak_0012_uni_001* %1, null}-> N158
N158 -{[!(%cmp = icmp eq %union.memory_leak_0012_uni_001* %1, null)]}-> N177
N158 -{[%cmp = icmp eq %union.memory_leak_0012_uni_001* %1, null]}-> N174
N158 -{[!(%cmp = icmp eq %union.memory_leak_0012_uni_001* %1, null)]}-> N177
N158 -{[%cmp = icmp eq %union.memory_leak_0012_uni_001* %1, null]}-> N174
N177 -{%call1 = call i8* @malloc(i64 40, i64 @malloc)}-> N162
N177 -{%call1 = call i8* @malloc(i64 40, i64 @malloc)}-> N162
N162 -{%2 = bitcast i8* %call1 to %union.memory_leak_0012_uni_001*}-> N163
N162 -{%2 = bitcast i8* %call1 to %union.memory_leak_0012_uni_001*}-> N163
N163 -{store %union.memory_leak_0012_uni_001* %2, %union.memory_leak_0012_uni_001** %p, align 8}-> N164
N163 -{store %union.memory_leak_0012_uni_001* %2, %union.memory_leak_0012_uni_001** %p, align 8}-> N164
N164 -{%3 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N165
N164 -{%3 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N165
N165 -{store %union.memory_leak_0012_uni_001* %3, %union.memory_leak_0012_uni_001** %p, align 8}-> N166
N165 -{store %union.memory_leak_0012_uni_001* %3, %union.memory_leak_0012_uni_001** %p, align 8}-> N166
N166 -{%4 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %p, align 8}-> N167
N166 -{%4 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %p, align 8}-> N167
N167 -{%s1 = bitcast %union.memory_leak_0012_uni_001* %4 to %struct.memory_leak_0012_s_001*}-> N168
N167 -{%s1 = bitcast %union.memory_leak_0012_uni_001* %4 to %struct.memory_leak_0012_s_001*}-> N168
N168 -{%a = getelementptr inbounds %struct.memory_leak_0012_s_001, %struct.memory_leak_0012_s_001* %s1, i32 0, i32 0}-> N169
N168 -{%a = getelementptr inbounds %struct.memory_leak_0012_s_001, %struct.memory_leak_0012_s_001* %s1, i32 0, i32 0}-> N169
N169 -{store i32 1, i32* %a, align 4}-> N170
N169 -{store i32 1, i32* %a, align 4}-> N170
N170 -{%5 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N171
N170 -{%5 = load %union.memory_leak_0012_uni_001*, %union.memory_leak_0012_uni_001** %u, align 8}-> N171
N171 -{%6 = bitcast %union.memory_leak_0012_uni_001* %5 to i8*}-> N172
N171 -{%6 = bitcast %union.memory_leak_0012_uni_001* %5 to i8*}-> N172
N172 -{call void @free(i8* %6, i8* @free)}-> N174
N172 -{call void @free(i8* %6, i8* @free)}-> N174
N174 -{ret void}-> N148
N174 -{ret void}-> N148
N148 -{Return edge from memory_leak_0012_bad to main}-> N146
N148 -{Return edge from memory_leak_0012_bad to main}-> N146
N146 -{ret i32 0}-> N140
N146 -{ret i32 0}-> N140
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N148
On edge  : N148 -{Return edge from memory_leak_0012_bad to main}-> N146
Message  : the heap object @H(memory_leak_0012_bad::call1) is not referenced any more
> Start from entry function: main, At N141 of Function main
> Entering function: memory_leak_0012_good, On N144 -> N179 (call memory_leak_0012_good)
> takes the false branch, At N192 of Function memory_leak_0012_good
> Leaving function: memory_leak_0012_good, On N178 -> N145 (Return edge from memory_leak_0012_good to main)
> Entering function: memory_leak_0012_bad, On N145 -> N149 (call memory_leak_0012_bad)
> takes the false branch, At N158 of Function memory_leak_0012_bad
<Defect> : N148 -> N146: [Return edge from memory_leak_0012_bad to main]
N148 -> N146: [Return edge from memory_leak_0012_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_12.c 77] memory_leak_0012_bad 		[N148 -{Return edge from memory_leak_0012_bad to main}-> N146]	(the heap object @H(memory_leak_0012_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_13.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0013_good]
 +memory_leak_0013_good
SCC(1): [memory_leak_0013_bad]
 +memory_leak_0013_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_0013_good, main, memory_leak_0013_bad]
Loops     []
----
function: main
P+ = [H(memory_leak_0013_bad::call1), H(memory_leak_0013_good::call1)] 
P- = [H(memory_leak_0013_bad::call), H(memory_leak_0013_bad::call1), H(memory_leak_0013_good::call), H(memory_leak_0013_good::call1)] 
Point-To:
H(memory_leak_0013_bad::call) -> [H(memory_leak_0013_bad::call1)]
H(memory_leak_0013_good::call) -> [N, H(memory_leak_0013_good::call1)]
Ret-Value: R
----
function: memory_leak_0013_bad
P+ = [H(memory_leak_0013_bad::call1)] 
P- = [H(memory_leak_0013_bad::call), H(memory_leak_0013_bad::call1)] 
Point-To:
H(memory_leak_0013_bad::call) -> [H(memory_leak_0013_bad::call1)]
Ret-Value: 
----
function: memory_leak_0013_good
P+ = [H(memory_leak_0013_good::call1)] 
P- = [H(memory_leak_0013_good::call), H(memory_leak_0013_good::call1)] 
Point-To:
H(memory_leak_0013_good::call) -> [N, H(memory_leak_0013_good::call1)]
Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.032s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N206): +oo]
> [1/1] entry: main ()
N206 -{%retval = alloca i32, align 4}-> N208
N208 -{store i32 0, i32* %retval, align 4}-> N209
N209 -{call memory_leak_0013_good}-> N260
N260 -{%u = alloca %union.memory_leak_0013_uni_001*, align 8}-> N262
N262 -{%p = alloca %union.memory_leak_0013_uni_001*, align 8}-> N264
N264 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N265
N264 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N265
N265 -{%0 = bitcast i8* %call to %union.memory_leak_0013_uni_001*}-> N266
N265 -{%0 = bitcast i8* %call to %union.memory_leak_0013_uni_001*}-> N266
N266 -{store %union.memory_leak_0013_uni_001* %0, %union.memory_leak_0013_uni_001** %u, align 8}-> N267
N266 -{store %union.memory_leak_0013_uni_001* %0, %union.memory_leak_0013_uni_001** %u, align 8}-> N267
N267 -{%1 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N268
N267 -{%1 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N268
N268 -{%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null}-> N269
N268 -{%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null}-> N269
N269 -{[%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null]}-> N302
N269 -{[!(%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null)]}-> N277
N269 -{[%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null]}-> N302
N269 -{[!(%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null)]}-> N277
N302 -{%call1 = call i8* @malloc(i64 8, i64 @malloc)}-> N271
N302 -{%call1 = call i8* @malloc(i64 8, i64 @malloc)}-> N271
N271 -{%2 = bitcast i8* %call1 to %struct.memory_leak_0013_s_001*}-> N272
N271 -{%2 = bitcast i8* %call1 to %struct.memory_leak_0013_s_001*}-> N272
N272 -{%3 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N273
N272 -{%3 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N273
N273 -{%s1 = bitcast %union.memory_leak_0013_uni_001* %3 to %struct.memory_leak_0013_s_001**}-> N274
N273 -{%s1 = bitcast %union.memory_leak_0013_uni_001* %3 to %struct.memory_leak_0013_s_001**}-> N274
N274 -{store %struct.memory_leak_0013_s_001* %2, %struct.memory_leak_0013_s_001** %s1, align 8}-> N277
N274 -{store %struct.memory_leak_0013_s_001* %2, %struct.memory_leak_0013_s_001** %s1, align 8}-> N277
N277 -{store %union.memory_leak_0013_uni_001* null, %union.memory_leak_0013_uni_001** %p, align 8}-> N278
N277 -{store %union.memory_leak_0013_uni_001* null, %union.memory_leak_0013_uni_001** %p, align 8}-> N278
N277 -{store %union.memory_leak_0013_uni_001* null, %union.memory_leak_0013_uni_001** %p, align 8}-> N278
N278 -{%4 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N279
N278 -{%4 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N279
N278 -{%4 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N279
N279 -{%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null}-> N280
N279 -{%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null}-> N280
N279 -{%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null}-> N280
N280 -{[%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null]}-> N304
N280 -{[!(%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null)]}-> N300
N280 -{[%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null]}-> N304
N280 -{[!(%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null)]}-> N300
N280 -{[%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null]}-> N304
N280 -{[!(%cmp2 = icmp ne %union.memory_leak_0013_uni_001* %4, null)]}-> N300
N304 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N282
N304 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N282
N282 -{store %union.memory_leak_0013_uni_001* %5, %union.memory_leak_0013_uni_001** %p, align 8}-> N283
N282 -{store %union.memory_leak_0013_uni_001* %5, %union.memory_leak_0013_uni_001** %p, align 8}-> N283
N283 -{%6 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N284
N283 -{%6 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N284
N284 -{%s14 = bitcast %union.memory_leak_0013_uni_001* %6 to %struct.memory_leak_0013_s_001**}-> N285
N284 -{%s14 = bitcast %union.memory_leak_0013_uni_001* %6 to %struct.memory_leak_0013_s_001**}-> N285
N285 -{%7 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s14, align 8}-> N286
N285 -{%7 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s14, align 8}-> N286
N286 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N287
N286 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N287
N287 -{store i32 1, i32* %a, align 4}-> N288
N288 -{%8 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N289
N289 -{%s15 = bitcast %union.memory_leak_0013_uni_001* %8 to %struct.memory_leak_0013_s_001**}-> N290
N290 -{%9 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s15, align 8}-> N291
N291 -{%10 = bitcast %struct.memory_leak_0013_s_001* %9 to i8*}-> N292
N292 -{call void @free(i8* %10, i8* @free)}-> N293
N293 -{%11 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N294
N294 -{%s16 = bitcast %union.memory_leak_0013_uni_001* %11 to %struct.memory_leak_0013_s_001**}-> N295
N295 -{store %struct.memory_leak_0013_s_001* null, %struct.memory_leak_0013_s_001** %s16, align 8}-> N296
N296 -{%12 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N297
N297 -{%13 = bitcast %union.memory_leak_0013_uni_001* %12 to i8*}-> N298
N298 -{call void @free(i8* %13, i8* @free)}-> N300
N300 -{ret void}-> N259
N259 -{Return edge from memory_leak_0013_good to main}-> N210
N210 -{call memory_leak_0013_bad}-> N214
N214 -{%u = alloca %union.memory_leak_0013_uni_001*, align 8}-> N216
N216 -{%p = alloca %union.memory_leak_0013_uni_001*, align 8}-> N218
N218 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N219
N218 -{%call = call i8* @malloc(i64 40, i64 @malloc)}-> N219
N219 -{%0 = bitcast i8* %call to %union.memory_leak_0013_uni_001*}-> N220
N219 -{%0 = bitcast i8* %call to %union.memory_leak_0013_uni_001*}-> N220
N220 -{store %union.memory_leak_0013_uni_001* %0, %union.memory_leak_0013_uni_001** %u, align 8}-> N221
N220 -{store %union.memory_leak_0013_uni_001* %0, %union.memory_leak_0013_uni_001** %u, align 8}-> N221
N221 -{%1 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N222
N221 -{%1 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N222
N222 -{%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null}-> N223
N222 -{%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null}-> N223
N223 -{[%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null]}-> N255
N223 -{[!(%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null)]}-> N231
N223 -{[%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null]}-> N255
N223 -{[!(%cmp = icmp ne %union.memory_leak_0013_uni_001* %1, null)]}-> N231
N255 -{%call1 = call i8* @malloc(i64 8, i64 @malloc)}-> N225
N255 -{%call1 = call i8* @malloc(i64 8, i64 @malloc)}-> N225
N225 -{%2 = bitcast i8* %call1 to %struct.memory_leak_0013_s_001*}-> N226
N225 -{%2 = bitcast i8* %call1 to %struct.memory_leak_0013_s_001*}-> N226
N226 -{%3 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N227
N226 -{%3 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N227
N227 -{%s1 = bitcast %union.memory_leak_0013_uni_001* %3 to %struct.memory_leak_0013_s_001**}-> N228
N227 -{%s1 = bitcast %union.memory_leak_0013_uni_001* %3 to %struct.memory_leak_0013_s_001**}-> N228
N228 -{store %struct.memory_leak_0013_s_001* %2, %struct.memory_leak_0013_s_001** %s1, align 8}-> N231
N228 -{store %struct.memory_leak_0013_s_001* %2, %struct.memory_leak_0013_s_001** %s1, align 8}-> N231
N231 -{%call2 = call i8* @malloc(i64 40, i64 @malloc)}-> N232
N231 -{%call2 = call i8* @malloc(i64 40, i64 @malloc)}-> N232
N231 -{%call2 = call i8* @malloc(i64 40, i64 @malloc)}-> N232
N231 -{%call2 = call i8* @malloc(i64 40, i64 @malloc)}-> N232
N231 -{%call2 = call i8* @malloc(i64 40, i64 @malloc)}-> N232
N231 -{%call2 = call i8* @malloc(i64 40, i64 @malloc)}-> N232
N232 -{%4 = bitcast i8* %call2 to %union.memory_leak_0013_uni_001*}-> N233
N232 -{%4 = bitcast i8* %call2 to %union.memory_leak_0013_uni_001*}-> N233
N232 -{%4 = bitcast i8* %call2 to %union.memory_leak_0013_uni_001*}-> N233
N232 -{%4 = bitcast i8* %call2 to %union.memory_leak_0013_uni_001*}-> N233
N232 -{%4 = bitcast i8* %call2 to %union.memory_leak_0013_uni_001*}-> N233
N232 -{%4 = bitcast i8* %call2 to %union.memory_leak_0013_uni_001*}-> N233
N233 -{store %union.memory_leak_0013_uni_001* %4, %union.memory_leak_0013_uni_001** %p, align 8}-> N234
N233 -{store %union.memory_leak_0013_uni_001* %4, %union.memory_leak_0013_uni_001** %p, align 8}-> N234
N233 -{store %union.memory_leak_0013_uni_001* %4, %union.memory_leak_0013_uni_001** %p, align 8}-> N234
N233 -{store %union.memory_leak_0013_uni_001* %4, %union.memory_leak_0013_uni_001** %p, align 8}-> N234
N233 -{store %union.memory_leak_0013_uni_001* %4, %union.memory_leak_0013_uni_001** %p, align 8}-> N234
N233 -{store %union.memory_leak_0013_uni_001* %4, %union.memory_leak_0013_uni_001** %p, align 8}-> N234
N234 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N235
N234 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N235
N234 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N235
N234 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N235
N234 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N235
N234 -{%5 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N235
N235 -{%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null}-> N236
N235 -{%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null}-> N236
N235 -{%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null}-> N236
N235 -{%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null}-> N236
N235 -{%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null}-> N236
N235 -{%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null}-> N236
N236 -{[%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null]}-> N257
N236 -{[!(%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null)]}-> N253
N236 -{[%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null]}-> N257
N236 -{[!(%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null)]}-> N253
N236 -{[%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null]}-> N257
N236 -{[!(%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null)]}-> N253
N236 -{[%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null]}-> N257
N236 -{[!(%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null)]}-> N253
N236 -{[%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null]}-> N257
N236 -{[!(%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null)]}-> N253
N236 -{[%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null]}-> N257
N236 -{[!(%cmp3 = icmp ne %union.memory_leak_0013_uni_001* %5, null)]}-> N253
N257 -{%6 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N238
N257 -{%6 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N238
N257 -{%6 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N238
N257 -{%6 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %u, align 8}-> N238
N238 -{store %union.memory_leak_0013_uni_001* %6, %union.memory_leak_0013_uni_001** %p, align 8}-> N239
N238 -{store %union.memory_leak_0013_uni_001* %6, %union.memory_leak_0013_uni_001** %p, align 8}-> N239
N238 -{store %union.memory_leak_0013_uni_001* %6, %union.memory_leak_0013_uni_001** %p, align 8}-> N239
N238 -{store %union.memory_leak_0013_uni_001* %6, %union.memory_leak_0013_uni_001** %p, align 8}-> N239
N239 -{%7 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N240
N239 -{%7 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N240
N239 -{%7 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N240
N239 -{%7 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N240
N240 -{%s15 = bitcast %union.memory_leak_0013_uni_001* %7 to %struct.memory_leak_0013_s_001**}-> N241
N240 -{%s15 = bitcast %union.memory_leak_0013_uni_001* %7 to %struct.memory_leak_0013_s_001**}-> N241
N240 -{%s15 = bitcast %union.memory_leak_0013_uni_001* %7 to %struct.memory_leak_0013_s_001**}-> N241
N240 -{%s15 = bitcast %union.memory_leak_0013_uni_001* %7 to %struct.memory_leak_0013_s_001**}-> N241
N241 -{%8 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s15, align 8}-> N242
N241 -{%8 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s15, align 8}-> N242
N241 -{%8 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s15, align 8}-> N242
N241 -{%8 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s15, align 8}-> N242
N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243
N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243
N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243
N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243
N243 -{store i32 1, i32* %a, align 4}-> N244
N243 -{store i32 1, i32* %a, align 4}-> N244
N244 -{%9 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N245
N244 -{%9 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N245
N245 -{%s16 = bitcast %union.memory_leak_0013_uni_001* %9 to %struct.memory_leak_0013_s_001**}-> N246
N245 -{%s16 = bitcast %union.memory_leak_0013_uni_001* %9 to %struct.memory_leak_0013_s_001**}-> N246
N246 -{%10 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s16, align 8}-> N247
N246 -{%10 = load %struct.memory_leak_0013_s_001*, %struct.memory_leak_0013_s_001** %s16, align 8}-> N247
N247 -{%11 = bitcast %struct.memory_leak_0013_s_001* %10 to i8*}-> N248
N247 -{%11 = bitcast %struct.memory_leak_0013_s_001* %10 to i8*}-> N248
N248 -{call void @free(i8* %11, i8* @free)}-> N249
N248 -{call void @free(i8* %11, i8* @free)}-> N249
N249 -{%12 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N250
N249 -{%12 = load %union.memory_leak_0013_uni_001*, %union.memory_leak_0013_uni_001** %p, align 8}-> N250
N250 -{%13 = bitcast %union.memory_leak_0013_uni_001* %12 to i8*}-> N251
N250 -{%13 = bitcast %union.memory_leak_0013_uni_001* %12 to i8*}-> N251
N251 -{call void @free(i8* %13, i8* @free)}-> N253
N251 -{call void @free(i8* %13, i8* @free)}-> N253
N253 -{ret void}-> N213
N253 -{ret void}-> N213
N213 -{Return edge from memory_leak_0013_bad to main}-> N211
N213 -{Return edge from memory_leak_0013_bad to main}-> N211
N211 -{ret i32 0}-> N205
N211 -{ret i32 0}-> N205
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N213
On edge  : N213 -{Return edge from memory_leak_0013_bad to main}-> N211
Message  : the heap object @H(memory_leak_0013_bad::call2) is not referenced any more
> Start from entry function: main, At N206 of Function main
> Entering function: memory_leak_0013_good, On N209 -> N260 (call memory_leak_0013_good)
> takes the false branch, At N269 of Function memory_leak_0013_good
> takes the false branch, At N280 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N259 -> N210 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N210 -> N214 (call memory_leak_0013_bad)
> takes the false branch, At N223 of Function memory_leak_0013_bad
> takes the false branch, At N236 of Function memory_leak_0013_bad
<Defect> : N213 -> N211: [Return edge from memory_leak_0013_bad to main]
N213 -> N211: [Return edge from memory_leak_0013_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N286
On edge  : N286 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N287
Message  : null pointer dereference
> Start from entry function: main, At N206 of Function main
> Entering function: memory_leak_0013_good, On N209 -> N260 (call memory_leak_0013_good)
> takes the true branch, At N269 of Function memory_leak_0013_good
> takes the true branch, At N280 of Function memory_leak_0013_good
<Defect> : N286 -> N287: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0]
N286 -> N287: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N242
On edge  : N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243
Message  : null pointer dereference
> Start from entry function: main, At N206 of Function main
> Entering function: memory_leak_0013_good, On N209 -> N260 (call memory_leak_0013_good)
> takes the false branch, At N269 of Function memory_leak_0013_good
> takes the false branch, At N280 of Function memory_leak_0013_good
> Leaving function: memory_leak_0013_good, On N259 -> N210 (Return edge from memory_leak_0013_good to main)
> Entering function: memory_leak_0013_bad, On N210 -> N214 (call memory_leak_0013_bad)
> takes the true branch, At N223 of Function memory_leak_0013_bad
> takes the true branch, At N236 of Function memory_leak_0013_bad
<Defect> : N242 -> N243: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0]
N242 -> N243: [%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_13.c 89] memory_leak_0013_bad 		[N213 -{Return edge from memory_leak_0013_bad to main}-> N211]	(the heap object @H(memory_leak_0013_bad::call2) is not referenced any more)

CWE_476(Null Pointer Dereference): 2
	[./401_memory_leak_13.c 74] memory_leak_0013_good 		[N286 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %7, i32 0, i32 0}-> N287]	(null pointer dereference)
	[./401_memory_leak_13.c 51] memory_leak_0013_bad 		[N242 -{%a = getelementptr inbounds %struct.memory_leak_0013_s_001, %struct.memory_leak_0013_s_001* %8, i32 0, i32 0}-> N243]	(null pointer dereference)

Found 3 defects in all (3 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_14.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_0014_bad]
 +memory_leak_0014_bad
SCC(1): [memory_leak_0014_good]
 +memory_leak_0014_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_0014_good, main, memory_leak_0014_bad]
Loops     []
----
function: main
P+ = [] 
P- = [N, H(memory_leak_0014_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0014_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_0014_good
P+ = [] 
P- = [N, H(memory_leak_0014_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.008s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N307): +oo]
> [1/1] entry: main ()
N307 -{%retval = alloca i32, align 4}-> N309
N309 -{store i32 0, i32* %retval, align 4}-> N310
N310 -{call memory_leak_0014_good}-> N353
N353 -{%fptr = alloca float*, align 8}-> N355
N355 -{%fp1 = alloca float**, align 8}-> N356
N356 -{%fp2 = alloca float**, align 8}-> N357
N357 -{%fptr1 = alloca float*, align 8}-> N358
N358 -{%fptr2 = alloca float*, align 8}-> N361
N361 -{store float** %fptr, float*** %fp1, align 8}-> N363
N363 -{store float** %fptr, float*** %fp2, align 8}-> N364
N364 -{store float* null, float** %fptr, align 8}-> N366
N366 -{%0 = load float**, float*** %fp1, align 8}-> N367
N367 -{%1 = load float*, float** %0, align 8}-> N368
N368 -{store float* %1, float** %fptr1, align 8}-> N369
N369 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N370
N369 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N370
N370 -{%2 = bitcast i8* %call to float*}-> N371
N370 -{%2 = bitcast i8* %call to float*}-> N371
N371 -{store float* %2, float** %fptr1, align 8}-> N372
N371 -{store float* %2, float** %fptr1, align 8}-> N372
N372 -{%3 = load float*, float** %fptr1, align 8}-> N373
N372 -{%3 = load float*, float** %fptr1, align 8}-> N373
N373 -{%cmp = icmp ne float* %3, null}-> N374
N373 -{%cmp = icmp ne float* %3, null}-> N374
N374 -{[%cmp = icmp ne float* %3, null]}-> N391
N374 -{[!(%cmp = icmp ne float* %3, null)]}-> N383
N374 -{[%cmp = icmp ne float* %3, null]}-> N391
N374 -{[!(%cmp = icmp ne float* %3, null)]}-> N383
N391 -{%4 = load float*, float** %fptr1, align 8}-> N376
N376 -{%add.ptr = getelementptr inbounds float, float* %4, i64 3}-> N377
N377 -{store float 5.050000e+01, float* %add.ptr, align 4}-> N378
N378 -{%5 = load float*, float** %fptr1, align 8}-> N379
N379 -{%6 = load float**, float*** %fp1, align 8}-> N380
N380 -{store float* %5, float** %6, align 8}-> N383
N383 -{%7 = load float**, float*** %fp2, align 8}-> N384
N383 -{%7 = load float**, float*** %fp2, align 8}-> N384
N384 -{%8 = load float*, float** %7, align 8}-> N385
N384 -{%8 = load float*, float** %7, align 8}-> N385
N385 -{store float* %8, float** %fptr2, align 8}-> N386
N385 -{store float* %8, float** %fptr2, align 8}-> N386
N386 -{%9 = load float*, float** %fptr2, align 8}-> N387
N386 -{%9 = load float*, float** %fptr2, align 8}-> N387
N387 -{%10 = bitcast float* %9 to i8*}-> N388
N387 -{%10 = bitcast float* %9 to i8*}-> N388
N388 -{call void @free(i8* %10, i8* @free)}-> N389
N388 -{call void @free(i8* %10, i8* @free)}-> N389
N389 -{ret void}-> N352
N352 -{Return edge from memory_leak_0014_good to main}-> N311
N311 -{call memory_leak_0014_bad}-> N315
N315 -{%fptr = alloca float*, align 8}-> N317
N317 -{%fp1 = alloca float**, align 8}-> N318
N318 -{%fp2 = alloca float**, align 8}-> N319
N319 -{%fptr1 = alloca float*, align 8}-> N320
N320 -{%fptr12 = alloca float*, align 8}-> N323
N323 -{store float** %fptr, float*** %fp1, align 8}-> N325
N325 -{store float** %fptr, float*** %fp2, align 8}-> N326
N326 -{store float* null, float** %fptr, align 8}-> N328
N328 -{%0 = load float**, float*** %fp1, align 8}-> N329
N329 -{%1 = load float*, float** %0, align 8}-> N330
N330 -{store float* %1, float** %fptr1, align 8}-> N331
N331 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N332
N331 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N332
N332 -{%2 = bitcast i8* %call to float*}-> N333
N332 -{%2 = bitcast i8* %call to float*}-> N333
N333 -{store float* %2, float** %fptr1, align 8}-> N334
N333 -{store float* %2, float** %fptr1, align 8}-> N334
N334 -{%3 = load float*, float** %fptr1, align 8}-> N335
N334 -{%3 = load float*, float** %fptr1, align 8}-> N335
N335 -{%cmp = icmp ne float* %3, null}-> N336
N335 -{%cmp = icmp ne float* %3, null}-> N336
N336 -{[%cmp = icmp ne float* %3, null]}-> N350
N336 -{[!(%cmp = icmp ne float* %3, null)]}-> N345
N336 -{[%cmp = icmp ne float* %3, null]}-> N350
N336 -{[!(%cmp = icmp ne float* %3, null)]}-> N345
N350 -{%4 = load float*, float** %fptr1, align 8}-> N338
N338 -{%add.ptr = getelementptr inbounds float, float* %4, i64 3}-> N339
N339 -{store float 5.050000e+01, float* %add.ptr, align 4}-> N340
N340 -{%5 = load float*, float** %fptr1, align 8}-> N341
N341 -{%6 = load float**, float*** %fp1, align 8}-> N342
N342 -{store float* %5, float** %6, align 8}-> N345
N345 -{%7 = load float**, float*** %fp2, align 8}-> N346
N345 -{%7 = load float**, float*** %fp2, align 8}-> N346
N346 -{%8 = load float*, float** %7, align 8}-> N347
N346 -{%8 = load float*, float** %7, align 8}-> N347
N347 -{store float* %8, float** %fptr12, align 8}-> N348
N347 -{store float* %8, float** %fptr12, align 8}-> N348
N348 -{ret void}-> N314
N348 -{ret void}-> N314
N314 -{Return edge from memory_leak_0014_bad to main}-> N312
N314 -{Return edge from memory_leak_0014_bad to main}-> N312
N312 -{ret i32 0}-> N306
N312 -{ret i32 0}-> N306
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N314
On edge  : N314 -{Return edge from memory_leak_0014_bad to main}-> N312
Message  : the heap object @H(memory_leak_0014_bad::call) is not referenced any more
> Start from entry function: main, At N307 of Function main
> Entering function: memory_leak_0014_good, On N310 -> N353 (call memory_leak_0014_good)
> takes the false branch, At N374 of Function memory_leak_0014_good
> Leaving function: memory_leak_0014_good, On N352 -> N311 (Return edge from memory_leak_0014_good to main)
> Entering function: memory_leak_0014_bad, On N311 -> N315 (call memory_leak_0014_bad)
> takes the true branch, At N336 of Function memory_leak_0014_bad
<Defect> : N314 -> N312: [Return edge from memory_leak_0014_bad to main]
N314 -> N312: [Return edge from memory_leak_0014_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N388
On edge  : N388 -{call void @free(i8* %10, i8* @free)}-> N389
Message  : null pointer dereference
> Start from entry function: main, At N307 of Function main
> Entering function: memory_leak_0014_good, On N310 -> N353 (call memory_leak_0014_good)
> takes the false branch, At N374 of Function memory_leak_0014_good
<Defect> : N388 -> N389: [call void @free(i8* %10, i8* @free)]
N388 -> N389: [call void @free(i8* %10, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_14.c 71] memory_leak_0014_bad 		[N314 -{Return edge from memory_leak_0014_bad to main}-> N312]	(the heap object @H(memory_leak_0014_bad::call) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[./401_memory_leak_14.c 59] memory_leak_0014_good 		[N388 -{call void @free(i8* %10, i8* @free)}-> N389]	(null pointer dereference)

Found 2 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_15.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_0015_func_001_good]
 +memory_leak_0015_func_001_good
SCC(1): [memory_leak_0015_good]
 +memory_leak_0015_good
SCC(1): [memory_leak_0015_func_001_bad]
 +memory_leak_0015_func_001_bad
SCC(1): [memory_leak_0015_bad]
 +memory_leak_0015_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_0015_bad, memory_leak_0015_func_001_bad, memory_leak_0015_func_001_good, memory_leak_0015_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_0015_func_001_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_0015_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_0015_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: H(memory_leak_0015_func_001_bad::call)
----
function: memory_leak_0015_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: H(memory_leak_0015_func_001_good::call)
----
function: memory_leak_0015_good
P+ = [] 
P- = [H(memory_leak_0015_func_001_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.03s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N394): +oo]
> [1/1] entry: main ()
N394 -{global: .str}-> N481
N481 -{%retval = alloca i32, align 4}-> N396
N396 -{store i32 0, i32* %retval, align 4}-> N397
N397 -{call memory_leak_0015_good}-> N457
N457 -{%str = alloca i8*, align 8}-> N459
N459 -{%str1 = alloca i8*, align 8}-> N461
N461 -{store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8** %str, align 8}-> N463
N463 -{%0 = load i8*, i8** %str, align 8}-> N464
N464 -{%call = call i64 @strlen(i8* %0, i8* @strlen)}-> N465
N465 -{%conv = trunc i64 %call to i32}-> N466
N466 -{call memory_leak_0015_func_001_good}-> N441
N441 -{%len.addr = alloca i32, align 4}-> N443
N443 -{%stringPtr = alloca i8*, align 8}-> N444
N444 -{store i32 %len, i32* %len.addr, align 4}-> N447
N447 -{%0 = load i32, i32* %len.addr, align 4}-> N448
N448 -{%add = add i32 %0, 1}-> N449
N449 -{%conv = sext i32 %add to i64}-> N450
N450 -{%mul = mul i64 1, %conv}-> N451
N451 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N452
N451 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N452
N452 -{store i8* %call, i8** %stringPtr, align 8}-> N453
N452 -{store i8* %call, i8** %stringPtr, align 8}-> N453
N453 -{%1 = load i8*, i8** %stringPtr, align 8}-> N454
N453 -{%1 = load i8*, i8** %stringPtr, align 8}-> N454
N454 -{ret i8* %1}-> N440
N454 -{ret i8* %1}-> N440
N440 -{Return edge from memory_leak_0015_func_001_good to memory_leak_0015_good}-> N467
N440 -{Return edge from memory_leak_0015_func_001_good to memory_leak_0015_good}-> N467
N467 -{store i8* %call1, i8** %str1, align 8}-> N468
N467 -{store i8* %call1, i8** %str1, align 8}-> N468
N468 -{%1 = load i8*, i8** %str1, align 8}-> N469
N468 -{%1 = load i8*, i8** %str1, align 8}-> N469
N469 -{%cmp = icmp ne i8* %1, null}-> N470
N469 -{%cmp = icmp ne i8* %1, null}-> N470
N470 -{[%cmp = icmp ne i8* %1, null]}-> N479
N470 -{[!(%cmp = icmp ne i8* %1, null)]}-> N477
N470 -{[%cmp = icmp ne i8* %1, null]}-> N479
N470 -{[!(%cmp = icmp ne i8* %1, null)]}-> N477
N479 -{%2 = load i8*, i8** %str1, align 8}-> N472
N472 -{%3 = load i8*, i8** %str, align 8}-> N473
N473 -{%call3 = call i8* @strcpy(i8* %2, i8* %3, i8* @strcpy)}-> N474
N474 -{%4 = load i8*, i8** %str1, align 8}-> N475
N475 -{call void @free(i8* %4, i8* @free)}-> N477
N477 -{ret void}-> N456
N456 -{Return edge from memory_leak_0015_good to main}-> N398
N398 -{call memory_leak_0015_bad}-> N402
N402 -{%str = alloca i8*, align 8}-> N404
N404 -{%str1 = alloca i8*, align 8}-> N406
N406 -{store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8** %str, align 8}-> N408
N408 -{%0 = load i8*, i8** %str, align 8}-> N409
N409 -{%call = call i64 @strlen(i8* %0, i8* @strlen)}-> N410
N410 -{%conv = trunc i64 %call to i32}-> N411
N411 -{call memory_leak_0015_func_001_bad}-> N425
N425 -{%len.addr = alloca i32, align 4}-> N427
N427 -{%stringPtr = alloca i8*, align 8}-> N428
N428 -{store i32 %len, i32* %len.addr, align 4}-> N431
N431 -{%0 = load i32, i32* %len.addr, align 4}-> N432
N432 -{%add = add i32 %0, 1}-> N433
N433 -{%conv = sext i32 %add to i64}-> N434
N434 -{%mul = mul i64 1, %conv}-> N435
N435 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N436
N435 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N436
N436 -{store i8* %call, i8** %stringPtr, align 8}-> N437
N436 -{store i8* %call, i8** %stringPtr, align 8}-> N437
N437 -{%1 = load i8*, i8** %stringPtr, align 8}-> N438
N437 -{%1 = load i8*, i8** %stringPtr, align 8}-> N438
N438 -{ret i8* %1}-> N424
N438 -{ret i8* %1}-> N424
N424 -{Return edge from memory_leak_0015_func_001_bad to memory_leak_0015_bad}-> N412
N424 -{Return edge from memory_leak_0015_func_001_bad to memory_leak_0015_bad}-> N412
N412 -{store i8* %call1, i8** %str1, align 8}-> N413
N412 -{store i8* %call1, i8** %str1, align 8}-> N413
N413 -{%1 = load i8*, i8** %str1, align 8}-> N414
N413 -{%1 = load i8*, i8** %str1, align 8}-> N414
N414 -{%cmp = icmp ne i8* %1, null}-> N415
N414 -{%cmp = icmp ne i8* %1, null}-> N415
N415 -{[%cmp = icmp ne i8* %1, null]}-> N422
N415 -{[!(%cmp = icmp ne i8* %1, null)]}-> N420
N415 -{[%cmp = icmp ne i8* %1, null]}-> N422
N415 -{[!(%cmp = icmp ne i8* %1, null)]}-> N420
N422 -{%2 = load i8*, i8** %str1, align 8}-> N417
N417 -{%3 = load i8*, i8** %str, align 8}-> N418
N418 -{%call3 = call i8* @strcpy(i8* %2, i8* %3, i8* @strcpy)}-> N420
N420 -{ret void}-> N401
N420 -{ret void}-> N401
N401 -{Return edge from memory_leak_0015_bad to main}-> N399
N401 -{Return edge from memory_leak_0015_bad to main}-> N399
N399 -{ret i32 0}-> N393
N399 -{ret i32 0}-> N393
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N401
On edge  : N401 -{Return edge from memory_leak_0015_bad to main}-> N399
Message  : the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N394 of Function main
> Entering function: memory_leak_0015_good, On N397 -> N457 (call memory_leak_0015_good)
> Entering function: memory_leak_0015_func_001_good, On N466 -> N441 (call memory_leak_0015_func_001_good)
> Leaving function: memory_leak_0015_func_001_good, On N440 -> N467 (Return edge from memory_leak_0015_func_001_good to memory_leak_0015_good)
> takes the false branch, At N470 of Function memory_leak_0015_good
> Leaving function: memory_leak_0015_good, On N456 -> N398 (Return edge from memory_leak_0015_good to main)
> Entering function: memory_leak_0015_bad, On N398 -> N402 (call memory_leak_0015_bad)
> Entering function: memory_leak_0015_func_001_bad, On N411 -> N425 (call memory_leak_0015_func_001_bad)
> Leaving function: memory_leak_0015_func_001_bad, On N424 -> N412 (Return edge from memory_leak_0015_func_001_bad to memory_leak_0015_bad)
> takes the true branch, At N415 of Function memory_leak_0015_bad
<Defect> : N401 -> N399: [Return edge from memory_leak_0015_bad to main]
N401 -> N399: [Return edge from memory_leak_0015_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_15.c 63] memory_leak_0015_bad 		[N401 -{Return edge from memory_leak_0015_bad to main}-> N399]	(the heap object @H(memory_leak_0015_func_001_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_1.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_001_good]
 +memory_leak_001_good
SCC(1): [memory_leak_001_bad]
 +memory_leak_001_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_001_bad, memory_leak_001_good]
Loops     [N529, N498]
----
function: main
P+ = [] 
P- = [H(memory_leak_001_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_001_good
P+ = [] 
P- = [H(memory_leak_001_good::call)] 
Point-To:

Ret-Value: 
----
loop N498 in memory_leak_001_bad: 
N498 -> P+ = [H(memory_leak_001_bad::call)], P- = [] Point-To: L(memory_leak_001_bad::buf) -> [H(memory_leak_001_bad::call)]
N500 -> P+ = [H(memory_leak_001_bad::call)], P- = [] Point-To: L(memory_leak_001_bad::buf) -> [H(memory_leak_001_bad::call)]
----
loop N529 in memory_leak_001_good: 
N529 -> P+ = [H(memory_leak_001_good::call)], P- = [H(memory_leak_001_good::call)] Point-To: L(memory_leak_001_good::buf) -> [H(memory_leak_001_good::call)]
N531 -> P+ = [H(memory_leak_001_good::call)], P- = [H(memory_leak_001_good::call)] Point-To: L(memory_leak_001_good::buf) -> [H(memory_leak_001_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.091s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N483): +oo]
> [1/1] entry: main ()
N483 -{%retval = alloca i32, align 4}-> N485
N485 -{store i32 0, i32* %retval, align 4}-> N486
N486 -{call memory_leak_001_good}-> N522
N522 -{%i = alloca i32, align 4}-> N524
N524 -{%buf = alloca i8*, align 8}-> N527
N527 -{store i32 0, i32* %i, align 4}-> N529
N529 -{%0 = load i32, i32* %i, align 4}-> N530
N529 -{@}-> N529
N529 -{@}-> N531
N530 -{%cmp = icmp slt i32 %0, 1}-> N531
N531 -{[%cmp = icmp slt i32 %0, 1]}-> N550
N531 -{[!(%cmp = icmp slt i32 %0, 1)]}-> N551
N550 -{%call = call i8* @calloc(i64 5, i64 1, i64 @calloc)}-> N533
N550 -{%call = call i8* @calloc(i64 5, i64 1, i64 @calloc)}-> N533
N533 -{store i8* %call, i8** %buf, align 8}-> N534
N533 -{store i8* %call, i8** %buf, align 8}-> N534
N534 -{%1 = load i8*, i8** %buf, align 8}-> N535
N534 -{%1 = load i8*, i8** %buf, align 8}-> N535
N535 -{%cmp1 = icmp ne i8* %1, null}-> N536
N535 -{%cmp1 = icmp ne i8* %1, null}-> N536
N536 -{[%cmp1 = icmp ne i8* %1, null]}-> N552
N536 -{[!(%cmp1 = icmp ne i8* %1, null)]}-> N544
N536 -{[%cmp1 = icmp ne i8* %1, null]}-> N552
N536 -{[!(%cmp1 = icmp ne i8* %1, null)]}-> N544
N552 -{%2 = load i8*, i8** %buf, align 8}-> N538
N538 -{%add.ptr = getelementptr inbounds i8, i8* %2, i64 1}-> N539
N539 -{store i8 1, i8* %add.ptr, align 1}-> N540
N540 -{%3 = load i8*, i8** %buf, align 8}-> N541
N541 -{call void @free(i8* %3, i8* @free)}-> N544
N544 -{%4 = load i32, i32* %i, align 4}-> N545
N545 -{%inc = add i32 %4, 1}-> N546
N546 -{store i32 %inc, i32* %i, align 4}-> N529
N529 -{%0 = load i32, i32* %i, align 4}-> N530
N530 -{%cmp = icmp slt i32 %0, 1}-> N531
N531 -{[%cmp = icmp slt i32 %0, 1]}-> N550
N531 -{[!(%cmp = icmp slt i32 %0, 1)]}-> N551
N551 -{ret void}-> N521
N521 -{Return edge from memory_leak_001_good to main}-> N487
N487 -{call memory_leak_001_bad}-> N491
N491 -{%i = alloca i32, align 4}-> N493
N493 -{%buf = alloca i8*, align 8}-> N496
N496 -{store i32 0, i32* %i, align 4}-> N498
N498 -{%0 = load i32, i32* %i, align 4}-> N499
N498 -{@}-> N498
N498 -{@}-> N500
N499 -{%cmp = icmp slt i32 %0, 1}-> N500
N500 -{[%cmp = icmp slt i32 %0, 1]}-> N517
N500 -{[!(%cmp = icmp slt i32 %0, 1)]}-> N518
N517 -{%call = call i8* @calloc(i64 5, i64 1, i64 @calloc)}-> N502
N517 -{%call = call i8* @calloc(i64 5, i64 1, i64 @calloc)}-> N502
N502 -{store i8* %call, i8** %buf, align 8}-> N503
N502 -{store i8* %call, i8** %buf, align 8}-> N503
N503 -{%1 = load i8*, i8** %buf, align 8}-> N504
N503 -{%1 = load i8*, i8** %buf, align 8}-> N504
N504 -{%cmp1 = icmp ne i8* %1, null}-> N505
N504 -{%cmp1 = icmp ne i8* %1, null}-> N505
N505 -{[%cmp1 = icmp ne i8* %1, null]}-> N519
N505 -{[!(%cmp1 = icmp ne i8* %1, null)]}-> N511
N505 -{[%cmp1 = icmp ne i8* %1, null]}-> N519
N505 -{[!(%cmp1 = icmp ne i8* %1, null)]}-> N511
N519 -{%2 = load i8*, i8** %buf, align 8}-> N507
N507 -{%arrayidx = getelementptr inbounds i8, i8* %2, i64 0}-> N508
N508 -{store i8 1, i8* %arrayidx, align 1}-> N511
N511 -{%3 = load i32, i32* %i, align 4}-> N512
N511 -{%3 = load i32, i32* %i, align 4}-> N512
N512 -{%inc = add i32 %3, 1}-> N513
N512 -{%inc = add i32 %3, 1}-> N513
N513 -{store i32 %inc, i32* %i, align 4}-> N498
N513 -{store i32 %inc, i32* %i, align 4}-> N498
N498 -{%0 = load i32, i32* %i, align 4}-> N499
N498 -{%0 = load i32, i32* %i, align 4}-> N499
N499 -{%cmp = icmp slt i32 %0, 1}-> N500
N499 -{%cmp = icmp slt i32 %0, 1}-> N500
N500 -{[%cmp = icmp slt i32 %0, 1]}-> N517
N500 -{[!(%cmp = icmp slt i32 %0, 1)]}-> N518
N500 -{[%cmp = icmp slt i32 %0, 1]}-> N517
N500 -{[!(%cmp = icmp slt i32 %0, 1)]}-> N518
N518 -{ret void}-> N490
N518 -{ret void}-> N490
N490 -{Return edge from memory_leak_001_bad to main}-> N488
N490 -{Return edge from memory_leak_001_bad to main}-> N488
N488 -{ret i32 0}-> N482
N488 -{ret i32 0}-> N482
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N490
On edge  : N490 -{Return edge from memory_leak_001_bad to main}-> N488
Message  : the heap object @H(memory_leak_001_bad::call) is not referenced any more
> Start from entry function: main, At N483 of Function main
> Entering function: memory_leak_001_good, On N486 -> N522 (call memory_leak_001_good)
> takes the true branch, At N531 of Function memory_leak_001_good
> takes the false branch, At N536 of Function memory_leak_001_good
> takes the false branch, At N531 of Function memory_leak_001_good
> Leaving function: memory_leak_001_good, On N521 -> N487 (Return edge from memory_leak_001_good to main)
> Entering function: memory_leak_001_bad, On N487 -> N491 (call memory_leak_001_bad)
> takes the true branch, At N500 of Function memory_leak_001_bad
> takes the true branch, At N505 of Function memory_leak_001_bad
> takes the false branch, At N500 of Function memory_leak_001_bad
<Defect> : N490 -> N488: [Return edge from memory_leak_001_bad to main]
N490 -> N488: [Return edge from memory_leak_001_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_1.c 58] memory_leak_001_bad 		[N490 -{Return edge from memory_leak_001_bad to main}-> N488]	(the heap object @H(memory_leak_001_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_2.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_002_good]
 +memory_leak_002_good
SCC(1): [memory_leak_002_bad]
 +memory_leak_002_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_002_bad, memory_leak_002_good]
Loops     [N680, N580, N728, N699, N621]
----
function: main
P+ = [H(memory_leak_002_bad::call2), H(memory_leak_002_good::call2)] 
P- = [H(memory_leak_002_bad::call), H(memory_leak_002_good::call), H(memory_leak_002_good::call2)] 
Point-To:
H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]
H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]
Ret-Value: R
----
function: memory_leak_002_bad
P+ = [H(memory_leak_002_bad::call2)] 
P- = [H(memory_leak_002_bad::call)] 
Point-To:
H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]
Ret-Value: 
----
function: memory_leak_002_good
P+ = [H(memory_leak_002_good::call2)] 
P- = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)] 
Point-To:
H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]
Ret-Value: 
----
loop N580 in memory_leak_002_bad: 
N580 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
N596 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
N582 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
----
loop N621 in memory_leak_002_bad: 
N607 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
N610 -> P+ = [H(memory_leak_002_bad::call), H(memory_leak_002_bad::call2)], P- = [] Point-To: H(memory_leak_002_bad::call)[??] -> [H(memory_leak_002_bad::call2)]; L(memory_leak_002_bad::ptr) -> [H(memory_leak_002_bad::call)]
----
loop N680 in memory_leak_002_good: 
N680 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N696 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N682 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
----
loop N699 in memory_leak_002_good: 
N699 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N702 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
----
loop N728 in memory_leak_002_good: 
N728 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
N731 -> P+ = [H(memory_leak_002_good::call), H(memory_leak_002_good::call2)], P- = [H(memory_leak_002_good::call2)] Point-To: H(memory_leak_002_good::call)[??] -> [H(memory_leak_002_good::call2)]; L(memory_leak_002_good::ptr) -> [H(memory_leak_002_good::call)]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.151s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N555): +oo]
> [1/1] entry: main ()
N555 -{%retval = alloca i32, align 4}-> N557
N557 -{store i32 0, i32* %retval, align 4}-> N558
N558 -{call memory_leak_002_good}-> N663
N663 -{%ptr = alloca i32**, align 8}-> N665
N665 -{%i = alloca i32, align 4}-> N666
N666 -{%j = alloca i32, align 4}-> N667
N667 -{%index = alloca i32, align 4}-> N669
N669 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N670
N669 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N670
N670 -{%0 = bitcast i8* %call to i32**}-> N671
N670 -{%0 = bitcast i8* %call to i32**}-> N671
N671 -{store i32** %0, i32*** %ptr, align 8}-> N672
N671 -{store i32** %0, i32*** %ptr, align 8}-> N672
N672 -{%1 = load i32**, i32*** %ptr, align 8}-> N673
N672 -{%1 = load i32**, i32*** %ptr, align 8}-> N673
N673 -{%cmp = icmp eq i32** %1, null}-> N674
N673 -{%cmp = icmp eq i32** %1, null}-> N674
N674 -{[!(%cmp = icmp eq i32** %1, null)]}-> N771
N674 -{[%cmp = icmp eq i32** %1, null]}-> N768
N674 -{[!(%cmp = icmp eq i32** %1, null)]}-> N771
N674 -{[%cmp = icmp eq i32** %1, null]}-> N768
N771 -{store i32 0, i32* %i, align 4}-> N680
N680 -{%2 = load i32, i32* %i, align 4}-> N681
N680 -{@}-> N680
N680 -{@}-> N696
N680 -{@}-> N682
N681 -{%cmp1 = icmp slt i32 %2, 2}-> N682
N682 -{[%cmp1 = icmp slt i32 %2, 2]}-> N772
N682 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N773
N772 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N684
N772 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N684
N684 -{%3 = bitcast i8* %call2 to i32*}-> N685
N684 -{%3 = bitcast i8* %call2 to i32*}-> N685
N685 -{%4 = load i32, i32* %i, align 4}-> N686
N685 -{%4 = load i32, i32* %i, align 4}-> N686
N686 -{%idxprom = sext i32 %4 to i64}-> N687
N686 -{%idxprom = sext i32 %4 to i64}-> N687
N687 -{%5 = load i32**, i32*** %ptr, align 8}-> N688
N687 -{%5 = load i32**, i32*** %ptr, align 8}-> N688
N688 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N689
N688 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N689
N689 -{store i32* %3, i32** %arrayidx, align 8}-> N690
N689 -{store i32* %3, i32** %arrayidx, align 8}-> N690
N690 -{%6 = load i32, i32* %i, align 4}-> N691
N690 -{%6 = load i32, i32* %i, align 4}-> N691
N691 -{%idxprom3 = sext i32 %6 to i64}-> N692
N691 -{%idxprom3 = sext i32 %6 to i64}-> N692
N692 -{%7 = load i32**, i32*** %ptr, align 8}-> N693
N692 -{%7 = load i32**, i32*** %ptr, align 8}-> N693
N693 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N694
N693 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N694
N694 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N695
N694 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N695
N695 -{%cmp5 = icmp eq i32* %8, null}-> N696
N695 -{%cmp5 = icmp eq i32* %8, null}-> N696
N696 -{[%cmp5 = icmp eq i32* %8, null]}-> N774
N696 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N775
N775 -{%18 = load i32, i32* %i, align 4}-> N721
N721 -{%inc14 = add i32 %18, 1}-> N722
N722 -{store i32 %inc14, i32* %i, align 4}-> N680
N680 -{%2 = load i32, i32* %i, align 4}-> N681
N681 -{%cmp1 = icmp slt i32 %2, 2}-> N682
N682 -{[%cmp1 = icmp slt i32 %2, 2]}-> N772
N682 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N773
N772 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N684
N772 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N684
N684 -{%3 = bitcast i8* %call2 to i32*}-> N685
N684 -{%3 = bitcast i8* %call2 to i32*}-> N685
N685 -{%4 = load i32, i32* %i, align 4}-> N686
N686 -{%idxprom = sext i32 %4 to i64}-> N687
N687 -{%5 = load i32**, i32*** %ptr, align 8}-> N688
N688 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N689
N689 -{store i32* %3, i32** %arrayidx, align 8}-> N690
N690 -{%6 = load i32, i32* %i, align 4}-> N691
N691 -{%idxprom3 = sext i32 %6 to i64}-> N692
N692 -{%7 = load i32**, i32*** %ptr, align 8}-> N693
N693 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N694
N694 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N695
N695 -{%cmp5 = icmp eq i32* %8, null}-> N696
N696 -{[%cmp5 = icmp eq i32* %8, null]}-> N774
N696 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N775
N696 -{[%cmp5 = icmp eq i32* %8, null]}-> N774
N696 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N775
N775 -{%18 = load i32, i32* %i, align 4}-> N721
N721 -{%inc14 = add i32 %18, 1}-> N722
N722 -{store i32 %inc14, i32* %i, align 4}-> N680
N680 -{%2 = load i32, i32* %i, align 4}-> N681
N681 -{%cmp1 = icmp slt i32 %2, 2}-> N682
N682 -{[%cmp1 = icmp slt i32 %2, 2]}-> N772
N682 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N773
N773 -{store i32 2, i32* %index, align 4}-> N726
N726 -{store i32 0, i32* %i, align 4}-> N728
N728 -{%19 = load i32, i32* %i, align 4}-> N729
N728 -{@}-> N728
N728 -{@}-> N731
N729 -{%20 = load i32, i32* %index, align 4}-> N730
N730 -{%cmp17 = icmp slt i32 %19, %20}-> N731
N731 -{[!(%cmp17 = icmp slt i32 %19, %20)]}-> N779
N731 -{[%cmp17 = icmp slt i32 %19, %20]}-> N778
N731 -{[!(%cmp17 = icmp slt i32 %19, %20)]}-> N779
N778 -{store i32 0, i32* %j, align 4}-> N734
N734 -{%21 = load i32, i32* %j, align 4}-> N735
N735 -{%cmp20 = icmp slt i32 %21, 1}-> N736
N736 -{[%cmp20 = icmp slt i32 %21, 1]}-> N780
N736 -{[!(%cmp20 = icmp slt i32 %21, 1)]}-> N781
N780 -{%22 = load i32, i32* %i, align 4}-> N738
N738 -{%23 = load i32**, i32*** %ptr, align 8}-> N739
N739 -{%24 = load i32, i32* %i, align 4}-> N740
N740 -{%idx.ext = sext i32 %24 to i64}-> N741
N741 -{%add.ptr = getelementptr inbounds i32*, i32** %23, i64 %idx.ext}-> N742
N742 -{%25 = load i32*, i32** %add.ptr, align 8}-> N743
N743 -{%26 = load i32, i32* %j, align 4}-> N744
N744 -{%idx.ext22 = sext i32 %26 to i64}-> N745
N745 -{%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22}-> N746
N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748
N748 -{%27 = load i32, i32* %j, align 4}-> N749
N749 -{%inc25 = add i32 %27, 1}-> N750
N750 -{store i32 %inc25, i32* %j, align 4}-> N734
N734 -{%21 = load i32, i32* %j, align 4}-> N735
N735 -{%cmp20 = icmp slt i32 %21, 1}-> N736
N736 -{[%cmp20 = icmp slt i32 %21, 1]}-> N780
N736 -{[!(%cmp20 = icmp slt i32 %21, 1)]}-> N781
N781 -{%28 = load i32, i32* %i, align 4}-> N753
N753 -{%idxprom27 = sext i32 %28 to i64}-> N754
N754 -{%29 = load i32**, i32*** %ptr, align 8}-> N755
N755 -{%arrayidx28 = getelementptr inbounds i32*, i32** %29, i64 %idxprom27}-> N756
N756 -{%30 = load i32*, i32** %arrayidx28, align 8}-> N757
N757 -{%31 = bitcast i32* %30 to i8*}-> N758
N758 -{call void @free(i8* %31, i8* @free)}-> N760
N760 -{%32 = load i32, i32* %i, align 4}-> N761
N761 -{%inc30 = add i32 %32, 1}-> N762
N762 -{store i32 %inc30, i32* %i, align 4}-> N728
N728 -{%19 = load i32, i32* %i, align 4}-> N729
N729 -{%20 = load i32, i32* %index, align 4}-> N730
N730 -{%cmp17 = icmp slt i32 %19, %20}-> N731
N731 -{[%cmp17 = icmp slt i32 %19, %20]}-> N778
N731 -{[!(%cmp17 = icmp slt i32 %19, %20)]}-> N779
N778 -{store i32 0, i32* %j, align 4}-> N734
N734 -{%21 = load i32, i32* %j, align 4}-> N735
N735 -{%cmp20 = icmp slt i32 %21, 1}-> N736
N736 -{[%cmp20 = icmp slt i32 %21, 1]}-> N780
N736 -{[!(%cmp20 = icmp slt i32 %21, 1)]}-> N781
N780 -{%22 = load i32, i32* %i, align 4}-> N738
N738 -{%23 = load i32**, i32*** %ptr, align 8}-> N739
N739 -{%24 = load i32, i32* %i, align 4}-> N740
N740 -{%idx.ext = sext i32 %24 to i64}-> N741
N741 -{%add.ptr = getelementptr inbounds i32*, i32** %23, i64 %idx.ext}-> N742
N742 -{%25 = load i32*, i32** %add.ptr, align 8}-> N743
N743 -{%26 = load i32, i32* %j, align 4}-> N744
N744 -{%idx.ext22 = sext i32 %26 to i64}-> N745
N745 -{%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22}-> N746
N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748
N748 -{%27 = load i32, i32* %j, align 4}-> N749
N749 -{%inc25 = add i32 %27, 1}-> N750
N750 -{store i32 %inc25, i32* %j, align 4}-> N734
N734 -{%21 = load i32, i32* %j, align 4}-> N735
N735 -{%cmp20 = icmp slt i32 %21, 1}-> N736
N736 -{[%cmp20 = icmp slt i32 %21, 1]}-> N780
N736 -{[!(%cmp20 = icmp slt i32 %21, 1)]}-> N781
N781 -{%28 = load i32, i32* %i, align 4}-> N753
N753 -{%idxprom27 = sext i32 %28 to i64}-> N754
N754 -{%29 = load i32**, i32*** %ptr, align 8}-> N755
N755 -{%arrayidx28 = getelementptr inbounds i32*, i32** %29, i64 %idxprom27}-> N756
N756 -{%30 = load i32*, i32** %arrayidx28, align 8}-> N757
N757 -{%31 = bitcast i32* %30 to i8*}-> N758
N758 -{call void @free(i8* %31, i8* @free)}-> N760
N760 -{%32 = load i32, i32* %i, align 4}-> N761
N761 -{%inc30 = add i32 %32, 1}-> N762
N762 -{store i32 %inc30, i32* %i, align 4}-> N728
N728 -{%19 = load i32, i32* %i, align 4}-> N729
N729 -{%20 = load i32, i32* %index, align 4}-> N730
N730 -{%cmp17 = icmp slt i32 %19, %20}-> N731
N731 -{[%cmp17 = icmp slt i32 %19, %20]}-> N778
N731 -{[!(%cmp17 = icmp slt i32 %19, %20)]}-> N779
N779 -{%33 = load i32**, i32*** %ptr, align 8}-> N765
N779 -{%33 = load i32**, i32*** %ptr, align 8}-> N765
N765 -{%34 = bitcast i32** %33 to i8*}-> N766
N765 -{%34 = bitcast i32** %33 to i8*}-> N766
N766 -{call void @free(i8* %34, i8* @free)}-> N768
N766 -{call void @free(i8* %34, i8* @free)}-> N768
N774 -{store i32 0, i32* %j, align 4}-> N699
N699 -{%9 = load i32, i32* %j, align 4}-> N700
N699 -{@}-> N699
N699 -{@}-> N702
N700 -{%10 = load i32, i32* %i, align 4}-> N701
N701 -{%cmp8 = icmp slt i32 %9, %10}-> N702
N702 -{[!(%cmp8 = icmp slt i32 %9, %10)]}-> N777
N702 -{[%cmp8 = icmp slt i32 %9, %10]}-> N776
N702 -{[!(%cmp8 = icmp slt i32 %9, %10)]}-> N777
N777 -{%16 = load i32**, i32*** %ptr, align 8}-> N716
N777 -{%16 = load i32**, i32*** %ptr, align 8}-> N716
N716 -{%17 = bitcast i32** %16 to i8*}-> N717
N716 -{%17 = bitcast i32** %16 to i8*}-> N717
N717 -{call void @free(i8* %17, i8* @free)}-> N768
N717 -{call void @free(i8* %17, i8* @free)}-> N768
N768 -{ret void}-> N662
N768 -{ret void}-> N662
N768 -{ret void}-> N662
N768 -{ret void}-> N662
N768 -{ret void}-> N662
N662 -{Return edge from memory_leak_002_good to main}-> N559
N662 -{Return edge from memory_leak_002_good to main}-> N559
N662 -{Return edge from memory_leak_002_good to main}-> N559
N662 -{Return edge from memory_leak_002_good to main}-> N559
N662 -{Return edge from memory_leak_002_good to main}-> N559
N559 -{call memory_leak_002_bad}-> N563
N563 -{%ptr = alloca i32**, align 8}-> N565
N565 -{%i = alloca i32, align 4}-> N566
N566 -{%j = alloca i32, align 4}-> N567
N567 -{%index = alloca i32, align 4}-> N569
N569 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N570
N569 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N570
N570 -{%0 = bitcast i8* %call to i32**}-> N571
N570 -{%0 = bitcast i8* %call to i32**}-> N571
N571 -{store i32** %0, i32*** %ptr, align 8}-> N572
N571 -{store i32** %0, i32*** %ptr, align 8}-> N572
N572 -{%1 = load i32**, i32*** %ptr, align 8}-> N573
N572 -{%1 = load i32**, i32*** %ptr, align 8}-> N573
N573 -{%cmp = icmp eq i32** %1, null}-> N574
N573 -{%cmp = icmp eq i32** %1, null}-> N574
N574 -{[!(%cmp = icmp eq i32** %1, null)]}-> N651
N574 -{[%cmp = icmp eq i32** %1, null]}-> N648
N574 -{[!(%cmp = icmp eq i32** %1, null)]}-> N651
N574 -{[%cmp = icmp eq i32** %1, null]}-> N648
N651 -{store i32 0, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N580 -{@}-> N580
N580 -{@}-> N596
N580 -{@}-> N582
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N655 -{%9 = load i32, i32* %i, align 4}-> N600
N600 -{%inc = add i32 %9, 1}-> N601
N601 -{store i32 %inc, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N655 -{%9 = load i32, i32* %i, align 4}-> N600
N600 -{%inc = add i32 %9, 1}-> N601
N601 -{store i32 %inc, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N653 -{store i32 2, i32* %index, align 4}-> N605
N605 -{store i32 0, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N607 -{@}-> N607
N607 -{@}-> N610
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N656 -{%12 = load i32, i32* %i, align 4}-> N612
N612 -{%idxprom11 = sext i32 %12 to i64}-> N613
N613 -{%13 = load i32**, i32*** %ptr, align 8}-> N614
N614 -{%arrayidx12 = getelementptr inbounds i32*, i32** %13, i64 %idxprom11}-> N615
N615 -{%14 = load i32*, i32** %arrayidx12, align 8}-> N616
N616 -{%cmp13 = icmp eq i32* %14, null}-> N617
N617 -{[!(%cmp13 = icmp eq i32* %14, null)]}-> N659
N617 -{[%cmp13 = icmp eq i32* %14, null]}-> N640
N659 -{store i32 0, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N660 -{%16 = load i32, i32* %i, align 4}-> N625
N625 -{%17 = load i32**, i32*** %ptr, align 8}-> N626
N626 -{%18 = load i32, i32* %i, align 4}-> N627
N627 -{%idx.ext = sext i32 %18 to i64}-> N628
N628 -{%add.ptr = getelementptr inbounds i32*, i32** %17, i64 %idx.ext}-> N629
N629 -{%19 = load i32*, i32** %add.ptr, align 8}-> N630
N630 -{%20 = load i32, i32* %j, align 4}-> N631
N631 -{%idx.ext19 = sext i32 %20 to i64}-> N632
N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
N635 -{%21 = load i32, i32* %j, align 4}-> N636
N636 -{%inc22 = add i32 %21, 1}-> N637
N637 -{store i32 %inc22, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N640 -{%22 = load i32, i32* %i, align 4}-> N641
N641 -{%inc25 = add i32 %22, 1}-> N642
N642 -{store i32 %inc25, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N656 -{%12 = load i32, i32* %i, align 4}-> N612
N612 -{%idxprom11 = sext i32 %12 to i64}-> N613
N613 -{%13 = load i32**, i32*** %ptr, align 8}-> N614
N614 -{%arrayidx12 = getelementptr inbounds i32*, i32** %13, i64 %idxprom11}-> N615
N615 -{%14 = load i32*, i32** %arrayidx12, align 8}-> N616
N616 -{%cmp13 = icmp eq i32* %14, null}-> N617
N617 -{[!(%cmp13 = icmp eq i32* %14, null)]}-> N659
N617 -{[%cmp13 = icmp eq i32* %14, null]}-> N640
N659 -{store i32 0, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N660 -{%16 = load i32, i32* %i, align 4}-> N625
N625 -{%17 = load i32**, i32*** %ptr, align 8}-> N626
N626 -{%18 = load i32, i32* %i, align 4}-> N627
N627 -{%idx.ext = sext i32 %18 to i64}-> N628
N628 -{%add.ptr = getelementptr inbounds i32*, i32** %17, i64 %idx.ext}-> N629
N629 -{%19 = load i32*, i32** %add.ptr, align 8}-> N630
N630 -{%20 = load i32, i32* %j, align 4}-> N631
N631 -{%idx.ext19 = sext i32 %20 to i64}-> N632
N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
N635 -{%21 = load i32, i32* %j, align 4}-> N636
N636 -{%inc22 = add i32 %21, 1}-> N637
N637 -{store i32 %inc22, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N640 -{%22 = load i32, i32* %i, align 4}-> N641
N641 -{%inc25 = add i32 %22, 1}-> N642
N642 -{store i32 %inc25, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N657 -{%23 = load i32**, i32*** %ptr, align 8}-> N645
N657 -{%23 = load i32**, i32*** %ptr, align 8}-> N645
N645 -{%24 = bitcast i32** %23 to i8*}-> N646
N645 -{%24 = bitcast i32** %23 to i8*}-> N646
N646 -{call void @free(i8* %24, i8* @free)}-> N648
N646 -{call void @free(i8* %24, i8* @free)}-> N648
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N559 -{call memory_leak_002_bad}-> N563
N563 -{%ptr = alloca i32**, align 8}-> N565
N565 -{%i = alloca i32, align 4}-> N566
N566 -{%j = alloca i32, align 4}-> N567
N567 -{%index = alloca i32, align 4}-> N569
N569 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N570
N569 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N570
N570 -{%0 = bitcast i8* %call to i32**}-> N571
N570 -{%0 = bitcast i8* %call to i32**}-> N571
N571 -{store i32** %0, i32*** %ptr, align 8}-> N572
N571 -{store i32** %0, i32*** %ptr, align 8}-> N572
N572 -{%1 = load i32**, i32*** %ptr, align 8}-> N573
N572 -{%1 = load i32**, i32*** %ptr, align 8}-> N573
N573 -{%cmp = icmp eq i32** %1, null}-> N574
N573 -{%cmp = icmp eq i32** %1, null}-> N574
N574 -{[!(%cmp = icmp eq i32** %1, null)]}-> N651
N574 -{[%cmp = icmp eq i32** %1, null]}-> N648
N574 -{[!(%cmp = icmp eq i32** %1, null)]}-> N651
N574 -{[%cmp = icmp eq i32** %1, null]}-> N648
N651 -{store i32 0, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N580 -{@}-> N580
N580 -{@}-> N596
N580 -{@}-> N582
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N655 -{%9 = load i32, i32* %i, align 4}-> N600
N600 -{%inc = add i32 %9, 1}-> N601
N601 -{store i32 %inc, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N655 -{%9 = load i32, i32* %i, align 4}-> N600
N600 -{%inc = add i32 %9, 1}-> N601
N601 -{store i32 %inc, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N653 -{store i32 2, i32* %index, align 4}-> N605
N605 -{store i32 0, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N607 -{@}-> N607
N607 -{@}-> N610
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N656 -{%12 = load i32, i32* %i, align 4}-> N612
N612 -{%idxprom11 = sext i32 %12 to i64}-> N613
N613 -{%13 = load i32**, i32*** %ptr, align 8}-> N614
N614 -{%arrayidx12 = getelementptr inbounds i32*, i32** %13, i64 %idxprom11}-> N615
N615 -{%14 = load i32*, i32** %arrayidx12, align 8}-> N616
N616 -{%cmp13 = icmp eq i32* %14, null}-> N617
N617 -{[!(%cmp13 = icmp eq i32* %14, null)]}-> N659
N617 -{[%cmp13 = icmp eq i32* %14, null]}-> N640
N659 -{store i32 0, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N660 -{%16 = load i32, i32* %i, align 4}-> N625
N625 -{%17 = load i32**, i32*** %ptr, align 8}-> N626
N626 -{%18 = load i32, i32* %i, align 4}-> N627
N627 -{%idx.ext = sext i32 %18 to i64}-> N628
N628 -{%add.ptr = getelementptr inbounds i32*, i32** %17, i64 %idx.ext}-> N629
N629 -{%19 = load i32*, i32** %add.ptr, align 8}-> N630
N630 -{%20 = load i32, i32* %j, align 4}-> N631
N631 -{%idx.ext19 = sext i32 %20 to i64}-> N632
N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
N635 -{%21 = load i32, i32* %j, align 4}-> N636
N636 -{%inc22 = add i32 %21, 1}-> N637
N637 -{store i32 %inc22, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N640 -{%22 = load i32, i32* %i, align 4}-> N641
N641 -{%inc25 = add i32 %22, 1}-> N642
N642 -{store i32 %inc25, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N656 -{%12 = load i32, i32* %i, align 4}-> N612
N612 -{%idxprom11 = sext i32 %12 to i64}-> N613
N613 -{%13 = load i32**, i32*** %ptr, align 8}-> N614
N614 -{%arrayidx12 = getelementptr inbounds i32*, i32** %13, i64 %idxprom11}-> N615
N615 -{%14 = load i32*, i32** %arrayidx12, align 8}-> N616
N616 -{%cmp13 = icmp eq i32* %14, null}-> N617
N617 -{[!(%cmp13 = icmp eq i32* %14, null)]}-> N659
N617 -{[%cmp13 = icmp eq i32* %14, null]}-> N640
N659 -{store i32 0, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N660 -{%16 = load i32, i32* %i, align 4}-> N625
N625 -{%17 = load i32**, i32*** %ptr, align 8}-> N626
N626 -{%18 = load i32, i32* %i, align 4}-> N627
N627 -{%idx.ext = sext i32 %18 to i64}-> N628
N628 -{%add.ptr = getelementptr inbounds i32*, i32** %17, i64 %idx.ext}-> N629
N629 -{%19 = load i32*, i32** %add.ptr, align 8}-> N630
N630 -{%20 = load i32, i32* %j, align 4}-> N631
N631 -{%idx.ext19 = sext i32 %20 to i64}-> N632
N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
N635 -{%21 = load i32, i32* %j, align 4}-> N636
N636 -{%inc22 = add i32 %21, 1}-> N637
N637 -{store i32 %inc22, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N640 -{%22 = load i32, i32* %i, align 4}-> N641
N641 -{%inc25 = add i32 %22, 1}-> N642
N642 -{store i32 %inc25, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N657 -{%23 = load i32**, i32*** %ptr, align 8}-> N645
N657 -{%23 = load i32**, i32*** %ptr, align 8}-> N645
N645 -{%24 = bitcast i32** %23 to i8*}-> N646
N645 -{%24 = bitcast i32** %23 to i8*}-> N646
N646 -{call void @free(i8* %24, i8* @free)}-> N648
N646 -{call void @free(i8* %24, i8* @free)}-> N648
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N559 -{call memory_leak_002_bad}-> N563
N563 -{%ptr = alloca i32**, align 8}-> N565
N565 -{%i = alloca i32, align 4}-> N566
N566 -{%j = alloca i32, align 4}-> N567
N567 -{%index = alloca i32, align 4}-> N569
N569 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N570
N569 -{%call = call i8* @malloc(i64 16, i64 @malloc)}-> N570
N570 -{%0 = bitcast i8* %call to i32**}-> N571
N570 -{%0 = bitcast i8* %call to i32**}-> N571
N571 -{store i32** %0, i32*** %ptr, align 8}-> N572
N571 -{store i32** %0, i32*** %ptr, align 8}-> N572
N572 -{%1 = load i32**, i32*** %ptr, align 8}-> N573
N572 -{%1 = load i32**, i32*** %ptr, align 8}-> N573
N573 -{%cmp = icmp eq i32** %1, null}-> N574
N573 -{%cmp = icmp eq i32** %1, null}-> N574
N574 -{[!(%cmp = icmp eq i32** %1, null)]}-> N651
N574 -{[%cmp = icmp eq i32** %1, null]}-> N648
N574 -{[!(%cmp = icmp eq i32** %1, null)]}-> N651
N574 -{[%cmp = icmp eq i32** %1, null]}-> N648
N651 -{store i32 0, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N580 -{@}-> N580
N580 -{@}-> N596
N580 -{@}-> N582
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N655 -{%9 = load i32, i32* %i, align 4}-> N600
N600 -{%inc = add i32 %9, 1}-> N601
N601 -{store i32 %inc, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N652 -{%call2 = call i8* @malloc(i64 4, i64 @malloc)}-> N584
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N584 -{%3 = bitcast i8* %call2 to i32*}-> N585
N585 -{%4 = load i32, i32* %i, align 4}-> N586
N586 -{%idxprom = sext i32 %4 to i64}-> N587
N587 -{%5 = load i32**, i32*** %ptr, align 8}-> N588
N588 -{%arrayidx = getelementptr inbounds i32*, i32** %5, i64 %idxprom}-> N589
N589 -{store i32* %3, i32** %arrayidx, align 8}-> N590
N590 -{%6 = load i32, i32* %i, align 4}-> N591
N591 -{%idxprom3 = sext i32 %6 to i64}-> N592
N592 -{%7 = load i32**, i32*** %ptr, align 8}-> N593
N593 -{%arrayidx4 = getelementptr inbounds i32*, i32** %7, i64 %idxprom3}-> N594
N594 -{%8 = load i32*, i32** %arrayidx4, align 8}-> N595
N595 -{%cmp5 = icmp eq i32* %8, null}-> N596
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N596 -{[!(%cmp5 = icmp eq i32* %8, null)]}-> N655
N596 -{[%cmp5 = icmp eq i32* %8, null]}-> N648
N655 -{%9 = load i32, i32* %i, align 4}-> N600
N600 -{%inc = add i32 %9, 1}-> N601
N601 -{store i32 %inc, i32* %i, align 4}-> N580
N580 -{%2 = load i32, i32* %i, align 4}-> N581
N581 -{%cmp1 = icmp slt i32 %2, 2}-> N582
N582 -{[%cmp1 = icmp slt i32 %2, 2]}-> N652
N582 -{[!(%cmp1 = icmp slt i32 %2, 2)]}-> N653
N653 -{store i32 2, i32* %index, align 4}-> N605
N605 -{store i32 0, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N607 -{@}-> N607
N607 -{@}-> N610
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N656 -{%12 = load i32, i32* %i, align 4}-> N612
N612 -{%idxprom11 = sext i32 %12 to i64}-> N613
N613 -{%13 = load i32**, i32*** %ptr, align 8}-> N614
N614 -{%arrayidx12 = getelementptr inbounds i32*, i32** %13, i64 %idxprom11}-> N615
N615 -{%14 = load i32*, i32** %arrayidx12, align 8}-> N616
N616 -{%cmp13 = icmp eq i32* %14, null}-> N617
N617 -{[!(%cmp13 = icmp eq i32* %14, null)]}-> N659
N617 -{[%cmp13 = icmp eq i32* %14, null]}-> N640
N659 -{store i32 0, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N660 -{%16 = load i32, i32* %i, align 4}-> N625
N625 -{%17 = load i32**, i32*** %ptr, align 8}-> N626
N626 -{%18 = load i32, i32* %i, align 4}-> N627
N627 -{%idx.ext = sext i32 %18 to i64}-> N628
N628 -{%add.ptr = getelementptr inbounds i32*, i32** %17, i64 %idx.ext}-> N629
N629 -{%19 = load i32*, i32** %add.ptr, align 8}-> N630
N630 -{%20 = load i32, i32* %j, align 4}-> N631
N631 -{%idx.ext19 = sext i32 %20 to i64}-> N632
N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
N635 -{%21 = load i32, i32* %j, align 4}-> N636
N636 -{%inc22 = add i32 %21, 1}-> N637
N637 -{store i32 %inc22, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N640 -{%22 = load i32, i32* %i, align 4}-> N641
N641 -{%inc25 = add i32 %22, 1}-> N642
N642 -{store i32 %inc25, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N656 -{%12 = load i32, i32* %i, align 4}-> N612
N612 -{%idxprom11 = sext i32 %12 to i64}-> N613
N613 -{%13 = load i32**, i32*** %ptr, align 8}-> N614
N614 -{%arrayidx12 = getelementptr inbounds i32*, i32** %13, i64 %idxprom11}-> N615
N615 -{%14 = load i32*, i32** %arrayidx12, align 8}-> N616
N616 -{%cmp13 = icmp eq i32* %14, null}-> N617
N617 -{[!(%cmp13 = icmp eq i32* %14, null)]}-> N659
N617 -{[%cmp13 = icmp eq i32* %14, null]}-> N640
N659 -{store i32 0, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N660 -{%16 = load i32, i32* %i, align 4}-> N625
N625 -{%17 = load i32**, i32*** %ptr, align 8}-> N626
N626 -{%18 = load i32, i32* %i, align 4}-> N627
N627 -{%idx.ext = sext i32 %18 to i64}-> N628
N628 -{%add.ptr = getelementptr inbounds i32*, i32** %17, i64 %idx.ext}-> N629
N629 -{%19 = load i32*, i32** %add.ptr, align 8}-> N630
N630 -{%20 = load i32, i32* %j, align 4}-> N631
N631 -{%idx.ext19 = sext i32 %20 to i64}-> N632
N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
N635 -{%21 = load i32, i32* %j, align 4}-> N636
N636 -{%inc22 = add i32 %21, 1}-> N637
N637 -{store i32 %inc22, i32* %j, align 4}-> N621
N621 -{%15 = load i32, i32* %j, align 4}-> N622
N622 -{%cmp17 = icmp slt i32 %15, 1}-> N623
N623 -{[%cmp17 = icmp slt i32 %15, 1]}-> N660
N623 -{[!(%cmp17 = icmp slt i32 %15, 1)]}-> N640
N640 -{%22 = load i32, i32* %i, align 4}-> N641
N641 -{%inc25 = add i32 %22, 1}-> N642
N642 -{store i32 %inc25, i32* %i, align 4}-> N607
N607 -{%10 = load i32, i32* %i, align 4}-> N608
N608 -{%11 = load i32, i32* %index, align 4}-> N609
N609 -{%cmp9 = icmp slt i32 %10, %11}-> N610
N610 -{[%cmp9 = icmp slt i32 %10, %11]}-> N656
N610 -{[!(%cmp9 = icmp slt i32 %10, %11)]}-> N657
N657 -{%23 = load i32**, i32*** %ptr, align 8}-> N645
N657 -{%23 = load i32**, i32*** %ptr, align 8}-> N645
N645 -{%24 = bitcast i32** %23 to i8*}-> N646
N645 -{%24 = bitcast i32** %23 to i8*}-> N646
N646 -{call void @free(i8* %24, i8* @free)}-> N648
N646 -{call void @free(i8* %24, i8* @free)}-> N648
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N648 -{ret void}-> N562
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N562 -{Return edge from memory_leak_002_bad to main}-> N560
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
N560 -{ret i32 0}-> N554
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N562
On edge  : N562 -{Return edge from memory_leak_002_bad to main}-> N560
Message  : the heap object @H(memory_leak_002_bad::call) is not referenced any more
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the true branch, At N596 of Function memory_leak_002_bad
<Defect> : N562 -> N560: [Return edge from memory_leak_002_bad to main]
N562 -> N560: [Return edge from memory_leak_002_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N560
On edge  : N560 -{ret i32 0}-> N554
Message  : the heap object @H(memory_leak_002_good::call2) is not referenced any more
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the true branch, At N574 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N562 -> N560 (Return edge from memory_leak_002_bad to main)
<Defect> : N560 -> N554: [ret i32 0]
N560 -> N554: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N560
On edge  : N560 -{ret i32 0}-> N554
Message  : the heap object @H(memory_leak_002_bad::call2) is not referenced any more
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the false branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N610 of Function memory_leak_002_bad
> Leaving function: memory_leak_002_bad, On N562 -> N560 (Return edge from memory_leak_002_bad to main)
<Defect> : N560 -> N554: [ret i32 0]
N560 -> N554: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N745
On edge  : N745 -{%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22}-> N746
Message  : null pointer dereference
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
<Defect> : N745 -> N746: [%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22]
N745 -> N746: [%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N746
On edge  : N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748
Message  : null pointer dereference
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
<Defect> : N746 -> N748: [store i32 %22, i32* %add.ptr23, align 4]
N746 -> N748: [store i32 %22, i32* %add.ptr23, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N758
On edge  : N758 -{call void @free(i8* %31, i8* @free)}-> N760
Message  : null pointer dereference
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
<Defect> : N758 -> N760: [call void @free(i8* %31, i8* @free)]
N758 -> N760: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N632
On edge  : N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633
Message  : null pointer dereference
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the false branch, At N582 of Function memory_leak_002_bad
> takes the true branch, At N610 of Function memory_leak_002_bad
> takes the false branch, At N617 of Function memory_leak_002_bad
> takes the true branch, At N623 of Function memory_leak_002_bad
> takes the false branch, At N623 of Function memory_leak_002_bad
> takes the true branch, At N610 of Function memory_leak_002_bad
> takes the false branch, At N617 of Function memory_leak_002_bad
> takes the true branch, At N623 of Function memory_leak_002_bad
<Defect> : N632 -> N633: [%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19]
N632 -> N633: [%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N633
On edge  : N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635
Message  : null pointer dereference
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N731 of Function memory_leak_002_good
> Leaving function: memory_leak_002_good, On N662 -> N559 (Return edge from memory_leak_002_good to main)
> Entering function: memory_leak_002_bad, On N559 -> N563 (call memory_leak_002_bad)
> takes the false branch, At N574 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the true branch, At N582 of Function memory_leak_002_bad
> takes the false branch, At N596 of Function memory_leak_002_bad
> takes the false branch, At N582 of Function memory_leak_002_bad
> takes the true branch, At N610 of Function memory_leak_002_bad
> takes the false branch, At N617 of Function memory_leak_002_bad
> takes the true branch, At N623 of Function memory_leak_002_bad
> takes the false branch, At N623 of Function memory_leak_002_bad
> takes the true branch, At N610 of Function memory_leak_002_bad
> takes the false branch, At N617 of Function memory_leak_002_bad
> takes the true branch, At N623 of Function memory_leak_002_bad
<Defect> : N633 -> N635: [store i32 %16, i32* %add.ptr20, align 4]
N633 -> N635: [store i32 %16, i32* %add.ptr20, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N758
On edge  : N758 -{call void @free(i8* %31, i8* @free)}-> N760
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
<Defect> : N758 -> N760: [call void @free(i8* %31, i8* @free)]
N758 -> N760: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N746
On edge  : N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
<Defect> : N746 -> N748: [store i32 %22, i32* %add.ptr23, align 4]
N746 -> N748: [store i32 %22, i32* %add.ptr23, align 4] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N758
On edge  : N758 -{call void @free(i8* %31, i8* @free)}-> N760
Message  : the memory is already freed
> Start from entry function: main, At N555 of Function main
> Entering function: memory_leak_002_good, On N558 -> N663 (call memory_leak_002_good)
> takes the false branch, At N674 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the true branch, At N682 of Function memory_leak_002_good
> takes the false branch, At N696 of Function memory_leak_002_good
> takes the false branch, At N682 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
> takes the true branch, At N731 of Function memory_leak_002_good
> takes the true branch, At N736 of Function memory_leak_002_good
> takes the false branch, At N736 of Function memory_leak_002_good
<Defect> : N758 -> N760: [call void @free(i8* %31, i8* @free)]
N758 -> N760: [call void @free(i8* %31, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 3
	[401_memory_leak_2.c 83] memory_leak_002_bad 		[N562 -{Return edge from memory_leak_002_bad to main}-> N560]	(the heap object @H(memory_leak_002_bad::call) is not referenced any more)
	[401_memory_leak_2.c 84] main 		[N560 -{ret i32 0}-> N554]	(the heap object @H(memory_leak_002_good::call2) is not referenced any more)
	[401_memory_leak_2.c 84] main 		[N560 -{ret i32 0}-> N554]	(the heap object @H(memory_leak_002_bad::call2) is not referenced any more)

CWE_476(Null Pointer Dereference): 5
	[401_memory_leak_2.c 68] memory_leak_002_good 		[N745 -{%add.ptr23 = getelementptr inbounds i32, i32* %25, i64 %idx.ext22}-> N746]	(null pointer dereference)
	[401_memory_leak_2.c 68] memory_leak_002_good 		[N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748]	(null pointer dereference)
	[401_memory_leak_2.c 70] memory_leak_002_good 		[N758 -{call void @free(i8* %31, i8* @free)}-> N760]	(null pointer dereference)
	[401_memory_leak_2.c 36] memory_leak_002_bad 		[N632 -{%add.ptr20 = getelementptr inbounds i32, i32* %19, i64 %idx.ext19}-> N633]	(null pointer dereference)
	[401_memory_leak_2.c 36] memory_leak_002_bad 		[N633 -{store i32 %16, i32* %add.ptr20, align 4}-> N635]	(null pointer dereference)

CWE_415(Double Free): 1
	[401_memory_leak_2.c 70] memory_leak_002_good 		[N758 -{call void @free(i8* %31, i8* @free)}-> N760]	(the memory is already freed)

CWE_416(Use After Free): 2
	[401_memory_leak_2.c 68] memory_leak_002_good 		[N746 -{store i32 %22, i32* %add.ptr23, align 4}-> N748]	(the memory is already freed)
	[401_memory_leak_2.c 70] memory_leak_002_good 		[N758 -{call void @free(i8* %31, i8* @free)}-> N760]	(the memory is already freed)

Found 11 defects in all (22 duplicates ignored).
=====================================================
Phase status: SUCCESS


java.lang.AssertionError: unexpected number of reports 
Expected :3
Actual   :2
 <Click to see difference>


	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.failNotEquals(Assert.java:743)
	at org.junit.Assert.assertEquals(Assert.java:118)
	at org.junit.Assert.assertEquals(Assert.java:555)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:48)
	at cn.edu.thu.tsmart.helper.assertion.NumberAssert.is(NumberAssert.java:44)
	at cn.edu.thu.tsmart.integrated.ITC_401_Test.lambda$itc_401_bit_2$1(ITC_401_Test.java:58)
	at cn.edu.thu.tsmart.helper.assertion.ReportSetAssert.satisfy(ReportSetAssert.java:79)
	at cn.edu.thu.tsmart.integrated.ITC_401_Test.itc_401_bit_2(ITC_401_Test.java:57)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:51)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_3.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_003_func_001_good]
 +memory_leak_003_func_001_good
SCC(1): [memory_leak_003_good]
 +memory_leak_003_good
SCC(1): [memory_leak_003_func_001_bad]
 +memory_leak_003_func_001_bad
SCC(1): [memory_leak_003_bad]
 +memory_leak_003_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_003_bad, memory_leak_003_func_001_bad, memory_leak_003_func_001_good, memory_leak_003_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_003_func_001_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_003_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: 
----
function: memory_leak_003_func_001_bad
P+ = [H(memory_leak_003_func_001_bad::call)] 
P- = [] 
Point-To:
P(memory_leak_003_func_001_bad::stringPtr) -> [H(memory_leak_003_func_001_bad::call)]
Ret-Value: 
----
function: memory_leak_003_func_001_good
P+ = [H(memory_leak_003_func_001_good::call)] 
P- = [] 
Point-To:
P(memory_leak_003_func_001_good::stringPtr) -> [H(memory_leak_003_func_001_good::call)]
Ret-Value: 
----
function: memory_leak_003_good
P+ = [] 
P- = [H(memory_leak_003_func_001_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.018s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N783): +oo]
> [1/1] entry: main ()
N783 -{global: .str}-> N880
N880 -{%retval = alloca i32, align 4}-> N785
N785 -{store i32 0, i32* %retval, align 4}-> N786
N786 -{call memory_leak_003_good}-> N863
N863 -{%str = alloca i8*, align 8}-> N865
N865 -{%str1 = alloca i8*, align 8}-> N867
N867 -{store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8** %str, align 8}-> N869
N869 -{%0 = load i8*, i8** %str, align 8}-> N870
N870 -{%call = call i64 @strlen(i8* %0, i8* @strlen)}-> N871
N871 -{%conv = trunc i64 %call to i32}-> N872
N872 -{call memory_leak_003_func_001_good}-> N835
N835 -{%len.addr = alloca i32, align 4}-> N837
N837 -{%stringPtr.addr = alloca i8**, align 8}-> N838
N838 -{%p = alloca i8*, align 8}-> N839
N839 -{store i32 %len, i32* %len.addr, align 4}-> N841
N841 -{store i8** %stringPtr, i8*** %stringPtr.addr, align 8}-> N844
N844 -{%0 = load i32, i32* %len.addr, align 4}-> N845
N845 -{%add = add i32 %0, 1}-> N846
N846 -{%conv = sext i32 %add to i64}-> N847
N847 -{%mul = mul i64 1, %conv}-> N848
N848 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N849
N848 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N849
N849 -{store i8* %call, i8** %p, align 8}-> N850
N849 -{store i8* %call, i8** %p, align 8}-> N850
N850 -{%1 = load i8*, i8** %p, align 8}-> N851
N850 -{%1 = load i8*, i8** %p, align 8}-> N851
N851 -{%cmp = icmp eq i8* %1, null}-> N852
N851 -{%cmp = icmp eq i8* %1, null}-> N852
N852 -{[!(%cmp = icmp eq i8* %1, null)]}-> N861
N852 -{[%cmp = icmp eq i8* %1, null]}-> N858
N852 -{[!(%cmp = icmp eq i8* %1, null)]}-> N861
N852 -{[%cmp = icmp eq i8* %1, null]}-> N858
N861 -{%2 = load i8*, i8** %p, align 8}-> N855
N855 -{%3 = load i8**, i8*** %stringPtr.addr, align 8}-> N856
N856 -{store i8* %2, i8** %3, align 8}-> N858
N858 -{ret void}-> N834
N858 -{ret void}-> N834
N834 -{Return edge from memory_leak_003_func_001_good to memory_leak_003_good}-> N873
N834 -{Return edge from memory_leak_003_func_001_good to memory_leak_003_good}-> N873
N873 -{%1 = load i8*, i8** %str1, align 8}-> N874
N873 -{%1 = load i8*, i8** %str1, align 8}-> N874
N874 -{%2 = load i8*, i8** %str, align 8}-> N875
N874 -{%2 = load i8*, i8** %str, align 8}-> N875
N875 -{%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)}-> N876
N875 -{%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)}-> N876
N876 -{%3 = load i8*, i8** %str1, align 8}-> N877
N876 -{%3 = load i8*, i8** %str1, align 8}-> N877
N877 -{call void @free(i8* %3, i8* @free)}-> N878
N877 -{call void @free(i8* %3, i8* @free)}-> N878
N878 -{ret void}-> N862
N862 -{Return edge from memory_leak_003_good to main}-> N787
N787 -{call memory_leak_003_bad}-> N791
N791 -{%str = alloca i8*, align 8}-> N793
N793 -{%str1 = alloca i8*, align 8}-> N795
N795 -{store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8** %str, align 8}-> N797
N797 -{%0 = load i8*, i8** %str, align 8}-> N798
N798 -{%call = call i64 @strlen(i8* %0, i8* @strlen)}-> N799
N799 -{%conv = trunc i64 %call to i32}-> N800
N800 -{call memory_leak_003_func_001_bad}-> N807
N807 -{%len.addr = alloca i32, align 4}-> N809
N809 -{%stringPtr.addr = alloca i8**, align 8}-> N810
N810 -{%p = alloca i8*, align 8}-> N811
N811 -{store i32 %len, i32* %len.addr, align 4}-> N813
N813 -{store i8** %stringPtr, i8*** %stringPtr.addr, align 8}-> N816
N816 -{%0 = load i32, i32* %len.addr, align 4}-> N817
N817 -{%add = add i32 %0, 1}-> N818
N818 -{%conv = sext i32 %add to i64}-> N819
N819 -{%mul = mul i64 1, %conv}-> N820
N820 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N821
N820 -{%call = call i8* @malloc(i64 %mul, i64 @malloc)}-> N821
N821 -{store i8* %call, i8** %p, align 8}-> N822
N821 -{store i8* %call, i8** %p, align 8}-> N822
N822 -{%1 = load i8*, i8** %p, align 8}-> N823
N822 -{%1 = load i8*, i8** %p, align 8}-> N823
N823 -{%cmp = icmp eq i8* %1, null}-> N824
N823 -{%cmp = icmp eq i8* %1, null}-> N824
N824 -{[!(%cmp = icmp eq i8* %1, null)]}-> N833
N824 -{[%cmp = icmp eq i8* %1, null]}-> N830
N824 -{[!(%cmp = icmp eq i8* %1, null)]}-> N833
N824 -{[%cmp = icmp eq i8* %1, null]}-> N830
N833 -{%2 = load i8*, i8** %p, align 8}-> N827
N827 -{%3 = load i8**, i8*** %stringPtr.addr, align 8}-> N828
N828 -{store i8* %2, i8** %3, align 8}-> N830
N830 -{ret void}-> N806
N830 -{ret void}-> N806
N806 -{Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad}-> N801
N806 -{Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad}-> N801
N801 -{%1 = load i8*, i8** %str1, align 8}-> N802
N801 -{%1 = load i8*, i8** %str1, align 8}-> N802
N802 -{%2 = load i8*, i8** %str, align 8}-> N803
N802 -{%2 = load i8*, i8** %str, align 8}-> N803
N803 -{%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)}-> N804
N803 -{%call1 = call i8* @strcpy(i8* %1, i8* %2, i8* @strcpy)}-> N804
N804 -{ret void}-> N790
N804 -{ret void}-> N790
N790 -{Return edge from memory_leak_003_bad to main}-> N788
N790 -{Return edge from memory_leak_003_bad to main}-> N788
N788 -{ret i32 0}-> N782
N788 -{ret i32 0}-> N782
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N790
On edge  : N790 -{Return edge from memory_leak_003_bad to main}-> N788
Message  : the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N862 -> N787 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N787 -> N791 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N800 -> N807 (call memory_leak_003_func_001_bad)
> takes the false branch, At N824 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N806 -> N801 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N790 -> N788: [Return edge from memory_leak_003_bad to main]
N790 -> N788: [Return edge from memory_leak_003_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N873
On edge  : N873 -{%1 = load i8*, i8** %str1, align 8}-> N874
Message  : use of uninitialized variable
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N873 -> N874: [%1 = load i8*, i8** %str1, align 8]
N873 -> N874: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N876
On edge  : N876 -{%3 = load i8*, i8** %str1, align 8}-> N877
Message  : use of uninitialized variable
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
<Defect> : N876 -> N877: [%3 = load i8*, i8** %str1, align 8]
N876 -> N877: [%3 = load i8*, i8** %str1, align 8] <--
-- end of trace --
-- start of trace --
Weakness : Use of Uninitialized Variable
At node  : N801
On edge  : N801 -{%1 = load i8*, i8** %str1, align 8}-> N802
Message  : use of uninitialized variable
> Start from entry function: main, At N783 of Function main
> Entering function: memory_leak_003_good, On N786 -> N863 (call memory_leak_003_good)
> Entering function: memory_leak_003_func_001_good, On N872 -> N835 (call memory_leak_003_func_001_good)
> takes the true branch, At N852 of Function memory_leak_003_func_001_good
> Leaving function: memory_leak_003_func_001_good, On N834 -> N873 (Return edge from memory_leak_003_func_001_good to memory_leak_003_good)
> Leaving function: memory_leak_003_good, On N862 -> N787 (Return edge from memory_leak_003_good to main)
> Entering function: memory_leak_003_bad, On N787 -> N791 (call memory_leak_003_bad)
> Entering function: memory_leak_003_func_001_bad, On N800 -> N807 (call memory_leak_003_func_001_bad)
> takes the true branch, At N824 of Function memory_leak_003_func_001_bad
> Leaving function: memory_leak_003_func_001_bad, On N806 -> N801 (Return edge from memory_leak_003_func_001_bad to memory_leak_003_bad)
<Defect> : N801 -> N802: [%1 = load i8*, i8** %str1, align 8]
N801 -> N802: [%1 = load i8*, i8** %str1, align 8] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_3.c 67] memory_leak_003_bad 		[N790 -{Return edge from memory_leak_003_bad to main}-> N788]	(the heap object @H(memory_leak_003_func_001_bad::call) is not referenced any more)

CWE_457(Use of Uninitialized Variable): 3
	[./401_memory_leak_3.c 55] memory_leak_003_good 		[N873 -{%1 = load i8*, i8** %str1, align 8}-> N874]	(use of uninitialized variable)
	[./401_memory_leak_3.c 56] memory_leak_003_good 		[N876 -{%3 = load i8*, i8** %str1, align 8}-> N877]	(use of uninitialized variable)
	[./401_memory_leak_3.c 33] memory_leak_003_bad 		[N801 -{%1 = load i8*, i8** %str1, align 8}-> N802]	(use of uninitialized variable)

Found 4 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_4.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_004_bad]
 +memory_leak_004_bad
SCC(1): [memory_leak_004_good]
 +memory_leak_004_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_004_bad, memory_leak_004_good]
Loops     [N943, N1010, N910, N989, N1044]
----
function: main
P+ = [H(memory_leak_004_bad::call4), H(memory_leak_004_good::call4)] 
P- = [H(memory_leak_004_bad::call), H(memory_leak_004_good::call), H(memory_leak_004_good::call4)] 
Point-To:
H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]
H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]
Ret-Value: R
----
function: memory_leak_004_bad
P+ = [H(memory_leak_004_bad::call4)] 
P- = [H(memory_leak_004_bad::call)] 
Point-To:
H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]
Ret-Value: 
----
function: memory_leak_004_good
P+ = [H(memory_leak_004_good::call4)] 
P- = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)] 
Point-To:
H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]
Ret-Value: 
----
loop N910 in memory_leak_004_bad: 
N910 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
N927 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
N912 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
----
loop N943 in memory_leak_004_bad: 
N943 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
N945 -> P+ = [H(memory_leak_004_bad::call), H(memory_leak_004_bad::call4)], P- = [] Point-To: H(memory_leak_004_bad::call)[??] -> [H(memory_leak_004_bad::call4)]; L(memory_leak_004_bad::s) -> [H(memory_leak_004_bad::call)]; L(memory_leak_004_bad::s1) -> [G(.str)[0_0]]
----
loop N989 in memory_leak_004_good: 
N989 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N1006 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N991 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
----
loop N1010 in memory_leak_004_good: 
N1010 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N1013 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
----
loop N1044 in memory_leak_004_good: 
N1044 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
N1046 -> P+ = [H(memory_leak_004_good::call), H(memory_leak_004_good::call4)], P- = [H(memory_leak_004_good::call4)] Point-To: H(memory_leak_004_good::call)[??] -> [H(memory_leak_004_good::call4)]; L(memory_leak_004_good::s) -> [H(memory_leak_004_good::call)]; L(memory_leak_004_good::s1) -> [G(.str)[0_0]]
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.068s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N882): +oo]
> [1/1] entry: main ()
N882 -{global: .str}-> N1077
N1077 -{%retval = alloca i32, align 4}-> N884
N884 -{store i32 0, i32* %retval, align 4}-> N885
N885 -{call memory_leak_004_good}-> N968
N968 -{%s = alloca %struct.memory_leak_004_s_001*, align 8}-> N970
N970 -{%s1 = alloca i8*, align 8}-> N971
N971 -{%i = alloca i32, align 4}-> N972
N972 -{%j = alloca i32, align 4}-> N974
N974 -{%call = call i8* @calloc(i64 5, i64 16, i64 @calloc)}-> N975
N974 -{%call = call i8* @calloc(i64 5, i64 16, i64 @calloc)}-> N975
N975 -{%0 = bitcast i8* %call to %struct.memory_leak_004_s_001*}-> N976
N975 -{%0 = bitcast i8* %call to %struct.memory_leak_004_s_001*}-> N976
N976 -{store %struct.memory_leak_004_s_001* %0, %struct.memory_leak_004_s_001** %s, align 8}-> N977
N976 -{store %struct.memory_leak_004_s_001* %0, %struct.memory_leak_004_s_001** %s, align 8}-> N977
N977 -{%1 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N978
N977 -{%1 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N978
N978 -{%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null}-> N979
N978 -{%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null}-> N979
N979 -{[!(%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null)]}-> N1066
N979 -{[%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null]}-> N1063
N979 -{[!(%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null)]}-> N1066
N979 -{[%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null]}-> N1063
N1066 -{store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8** %s1, align 8}-> N984
N984 -{%2 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N985
N985 -{%cmp1 = icmp ne %struct.memory_leak_004_s_001* %2, null}-> N986
N986 -{[%cmp1 = icmp ne %struct.memory_leak_004_s_001* %2, null]}-> N1067
N986 -{[!(%cmp1 = icmp ne %struct.memory_leak_004_s_001* %2, null)]}-> N1036
N1067 -{store i32 0, i32* %i, align 4}-> N989
N989 -{%3 = load i32, i32* %i, align 4}-> N990
N989 -{@}-> N989
N989 -{@}-> N1006
N989 -{@}-> N991
N990 -{%cmp3 = icmp slt i32 %3, 5}-> N991
N991 -{[%cmp3 = icmp slt i32 %3, 5]}-> N1069
N991 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N1036
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N994 -{%5 = load i32, i32* %i, align 4}-> N995
N994 -{%5 = load i32, i32* %i, align 4}-> N995
N995 -{%idx.ext = sext i32 %5 to i64}-> N996
N995 -{%idx.ext = sext i32 %5 to i64}-> N996
N996 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N997
N996 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N997
N997 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N998
N997 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N998
N998 -{store i8* %call4, i8** %buf, align 8}-> N999
N998 -{store i8* %call4, i8** %buf, align 8}-> N999
N999 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1000
N999 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1000
N1000 -{%7 = load i32, i32* %i, align 4}-> N1001
N1000 -{%7 = load i32, i32* %i, align 4}-> N1001
N1001 -{%idx.ext5 = sext i32 %7 to i64}-> N1002
N1001 -{%idx.ext5 = sext i32 %7 to i64}-> N1002
N1002 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N1003
N1002 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N1003
N1003 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N1004
N1003 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N1004
N1004 -{%8 = load i8*, i8** %buf7, align 8}-> N1005
N1004 -{%8 = load i8*, i8** %buf7, align 8}-> N1005
N1005 -{%cmp8 = icmp eq i8* %8, null}-> N1006
N1005 -{%cmp8 = icmp eq i8* %8, null}-> N1006
N1006 -{[%cmp8 = icmp eq i8* %8, null]}-> N1071
N1006 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N1072
N1072 -{%17 = load i32, i32* %i, align 4}-> N1032
N1032 -{%inc18 = add i32 %17, 1}-> N1033
N1033 -{store i32 %inc18, i32* %i, align 4}-> N989
N989 -{%3 = load i32, i32* %i, align 4}-> N990
N990 -{%cmp3 = icmp slt i32 %3, 5}-> N991
N991 -{[%cmp3 = icmp slt i32 %3, 5]}-> N1069
N991 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N1036
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N994 -{%5 = load i32, i32* %i, align 4}-> N995
N995 -{%idx.ext = sext i32 %5 to i64}-> N996
N996 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N997
N997 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N998
N998 -{store i8* %call4, i8** %buf, align 8}-> N999
N999 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1000
N1000 -{%7 = load i32, i32* %i, align 4}-> N1001
N1001 -{%idx.ext5 = sext i32 %7 to i64}-> N1002
N1002 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N1003
N1003 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N1004
N1004 -{%8 = load i8*, i8** %buf7, align 8}-> N1005
N1005 -{%cmp8 = icmp eq i8* %8, null}-> N1006
N1006 -{[%cmp8 = icmp eq i8* %8, null]}-> N1071
N1006 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N1072
N1006 -{[%cmp8 = icmp eq i8* %8, null]}-> N1071
N1006 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N1072
N1072 -{%17 = load i32, i32* %i, align 4}-> N1032
N1032 -{%inc18 = add i32 %17, 1}-> N1033
N1033 -{store i32 %inc18, i32* %i, align 4}-> N989
N989 -{%3 = load i32, i32* %i, align 4}-> N990
N990 -{%cmp3 = icmp slt i32 %3, 5}-> N991
N991 -{[%cmp3 = icmp slt i32 %3, 5]}-> N1069
N991 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N1036
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N994 -{%5 = load i32, i32* %i, align 4}-> N995
N995 -{%idx.ext = sext i32 %5 to i64}-> N996
N996 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N997
N997 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N998
N998 -{store i8* %call4, i8** %buf, align 8}-> N999
N999 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1000
N1000 -{%7 = load i32, i32* %i, align 4}-> N1001
N1001 -{%idx.ext5 = sext i32 %7 to i64}-> N1002
N1002 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N1003
N1003 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N1004
N1004 -{%8 = load i8*, i8** %buf7, align 8}-> N1005
N1005 -{%cmp8 = icmp eq i8* %8, null}-> N1006
N1006 -{[%cmp8 = icmp eq i8* %8, null]}-> N1071
N1006 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N1072
N1072 -{%17 = load i32, i32* %i, align 4}-> N1032
N1032 -{%inc18 = add i32 %17, 1}-> N1033
N1033 -{store i32 %inc18, i32* %i, align 4}-> N989
N989 -{%3 = load i32, i32* %i, align 4}-> N990
N990 -{%cmp3 = icmp slt i32 %3, 5}-> N991
N991 -{[%cmp3 = icmp slt i32 %3, 5]}-> N1069
N991 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N1036
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N994 -{%5 = load i32, i32* %i, align 4}-> N995
N995 -{%idx.ext = sext i32 %5 to i64}-> N996
N996 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N997
N997 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N998
N998 -{store i8* %call4, i8** %buf, align 8}-> N999
N999 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1000
N1000 -{%7 = load i32, i32* %i, align 4}-> N1001
N1001 -{%idx.ext5 = sext i32 %7 to i64}-> N1002
N1002 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N1003
N1003 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N1004
N1004 -{%8 = load i8*, i8** %buf7, align 8}-> N1005
N1005 -{%cmp8 = icmp eq i8* %8, null}-> N1006
N1006 -{[%cmp8 = icmp eq i8* %8, null]}-> N1071
N1006 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N1072
N1072 -{%17 = load i32, i32* %i, align 4}-> N1032
N1032 -{%inc18 = add i32 %17, 1}-> N1033
N1033 -{store i32 %inc18, i32* %i, align 4}-> N989
N989 -{%3 = load i32, i32* %i, align 4}-> N990
N990 -{%cmp3 = icmp slt i32 %3, 5}-> N991
N991 -{[%cmp3 = icmp slt i32 %3, 5]}-> N1069
N991 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N1036
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N1069 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N993
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N993 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N994
N994 -{%5 = load i32, i32* %i, align 4}-> N995
N995 -{%idx.ext = sext i32 %5 to i64}-> N996
N996 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N997
N997 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N998
N998 -{store i8* %call4, i8** %buf, align 8}-> N999
N999 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1000
N1000 -{%7 = load i32, i32* %i, align 4}-> N1001
N1001 -{%idx.ext5 = sext i32 %7 to i64}-> N1002
N1002 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N1003
N1003 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N1004
N1004 -{%8 = load i8*, i8** %buf7, align 8}-> N1005
N1005 -{%cmp8 = icmp eq i8* %8, null}-> N1006
N1006 -{[%cmp8 = icmp eq i8* %8, null]}-> N1071
N1006 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N1072
N1072 -{%17 = load i32, i32* %i, align 4}-> N1032
N1032 -{%inc18 = add i32 %17, 1}-> N1033
N1033 -{store i32 %inc18, i32* %i, align 4}-> N989
N989 -{%3 = load i32, i32* %i, align 4}-> N990
N990 -{%cmp3 = icmp slt i32 %3, 5}-> N991
N991 -{[%cmp3 = icmp slt i32 %3, 5]}-> N1069
N991 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N1036
N1036 -{%18 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1037
N1037 -{%add.ptr21 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %18, i64 4}-> N1038
N1038 -{%buf22 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr21, i32 0, i32 2}-> N1039
N1039 -{%19 = load i8*, i8** %buf22, align 8}-> N1040
N1040 -{%20 = load i8*, i8** %s1, align 8}-> N1041
N1041 -{%call23 = call i8* @strcpy(i8* %19, i8* %20, i8* @strcpy)}-> N1042
N1042 -{store i32 0, i32* %i, align 4}-> N1044
N1044 -{%21 = load i32, i32* %i, align 4}-> N1045
N1044 -{@}-> N1044
N1044 -{@}-> N1046
N1045 -{%cmp25 = icmp slt i32 %21, 5}-> N1046
N1046 -{[%cmp25 = icmp slt i32 %21, 5]}-> N1075
N1046 -{[!(%cmp25 = icmp slt i32 %21, 5)]}-> N1076
N1075 -{%22 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1048
N1048 -{%23 = load i32, i32* %i, align 4}-> N1049
N1049 -{%idx.ext27 = sext i32 %23 to i64}-> N1050
N1050 -{%add.ptr28 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %22, i64 %idx.ext27}-> N1051
N1051 -{%buf29 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr28, i32 0, i32 2}-> N1052
N1052 -{%24 = load i8*, i8** %buf29, align 8}-> N1053
N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
N1055 -{%25 = load i32, i32* %i, align 4}-> N1056
N1056 -{%inc31 = add i32 %25, 1}-> N1057
N1057 -{store i32 %inc31, i32* %i, align 4}-> N1044
N1044 -{%21 = load i32, i32* %i, align 4}-> N1045
N1045 -{%cmp25 = icmp slt i32 %21, 5}-> N1046
N1046 -{[%cmp25 = icmp slt i32 %21, 5]}-> N1075
N1046 -{[!(%cmp25 = icmp slt i32 %21, 5)]}-> N1076
N1075 -{%22 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1048
N1048 -{%23 = load i32, i32* %i, align 4}-> N1049
N1049 -{%idx.ext27 = sext i32 %23 to i64}-> N1050
N1050 -{%add.ptr28 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %22, i64 %idx.ext27}-> N1051
N1051 -{%buf29 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr28, i32 0, i32 2}-> N1052
N1052 -{%24 = load i8*, i8** %buf29, align 8}-> N1053
N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
N1055 -{%25 = load i32, i32* %i, align 4}-> N1056
N1056 -{%inc31 = add i32 %25, 1}-> N1057
N1057 -{store i32 %inc31, i32* %i, align 4}-> N1044
N1044 -{%21 = load i32, i32* %i, align 4}-> N1045
N1045 -{%cmp25 = icmp slt i32 %21, 5}-> N1046
N1046 -{[%cmp25 = icmp slt i32 %21, 5]}-> N1075
N1046 -{[!(%cmp25 = icmp slt i32 %21, 5)]}-> N1076
N1075 -{%22 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1048
N1048 -{%23 = load i32, i32* %i, align 4}-> N1049
N1049 -{%idx.ext27 = sext i32 %23 to i64}-> N1050
N1050 -{%add.ptr28 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %22, i64 %idx.ext27}-> N1051
N1051 -{%buf29 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr28, i32 0, i32 2}-> N1052
N1052 -{%24 = load i8*, i8** %buf29, align 8}-> N1053
N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
N1055 -{%25 = load i32, i32* %i, align 4}-> N1056
N1056 -{%inc31 = add i32 %25, 1}-> N1057
N1057 -{store i32 %inc31, i32* %i, align 4}-> N1044
N1044 -{%21 = load i32, i32* %i, align 4}-> N1045
N1045 -{%cmp25 = icmp slt i32 %21, 5}-> N1046
N1046 -{[%cmp25 = icmp slt i32 %21, 5]}-> N1075
N1046 -{[!(%cmp25 = icmp slt i32 %21, 5)]}-> N1076
N1075 -{%22 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1048
N1048 -{%23 = load i32, i32* %i, align 4}-> N1049
N1049 -{%idx.ext27 = sext i32 %23 to i64}-> N1050
N1050 -{%add.ptr28 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %22, i64 %idx.ext27}-> N1051
N1051 -{%buf29 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr28, i32 0, i32 2}-> N1052
N1052 -{%24 = load i8*, i8** %buf29, align 8}-> N1053
N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
N1055 -{%25 = load i32, i32* %i, align 4}-> N1056
N1056 -{%inc31 = add i32 %25, 1}-> N1057
N1057 -{store i32 %inc31, i32* %i, align 4}-> N1044
N1044 -{%21 = load i32, i32* %i, align 4}-> N1045
N1045 -{%cmp25 = icmp slt i32 %21, 5}-> N1046
N1046 -{[%cmp25 = icmp slt i32 %21, 5]}-> N1075
N1046 -{[!(%cmp25 = icmp slt i32 %21, 5)]}-> N1076
N1075 -{%22 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1048
N1048 -{%23 = load i32, i32* %i, align 4}-> N1049
N1049 -{%idx.ext27 = sext i32 %23 to i64}-> N1050
N1050 -{%add.ptr28 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %22, i64 %idx.ext27}-> N1051
N1051 -{%buf29 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr28, i32 0, i32 2}-> N1052
N1052 -{%24 = load i8*, i8** %buf29, align 8}-> N1053
N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
N1055 -{%25 = load i32, i32* %i, align 4}-> N1056
N1056 -{%inc31 = add i32 %25, 1}-> N1057
N1057 -{store i32 %inc31, i32* %i, align 4}-> N1044
N1044 -{%21 = load i32, i32* %i, align 4}-> N1045
N1045 -{%cmp25 = icmp slt i32 %21, 5}-> N1046
N1046 -{[%cmp25 = icmp slt i32 %21, 5]}-> N1075
N1046 -{[!(%cmp25 = icmp slt i32 %21, 5)]}-> N1076
N1076 -{%26 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1060
N1060 -{%27 = bitcast %struct.memory_leak_004_s_001* %26 to i8*}-> N1061
N1061 -{call void @free(i8* %27, i8* @free)}-> N1063
N1071 -{store i32 0, i32* %j, align 4}-> N1010
N1010 -{%9 = load i32, i32* %j, align 4}-> N1011
N1010 -{@}-> N1010
N1010 -{@}-> N1013
N1011 -{%10 = load i32, i32* %i, align 4}-> N1012
N1012 -{%cmp11 = icmp slt i32 %9, %10}-> N1013
N1013 -{[!(%cmp11 = icmp slt i32 %9, %10)]}-> N1074
N1013 -{[%cmp11 = icmp slt i32 %9, %10]}-> N1073
N1013 -{[!(%cmp11 = icmp slt i32 %9, %10)]}-> N1074
N1074 -{%15 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1027
N1074 -{%15 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N1027
N1027 -{%16 = bitcast %struct.memory_leak_004_s_001* %15 to i8*}-> N1028
N1027 -{%16 = bitcast %struct.memory_leak_004_s_001* %15 to i8*}-> N1028
N1028 -{call void @free(i8* %16, i8* @free)}-> N1063
N1028 -{call void @free(i8* %16, i8* @free)}-> N1063
N1063 -{ret void}-> N967
N1063 -{ret void}-> N967
N1063 -{ret void}-> N967
N1063 -{ret void}-> N967
N967 -{Return edge from memory_leak_004_good to main}-> N886
N967 -{Return edge from memory_leak_004_good to main}-> N886
N967 -{Return edge from memory_leak_004_good to main}-> N886
N967 -{Return edge from memory_leak_004_good to main}-> N886
N886 -{call memory_leak_004_bad}-> N890
N890 -{%s = alloca %struct.memory_leak_004_s_001*, align 8}-> N892
N892 -{%s1 = alloca i8*, align 8}-> N893
N893 -{%i = alloca i32, align 4}-> N895
N895 -{%call = call i8* @calloc(i64 5, i64 16, i64 @calloc)}-> N896
N895 -{%call = call i8* @calloc(i64 5, i64 16, i64 @calloc)}-> N896
N896 -{%0 = bitcast i8* %call to %struct.memory_leak_004_s_001*}-> N897
N896 -{%0 = bitcast i8* %call to %struct.memory_leak_004_s_001*}-> N897
N897 -{store %struct.memory_leak_004_s_001* %0, %struct.memory_leak_004_s_001** %s, align 8}-> N898
N897 -{store %struct.memory_leak_004_s_001* %0, %struct.memory_leak_004_s_001** %s, align 8}-> N898
N898 -{%1 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N899
N898 -{%1 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N899
N899 -{%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null}-> N900
N899 -{%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null}-> N900
N900 -{[!(%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null)]}-> N958
N900 -{[%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null]}-> N955
N900 -{[!(%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null)]}-> N958
N900 -{[%cmp = icmp eq %struct.memory_leak_004_s_001* %1, null]}-> N955
N958 -{store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str, i32 0, i32 0), i8** %s1, align 8}-> N905
N905 -{%2 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N906
N906 -{%cmp1 = icmp ne %struct.memory_leak_004_s_001* %2, null}-> N907
N907 -{[%cmp1 = icmp ne %struct.memory_leak_004_s_001* %2, null]}-> N959
N907 -{[!(%cmp1 = icmp ne %struct.memory_leak_004_s_001* %2, null)]}-> N935
N959 -{store i32 0, i32* %i, align 4}-> N910
N910 -{%3 = load i32, i32* %i, align 4}-> N911
N910 -{@}-> N910
N910 -{@}-> N927
N910 -{@}-> N912
N911 -{%cmp3 = icmp slt i32 %3, 5}-> N912
N912 -{[%cmp3 = icmp slt i32 %3, 5]}-> N961
N912 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N935
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N915 -{%5 = load i32, i32* %i, align 4}-> N916
N915 -{%5 = load i32, i32* %i, align 4}-> N916
N916 -{%idx.ext = sext i32 %5 to i64}-> N917
N916 -{%idx.ext = sext i32 %5 to i64}-> N917
N917 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N918
N917 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N918
N918 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N919
N918 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N919
N919 -{store i8* %call4, i8** %buf, align 8}-> N920
N919 -{store i8* %call4, i8** %buf, align 8}-> N920
N920 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N921
N920 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N921
N921 -{%7 = load i32, i32* %i, align 4}-> N922
N921 -{%7 = load i32, i32* %i, align 4}-> N922
N922 -{%idx.ext5 = sext i32 %7 to i64}-> N923
N922 -{%idx.ext5 = sext i32 %7 to i64}-> N923
N923 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N924
N923 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N924
N924 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N925
N924 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N925
N925 -{%8 = load i8*, i8** %buf7, align 8}-> N926
N925 -{%8 = load i8*, i8** %buf7, align 8}-> N926
N926 -{%cmp8 = icmp eq i8* %8, null}-> N927
N926 -{%cmp8 = icmp eq i8* %8, null}-> N927
N927 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N964
N927 -{[%cmp8 = icmp eq i8* %8, null]}-> N955
N964 -{%9 = load i32, i32* %i, align 4}-> N931
N931 -{%inc = add i32 %9, 1}-> N932
N932 -{store i32 %inc, i32* %i, align 4}-> N910
N910 -{%3 = load i32, i32* %i, align 4}-> N911
N911 -{%cmp3 = icmp slt i32 %3, 5}-> N912
N912 -{[%cmp3 = icmp slt i32 %3, 5]}-> N961
N912 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N935
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N915 -{%5 = load i32, i32* %i, align 4}-> N916
N916 -{%idx.ext = sext i32 %5 to i64}-> N917
N917 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N918
N918 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N919
N919 -{store i8* %call4, i8** %buf, align 8}-> N920
N920 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N921
N921 -{%7 = load i32, i32* %i, align 4}-> N922
N922 -{%idx.ext5 = sext i32 %7 to i64}-> N923
N923 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N924
N924 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N925
N925 -{%8 = load i8*, i8** %buf7, align 8}-> N926
N926 -{%cmp8 = icmp eq i8* %8, null}-> N927
N927 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N964
N927 -{[%cmp8 = icmp eq i8* %8, null]}-> N955
N927 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N964
N927 -{[%cmp8 = icmp eq i8* %8, null]}-> N955
N964 -{%9 = load i32, i32* %i, align 4}-> N931
N931 -{%inc = add i32 %9, 1}-> N932
N932 -{store i32 %inc, i32* %i, align 4}-> N910
N910 -{%3 = load i32, i32* %i, align 4}-> N911
N911 -{%cmp3 = icmp slt i32 %3, 5}-> N912
N912 -{[%cmp3 = icmp slt i32 %3, 5]}-> N961
N912 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N935
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N915 -{%5 = load i32, i32* %i, align 4}-> N916
N916 -{%idx.ext = sext i32 %5 to i64}-> N917
N917 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N918
N918 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N919
N919 -{store i8* %call4, i8** %buf, align 8}-> N920
N920 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N921
N921 -{%7 = load i32, i32* %i, align 4}-> N922
N922 -{%idx.ext5 = sext i32 %7 to i64}-> N923
N923 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N924
N924 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N925
N925 -{%8 = load i8*, i8** %buf7, align 8}-> N926
N926 -{%cmp8 = icmp eq i8* %8, null}-> N927
N927 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N964
N927 -{[%cmp8 = icmp eq i8* %8, null]}-> N955
N964 -{%9 = load i32, i32* %i, align 4}-> N931
N931 -{%inc = add i32 %9, 1}-> N932
N932 -{store i32 %inc, i32* %i, align 4}-> N910
N910 -{%3 = load i32, i32* %i, align 4}-> N911
N911 -{%cmp3 = icmp slt i32 %3, 5}-> N912
N912 -{[%cmp3 = icmp slt i32 %3, 5]}-> N961
N912 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N935
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N915 -{%5 = load i32, i32* %i, align 4}-> N916
N916 -{%idx.ext = sext i32 %5 to i64}-> N917
N917 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N918
N918 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N919
N919 -{store i8* %call4, i8** %buf, align 8}-> N920
N920 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N921
N921 -{%7 = load i32, i32* %i, align 4}-> N922
N922 -{%idx.ext5 = sext i32 %7 to i64}-> N923
N923 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N924
N924 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N925
N925 -{%8 = load i8*, i8** %buf7, align 8}-> N926
N926 -{%cmp8 = icmp eq i8* %8, null}-> N927
N927 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N964
N927 -{[%cmp8 = icmp eq i8* %8, null]}-> N955
N964 -{%9 = load i32, i32* %i, align 4}-> N931
N931 -{%inc = add i32 %9, 1}-> N932
N932 -{store i32 %inc, i32* %i, align 4}-> N910
N910 -{%3 = load i32, i32* %i, align 4}-> N911
N911 -{%cmp3 = icmp slt i32 %3, 5}-> N912
N912 -{[%cmp3 = icmp slt i32 %3, 5]}-> N961
N912 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N935
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N961 -{%call4 = call i8* @malloc(i64 25, i64 @malloc)}-> N914
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N914 -{%4 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N915
N915 -{%5 = load i32, i32* %i, align 4}-> N916
N916 -{%idx.ext = sext i32 %5 to i64}-> N917
N917 -{%add.ptr = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %4, i64 %idx.ext}-> N918
N918 -{%buf = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr, i32 0, i32 2}-> N919
N919 -{store i8* %call4, i8** %buf, align 8}-> N920
N920 -{%6 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N921
N921 -{%7 = load i32, i32* %i, align 4}-> N922
N922 -{%idx.ext5 = sext i32 %7 to i64}-> N923
N923 -{%add.ptr6 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %6, i64 %idx.ext5}-> N924
N924 -{%buf7 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr6, i32 0, i32 2}-> N925
N925 -{%8 = load i8*, i8** %buf7, align 8}-> N926
N926 -{%cmp8 = icmp eq i8* %8, null}-> N927
N927 -{[!(%cmp8 = icmp eq i8* %8, null)]}-> N964
N927 -{[%cmp8 = icmp eq i8* %8, null]}-> N955
N964 -{%9 = load i32, i32* %i, align 4}-> N931
N931 -{%inc = add i32 %9, 1}-> N932
N932 -{store i32 %inc, i32* %i, align 4}-> N910
N910 -{%3 = load i32, i32* %i, align 4}-> N911
N911 -{%cmp3 = icmp slt i32 %3, 5}-> N912
N912 -{[%cmp3 = icmp slt i32 %3, 5]}-> N961
N912 -{[!(%cmp3 = icmp slt i32 %3, 5)]}-> N935
N935 -{%10 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N936
N936 -{%add.ptr12 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %10, i64 4}-> N937
N937 -{%buf13 = getelementptr inbounds %struct.memory_leak_004_s_001, %struct.memory_leak_004_s_001* %add.ptr12, i32 0, i32 2}-> N938
N938 -{%11 = load i8*, i8** %buf13, align 8}-> N939
N939 -{%12 = load i8*, i8** %s1, align 8}-> N940
N940 -{%call14 = call i8* @strcpy(i8* %11, i8* %12, i8* @strcpy)}-> N941
N941 -{store i32 0, i32* %i, align 4}-> N943
N943 -{%13 = load i32, i32* %i, align 4}-> N944
N943 -{@}-> N943
N943 -{@}-> N945
N944 -{%cmp16 = icmp slt i32 %13, 5}-> N945
N945 -{[%cmp16 = icmp slt i32 %13, 5]}-> N965
N945 -{[!(%cmp16 = icmp slt i32 %13, 5)]}-> N966
N965 -{%14 = load i32, i32* %i, align 4}-> N948
N948 -{%inc19 = add i32 %14, 1}-> N949
N949 -{store i32 %inc19, i32* %i, align 4}-> N943
N943 -{%13 = load i32, i32* %i, align 4}-> N944
N944 -{%cmp16 = icmp slt i32 %13, 5}-> N945
N945 -{[%cmp16 = icmp slt i32 %13, 5]}-> N965
N945 -{[!(%cmp16 = icmp slt i32 %13, 5)]}-> N966
N965 -{%14 = load i32, i32* %i, align 4}-> N948
N948 -{%inc19 = add i32 %14, 1}-> N949
N949 -{store i32 %inc19, i32* %i, align 4}-> N943
N943 -{%13 = load i32, i32* %i, align 4}-> N944
N944 -{%cmp16 = icmp slt i32 %13, 5}-> N945
N945 -{[%cmp16 = icmp slt i32 %13, 5]}-> N965
N945 -{[!(%cmp16 = icmp slt i32 %13, 5)]}-> N966
N965 -{%14 = load i32, i32* %i, align 4}-> N948
N948 -{%inc19 = add i32 %14, 1}-> N949
N949 -{store i32 %inc19, i32* %i, align 4}-> N943
N943 -{%13 = load i32, i32* %i, align 4}-> N944
N944 -{%cmp16 = icmp slt i32 %13, 5}-> N945
N945 -{[%cmp16 = icmp slt i32 %13, 5]}-> N965
N945 -{[!(%cmp16 = icmp slt i32 %13, 5)]}-> N966
N965 -{%14 = load i32, i32* %i, align 4}-> N948
N948 -{%inc19 = add i32 %14, 1}-> N949
N949 -{store i32 %inc19, i32* %i, align 4}-> N943
N943 -{%13 = load i32, i32* %i, align 4}-> N944
N944 -{%cmp16 = icmp slt i32 %13, 5}-> N945
N945 -{[%cmp16 = icmp slt i32 %13, 5]}-> N965
N945 -{[!(%cmp16 = icmp slt i32 %13, 5)]}-> N966
N965 -{%14 = load i32, i32* %i, align 4}-> N948
N948 -{%inc19 = add i32 %14, 1}-> N949
N949 -{store i32 %inc19, i32* %i, align 4}-> N943
N943 -{%13 = load i32, i32* %i, align 4}-> N944
N944 -{%cmp16 = icmp slt i32 %13, 5}-> N945
N945 -{[%cmp16 = icmp slt i32 %13, 5]}-> N965
N945 -{[!(%cmp16 = icmp slt i32 %13, 5)]}-> N966
N966 -{%15 = load %struct.memory_leak_004_s_001*, %struct.memory_leak_004_s_001** %s, align 8}-> N952
N952 -{%16 = bitcast %struct.memory_leak_004_s_001* %15 to i8*}-> N953
N953 -{call void @free(i8* %16, i8* @free)}-> N955
N955 -{ret void}-> N889
N955 -{ret void}-> N889
N955 -{ret void}-> N889
N889 -{Return edge from memory_leak_004_bad to main}-> N887
N889 -{Return edge from memory_leak_004_bad to main}-> N887
N889 -{Return edge from memory_leak_004_bad to main}-> N887
N887 -{ret i32 0}-> N881
N887 -{ret i32 0}-> N881
N887 -{ret i32 0}-> N881
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N889
On edge  : N889 -{Return edge from memory_leak_004_bad to main}-> N887
Message  : the heap object @H(memory_leak_004_bad::call) is not referenced any more
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the true branch, At N979 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N967 -> N886 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N886 -> N890 (call memory_leak_004_bad)
> takes the false branch, At N900 of Function memory_leak_004_bad
> takes the true branch, At N907 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the true branch, At N927 of Function memory_leak_004_bad
<Defect> : N889 -> N887: [Return edge from memory_leak_004_bad to main]
N889 -> N887: [Return edge from memory_leak_004_bad to main] <--
-- end of trace --
-- start of trace --
Weakness : Memory Leak
At node  : N887
On edge  : N887 -{ret i32 0}-> N881
Message  : the heap object @H(memory_leak_004_bad::call4) is not referenced any more
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the true branch, At N979 of Function memory_leak_004_good
> Leaving function: memory_leak_004_good, On N967 -> N886 (Return edge from memory_leak_004_good to main)
> Entering function: memory_leak_004_bad, On N886 -> N890 (call memory_leak_004_bad)
> takes the false branch, At N900 of Function memory_leak_004_bad
> takes the true branch, At N907 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N927 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N927 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N927 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N927 of Function memory_leak_004_bad
> takes the true branch, At N912 of Function memory_leak_004_bad
> takes the false branch, At N927 of Function memory_leak_004_bad
> takes the false branch, At N912 of Function memory_leak_004_bad
> takes the true branch, At N945 of Function memory_leak_004_bad
> takes the true branch, At N945 of Function memory_leak_004_bad
> takes the true branch, At N945 of Function memory_leak_004_bad
> takes the true branch, At N945 of Function memory_leak_004_bad
> takes the true branch, At N945 of Function memory_leak_004_bad
> takes the false branch, At N945 of Function memory_leak_004_bad
> Leaving function: memory_leak_004_bad, On N889 -> N887 (Return edge from memory_leak_004_bad to main)
<Defect> : N887 -> N881: [ret i32 0]
N887 -> N881: [ret i32 0] <--
-- end of trace --
-- start of trace --
Weakness : Null Pointer Dereference
At node  : N1053
On edge  : N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
Message  : null pointer dereference
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
<Defect> : N1053 -> N1055: [call void @free(i8* %24, i8* @free)]
N1053 -> N1055: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Double Free
At node  : N1053
On edge  : N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
Message  : the memory is already freed
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
<Defect> : N1053 -> N1055: [call void @free(i8* %24, i8* @free)]
N1053 -> N1055: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
-- start of trace --
Weakness : Use After Free
At node  : N1053
On edge  : N1053 -{call void @free(i8* %24, i8* @free)}-> N1055
Message  : the memory is already freed
> Start from entry function: main, At N882 of Function main
> Entering function: memory_leak_004_good, On N885 -> N968 (call memory_leak_004_good)
> takes the false branch, At N979 of Function memory_leak_004_good
> takes the true branch, At N986 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the true branch, At N991 of Function memory_leak_004_good
> takes the false branch, At N1006 of Function memory_leak_004_good
> takes the false branch, At N991 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
> takes the true branch, At N1046 of Function memory_leak_004_good
<Defect> : N1053 -> N1055: [call void @free(i8* %24, i8* @free)]
N1053 -> N1055: [call void @free(i8* %24, i8* @free)] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 2
	[401_memory_leak_4.c 90] memory_leak_004_bad 		[N889 -{Return edge from memory_leak_004_bad to main}-> N887]	(the heap object @H(memory_leak_004_bad::call) is not referenced any more)
	[401_memory_leak_4.c 91] main 		[N887 -{ret i32 0}-> N881]	(the heap object @H(memory_leak_004_bad::call4) is not referenced any more)

CWE_476(Null Pointer Dereference): 1
	[401_memory_leak_4.c 78] memory_leak_004_good 		[N1053 -{call void @free(i8* %24, i8* @free)}-> N1055]	(null pointer dereference)

CWE_415(Double Free): 1
	[401_memory_leak_4.c 78] memory_leak_004_good 		[N1053 -{call void @free(i8* %24, i8* @free)}-> N1055]	(the memory is already freed)

CWE_416(Use After Free): 1
	[401_memory_leak_4.c 78] memory_leak_004_good 		[N1053 -{call void @free(i8* %24, i8* @free)}-> N1055]	(the memory is already freed)

Found 5 defects in all (11 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_5.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_005_good]
 +memory_leak_005_good
SCC(1): [memory_leak_005_bad]
 +memory_leak_005_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [memory_leak_005_good, main, memory_leak_005_bad]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_005_bad::call), H(memory_leak_005_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_005_bad
P+ = [] 
P- = [H(memory_leak_005_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_005_good
P+ = [] 
P- = [H(memory_leak_005_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1079): +oo]
> [1/1] entry: main ()
N1079 -{%retval = alloca i32, align 4}-> N1081
N1081 -{store i32 0, i32* %retval, align 4}-> N1082
N1082 -{call memory_leak_005_good}-> N1123
N1123 -{%ptr = alloca float*, align 8}-> N1125
N1125 -{%flag = alloca i32, align 4}-> N1128
N1128 -{store i32 10, i32* %flag, align 4}-> N1129
N1129 -{%0 = load i32, i32* %flag, align 4}-> N1130
N1130 -{%cmp = icmp sgt i32 %0, 0}-> N1131
N1131 -{[%cmp = icmp sgt i32 %0, 0]}-> N1148
N1131 -{[!(%cmp = icmp sgt i32 %0, 0)]}-> N1146
N1148 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1133
N1148 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1133
N1133 -{%1 = bitcast i8* %call to float*}-> N1134
N1133 -{%1 = bitcast i8* %call to float*}-> N1134
N1134 -{store float* %1, float** %ptr, align 8}-> N1135
N1134 -{store float* %1, float** %ptr, align 8}-> N1135
N1135 -{%2 = load float*, float** %ptr, align 8}-> N1136
N1135 -{%2 = load float*, float** %ptr, align 8}-> N1136
N1136 -{%cmp1 = icmp ne float* %2, null}-> N1137
N1136 -{%cmp1 = icmp ne float* %2, null}-> N1137
N1137 -{[%cmp1 = icmp ne float* %2, null]}-> N1150
N1137 -{[!(%cmp1 = icmp ne float* %2, null)]}-> N1146
N1137 -{[%cmp1 = icmp ne float* %2, null]}-> N1150
N1137 -{[!(%cmp1 = icmp ne float* %2, null)]}-> N1146
N1150 -{%3 = load float*, float** %ptr, align 8}-> N1139
N1139 -{%add.ptr = getelementptr inbounds float, float* %3, i64 1}-> N1140
N1140 -{store float 1.050000e+01, float* %add.ptr, align 4}-> N1141
N1141 -{%4 = load float*, float** %ptr, align 8}-> N1142
N1142 -{%5 = bitcast float* %4 to i8*}-> N1143
N1143 -{call void @free(i8* %5, i8* @free)}-> N1146
N1146 -{ret void}-> N1122
N1122 -{Return edge from memory_leak_005_good to main}-> N1083
N1083 -{call memory_leak_005_bad}-> N1087
N1087 -{%ptr = alloca float*, align 8}-> N1089
N1089 -{%flag = alloca i32, align 4}-> N1092
N1092 -{store i32 10, i32* %flag, align 4}-> N1093
N1093 -{%0 = load i32, i32* %flag, align 4}-> N1094
N1094 -{%cmp = icmp sgt i32 %0, 0}-> N1095
N1095 -{[%cmp = icmp sgt i32 %0, 0]}-> N1116
N1095 -{[!(%cmp = icmp sgt i32 %0, 0)]}-> N1107
N1116 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1097
N1116 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1097
N1097 -{%1 = bitcast i8* %call to float*}-> N1098
N1097 -{%1 = bitcast i8* %call to float*}-> N1098
N1098 -{store float* %1, float** %ptr, align 8}-> N1099
N1098 -{store float* %1, float** %ptr, align 8}-> N1099
N1099 -{%2 = load float*, float** %ptr, align 8}-> N1100
N1099 -{%2 = load float*, float** %ptr, align 8}-> N1100
N1100 -{%cmp1 = icmp ne float* %2, null}-> N1101
N1100 -{%cmp1 = icmp ne float* %2, null}-> N1101
N1101 -{[%cmp1 = icmp ne float* %2, null]}-> N1118
N1101 -{[!(%cmp1 = icmp ne float* %2, null)]}-> N1107
N1101 -{[%cmp1 = icmp ne float* %2, null]}-> N1118
N1101 -{[!(%cmp1 = icmp ne float* %2, null)]}-> N1107
N1118 -{%3 = load float*, float** %ptr, align 8}-> N1103
N1103 -{%add.ptr = getelementptr inbounds float, float* %3, i64 1}-> N1104
N1104 -{store float 1.050000e+01, float* %add.ptr, align 4}-> N1107
N1107 -{%4 = load i32, i32* %flag, align 4}-> N1108
N1107 -{%4 = load i32, i32* %flag, align 4}-> N1108
N1108 -{%cmp4 = icmp slt i32 %4, 0}-> N1109
N1108 -{%cmp4 = icmp slt i32 %4, 0}-> N1109
N1109 -{[%cmp4 = icmp slt i32 %4, 0]}-> N1120
N1109 -{[!(%cmp4 = icmp slt i32 %4, 0)]}-> N1114
N1109 -{[%cmp4 = icmp slt i32 %4, 0]}-> N1120
N1109 -{[!(%cmp4 = icmp slt i32 %4, 0)]}-> N1114
N1114 -{ret void}-> N1086
N1114 -{ret void}-> N1086
N1086 -{Return edge from memory_leak_005_bad to main}-> N1084
N1086 -{Return edge from memory_leak_005_bad to main}-> N1084
N1084 -{ret i32 0}-> N1078
N1084 -{ret i32 0}-> N1078
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1086
On edge  : N1086 -{Return edge from memory_leak_005_bad to main}-> N1084
Message  : the heap object @H(memory_leak_005_bad::call) is not referenced any more
> Start from entry function: main, At N1079 of Function main
> Entering function: memory_leak_005_good, On N1082 -> N1123 (call memory_leak_005_good)
> takes the true branch, At N1131 of Function memory_leak_005_good
> takes the false branch, At N1137 of Function memory_leak_005_good
> Leaving function: memory_leak_005_good, On N1122 -> N1083 (Return edge from memory_leak_005_good to main)
> Entering function: memory_leak_005_bad, On N1083 -> N1087 (call memory_leak_005_bad)
> takes the true branch, At N1095 of Function memory_leak_005_bad
> takes the true branch, At N1101 of Function memory_leak_005_bad
> takes the false branch, At N1109 of Function memory_leak_005_bad
<Defect> : N1086 -> N1084: [Return edge from memory_leak_005_bad to main]
N1086 -> N1084: [Return edge from memory_leak_005_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_5.c 62] memory_leak_005_bad 		[N1086 -{Return edge from memory_leak_005_bad to main}-> N1084]	(the heap object @H(memory_leak_005_bad::call) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_6.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_006_func_001_good]
 +memory_leak_006_func_001_good
SCC(1): [memory_leak_006_good]
 +memory_leak_006_good
SCC(1): [memory_leak_006_func_001_bad]
 +memory_leak_006_func_001_bad
SCC(1): [memory_leak_006_bad]
 +memory_leak_006_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_006_bad, memory_leak_006_func_001_bad, memory_leak_006_func_001_good, memory_leak_006_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_006_bad::call1), H(memory_leak_006_good::call1)] 
Point-To:

Ret-Value: R
----
function: memory_leak_006_bad
P+ = [] 
P- = [H(memory_leak_006_bad::call1)] 
Point-To:

Ret-Value: 
----
function: memory_leak_006_func_001_bad
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: memory_leak_006_func_001_good
P+ = [] 
P- = [] 
Point-To:

Ret-Value: R
----
function: memory_leak_006_good
P+ = [] 
P- = [H(memory_leak_006_good::call1)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.004s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1153): +oo]
> [1/1] entry: main ()
N1153 -{%retval = alloca i32, align 4}-> N1155
N1155 -{store i32 0, i32* %retval, align 4}-> N1156
N1156 -{call memory_leak_006_good}-> N1237
N1237 -{%dptr = alloca double*, align 8}-> N1239
N1239 -{%flag = alloca i32, align 4}-> N1242
N1242 -{store i32 0, i32* %flag, align 4}-> N1243
N1243 -{%0 = load i32, i32* %flag, align 4}-> N1244
N1244 -{call memory_leak_006_func_001_good}-> N1218
N1218 -{%flag.addr = alloca i32, align 4}-> N1220
N1220 -{%ret = alloca i32, align 4}-> N1221
N1221 -{store i32 %flag, i32* %flag.addr, align 4}-> N1224
N1224 -{%0 = load i32, i32* %flag.addr, align 4}-> N1225
N1225 -{%cmp = icmp eq i32 %0, 0}-> N1226
N1226 -{[%cmp = icmp eq i32 %0, 0]}-> N1234
N1226 -{[!(%cmp = icmp eq i32 %0, 0)]}-> N1235
N1234 -{store i32 0, i32* %ret, align 4}-> N1231
N1231 -{%1 = load i32, i32* %ret, align 4}-> N1232
N1232 -{ret i32 %1}-> N1217
N1217 -{Return edge from memory_leak_006_func_001_good to memory_leak_006_good}-> N1245
N1245 -{%cmp = icmp eq i32 %call, 0}-> N1246
N1246 -{[%cmp = icmp eq i32 %call, 0]}-> N1263
N1246 -{[!(%cmp = icmp eq i32 %call, 0)]}-> N1261
N1263 -{%call1 = call i8* @malloc(i64 40, i64 @malloc)}-> N1248
N1263 -{%call1 = call i8* @malloc(i64 40, i64 @malloc)}-> N1248
N1248 -{%1 = bitcast i8* %call1 to double*}-> N1249
N1248 -{%1 = bitcast i8* %call1 to double*}-> N1249
N1249 -{store double* %1, double** %dptr, align 8}-> N1250
N1249 -{store double* %1, double** %dptr, align 8}-> N1250
N1250 -{%2 = load double*, double** %dptr, align 8}-> N1251
N1250 -{%2 = load double*, double** %dptr, align 8}-> N1251
N1251 -{%cmp2 = icmp ne double* %2, null}-> N1252
N1251 -{%cmp2 = icmp ne double* %2, null}-> N1252
N1252 -{[%cmp2 = icmp ne double* %2, null]}-> N1265
N1252 -{[!(%cmp2 = icmp ne double* %2, null)]}-> N1261
N1252 -{[%cmp2 = icmp ne double* %2, null]}-> N1265
N1252 -{[!(%cmp2 = icmp ne double* %2, null)]}-> N1261
N1265 -{%3 = load double*, double** %dptr, align 8}-> N1254
N1254 -{%add.ptr = getelementptr inbounds double, double* %3, i64 1}-> N1255
N1255 -{store double 1.050000e+01, double* %add.ptr, align 8}-> N1256
N1256 -{%4 = load double*, double** %dptr, align 8}-> N1257
N1257 -{%5 = bitcast double* %4 to i8*}-> N1258
N1258 -{call void @free(i8* %5, i8* @free)}-> N1261
N1261 -{ret void}-> N1236
N1236 -{Return edge from memory_leak_006_good to main}-> N1157
N1157 -{call memory_leak_006_bad}-> N1161
N1161 -{%dptr = alloca double*, align 8}-> N1163
N1163 -{%flag = alloca i32, align 4}-> N1166
N1166 -{store i32 0, i32* %flag, align 4}-> N1167
N1167 -{%0 = load i32, i32* %flag, align 4}-> N1168
N1168 -{call memory_leak_006_func_001_bad}-> N1199
N1199 -{%flag.addr = alloca i32, align 4}-> N1201
N1201 -{%ret = alloca i32, align 4}-> N1202
N1202 -{store i32 %flag, i32* %flag.addr, align 4}-> N1205
N1205 -{%0 = load i32, i32* %flag.addr, align 4}-> N1206
N1206 -{%cmp = icmp eq i32 %0, 0}-> N1207
N1207 -{[%cmp = icmp eq i32 %0, 0]}-> N1215
N1207 -{[!(%cmp = icmp eq i32 %0, 0)]}-> N1216
N1215 -{store i32 0, i32* %ret, align 4}-> N1212
N1212 -{%1 = load i32, i32* %ret, align 4}-> N1213
N1213 -{ret i32 %1}-> N1198
N1198 -{Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad}-> N1169
N1169 -{%cmp = icmp eq i32 %call, 0}-> N1170
N1170 -{[%cmp = icmp eq i32 %call, 0]}-> N1192
N1170 -{[!(%cmp = icmp eq i32 %call, 0)]}-> N1182
N1192 -{%call1 = call i8* @malloc(i64 40, i64 @malloc)}-> N1172
N1192 -{%call1 = call i8* @malloc(i64 40, i64 @malloc)}-> N1172
N1172 -{%1 = bitcast i8* %call1 to double*}-> N1173
N1172 -{%1 = bitcast i8* %call1 to double*}-> N1173
N1173 -{store double* %1, double** %dptr, align 8}-> N1174
N1173 -{store double* %1, double** %dptr, align 8}-> N1174
N1174 -{%2 = load double*, double** %dptr, align 8}-> N1175
N1174 -{%2 = load double*, double** %dptr, align 8}-> N1175
N1175 -{%cmp2 = icmp ne double* %2, null}-> N1176
N1175 -{%cmp2 = icmp ne double* %2, null}-> N1176
N1176 -{[%cmp2 = icmp ne double* %2, null]}-> N1194
N1176 -{[!(%cmp2 = icmp ne double* %2, null)]}-> N1182
N1176 -{[%cmp2 = icmp ne double* %2, null]}-> N1194
N1176 -{[!(%cmp2 = icmp ne double* %2, null)]}-> N1182
N1194 -{%3 = load double*, double** %dptr, align 8}-> N1178
N1178 -{%add.ptr = getelementptr inbounds double, double* %3, i64 1}-> N1179
N1179 -{store double 1.050000e+01, double* %add.ptr, align 8}-> N1182
N1182 -{%4 = load i32, i32* %flag, align 4}-> N1183
N1182 -{%4 = load i32, i32* %flag, align 4}-> N1183
N1183 -{call memory_leak_006_func_001_bad}-> N1199
N1199 -{%flag.addr = alloca i32, align 4}-> N1201
N1201 -{%ret = alloca i32, align 4}-> N1202
N1202 -{store i32 %flag, i32* %flag.addr, align 4}-> N1205
N1205 -{%0 = load i32, i32* %flag.addr, align 4}-> N1206
N1206 -{%cmp = icmp eq i32 %0, 0}-> N1207
N1207 -{[%cmp = icmp eq i32 %0, 0]}-> N1215
N1207 -{[!(%cmp = icmp eq i32 %0, 0)]}-> N1216
N1215 -{store i32 0, i32* %ret, align 4}-> N1212
N1212 -{%1 = load i32, i32* %ret, align 4}-> N1213
N1213 -{ret i32 %1}-> N1198
N1198 -{Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad}-> N1184
N1183 -{call memory_leak_006_func_001_bad}-> N1199
N1199 -{%flag.addr = alloca i32, align 4}-> N1201
N1201 -{%ret = alloca i32, align 4}-> N1202
N1202 -{store i32 %flag, i32* %flag.addr, align 4}-> N1205
N1205 -{%0 = load i32, i32* %flag.addr, align 4}-> N1206
N1206 -{%cmp = icmp eq i32 %0, 0}-> N1207
N1207 -{[%cmp = icmp eq i32 %0, 0]}-> N1215
N1207 -{[!(%cmp = icmp eq i32 %0, 0)]}-> N1216
N1215 -{store i32 0, i32* %ret, align 4}-> N1212
N1212 -{%1 = load i32, i32* %ret, align 4}-> N1213
N1213 -{ret i32 %1}-> N1198
N1198 -{Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad}-> N1184
N1184 -{%cmp6 = icmp ne i32 %call5, 0}-> N1185
N1184 -{%cmp6 = icmp ne i32 %call5, 0}-> N1185
N1185 -{[%cmp6 = icmp ne i32 %call5, 0]}-> N1196
N1185 -{[!(%cmp6 = icmp ne i32 %call5, 0)]}-> N1190
N1185 -{[%cmp6 = icmp ne i32 %call5, 0]}-> N1196
N1185 -{[!(%cmp6 = icmp ne i32 %call5, 0)]}-> N1190
N1190 -{ret void}-> N1160
N1190 -{ret void}-> N1160
N1160 -{Return edge from memory_leak_006_bad to main}-> N1158
N1160 -{Return edge from memory_leak_006_bad to main}-> N1158
N1158 -{ret i32 0}-> N1152
N1158 -{ret i32 0}-> N1152
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1160
On edge  : N1160 -{Return edge from memory_leak_006_bad to main}-> N1158
Message  : the heap object @H(memory_leak_006_bad::call1) is not referenced any more
> Start from entry function: main, At N1153 of Function main
> Entering function: memory_leak_006_good, On N1156 -> N1237 (call memory_leak_006_good)
> Entering function: memory_leak_006_func_001_good, On N1244 -> N1218 (call memory_leak_006_func_001_good)
> takes the true branch, At N1226 of Function memory_leak_006_func_001_good
> Leaving function: memory_leak_006_func_001_good, On N1217 -> N1245 (Return edge from memory_leak_006_func_001_good to memory_leak_006_good)
> takes the true branch, At N1246 of Function memory_leak_006_good
> takes the false branch, At N1252 of Function memory_leak_006_good
> Leaving function: memory_leak_006_good, On N1236 -> N1157 (Return edge from memory_leak_006_good to main)
> Entering function: memory_leak_006_bad, On N1157 -> N1161 (call memory_leak_006_bad)
> Entering function: memory_leak_006_func_001_bad, On N1168 -> N1199 (call memory_leak_006_func_001_bad)
> takes the true branch, At N1207 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N1198 -> N1169 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the true branch, At N1170 of Function memory_leak_006_bad
> takes the true branch, At N1176 of Function memory_leak_006_bad
> Entering function: memory_leak_006_func_001_bad, On N1183 -> N1199 (call memory_leak_006_func_001_bad)
> takes the true branch, At N1207 of Function memory_leak_006_func_001_bad
> Leaving function: memory_leak_006_func_001_bad, On N1198 -> N1184 (Return edge from memory_leak_006_func_001_bad to memory_leak_006_bad)
> takes the false branch, At N1185 of Function memory_leak_006_bad
<Defect> : N1160 -> N1158: [Return edge from memory_leak_006_bad to main]
N1160 -> N1158: [Return edge from memory_leak_006_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_6.c 82] memory_leak_006_bad 		[N1160 -{Return edge from memory_leak_006_bad to main}-> N1158]	(the heap object @H(memory_leak_006_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_7.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
5 SCCs to deal with
SCC(1): [memory_leak_007_func_001_bad]
 +memory_leak_007_func_001_bad
SCC(1): [memory_leak_007_bad]
 +memory_leak_007_bad
SCC(1): [memory_leak_007_func_001_good]
 +memory_leak_007_func_001_good
SCC(1): [memory_leak_007_good]
 +memory_leak_007_good
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_007_bad, memory_leak_007_func_001_bad, memory_leak_007_func_001_good, memory_leak_007_good]
Loops     []
----
function: main
P+ = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
P- = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8), H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
Point-To:
G(vptr_bad) -> [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)]
G(vptr_good) -> [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)]
Ret-Value: R
----
function: memory_leak_007_bad
P+ = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)] 
P- = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)] 
Point-To:
G(vptr_bad) -> [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)]
Ret-Value: 
----
function: memory_leak_007_func_001_bad
P+ = [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)] 
P- = [] 
Point-To:
G(vptr_bad) -> [H(memory_leak_007_func_001_bad::call), H(memory_leak_007_func_001_bad::call2), H(memory_leak_007_func_001_bad::call8)]
Ret-Value: R
----
function: memory_leak_007_func_001_good
P+ = [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
P- = [] 
Point-To:
G(vptr_good) -> [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)]
Ret-Value: R
----
function: memory_leak_007_good
P+ = [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
P- = [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)] 
Point-To:
G(vptr_good) -> [H(memory_leak_007_func_001_good::call), H(memory_leak_007_func_001_good::call2), H(memory_leak_007_func_001_good::call8)]
Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.012s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1268): +oo]
> [1/1] entry: main ()
N1268 -{global: vptr_bad}-> N1450
N1450 -{global: vptr_good}-> N1449
N1449 -{%retval = alloca i32, align 4}-> N1270
N1270 -{store i32 0, i32* %retval, align 4}-> N1271
N1271 -{call memory_leak_007_good}-> N1427
N1427 -{%ret = alloca i32, align 4}-> N1430
N1430 -{%call = call i32 @rand(i32 ()* @rand)}-> N1431
N1431 -{call memory_leak_007_func_001_good}-> N1363
N1363 -{%retval = alloca i32, align 4}-> N1365
N1365 -{%flag.addr = alloca i32, align 4}-> N1366
N1366 -{store i32 %flag, i32* %flag.addr, align 4}-> N1368
N1368 -{%0 = load i32, i32* %flag.addr, align 4}-> N1369
N1369 -{[%0 = load i32, i32* %flag.addr, align 4==1]}-> N1414
N1369 -{[%0 = load i32, i32* %flag.addr, align 4!=1]}-> N1415
N1414 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N1371
N1414 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N1371
N1371 -{%1 = bitcast i8* %call to i32*}-> N1372
N1371 -{%1 = bitcast i8* %call to i32*}-> N1372
N1372 -{%2 = bitcast i32* %1 to i8*}-> N1373
N1372 -{%2 = bitcast i32* %1 to i8*}-> N1373
N1373 -{store i8* %2, i8** @vptr_good, align 8}-> N1374
N1373 -{store i8* %2, i8** @vptr_good, align 8}-> N1374
N1374 -{%3 = load i8*, i8** @vptr_good, align 8}-> N1375
N1374 -{%3 = load i8*, i8** @vptr_good, align 8}-> N1375
N1375 -{%cmp = icmp ne i8* %3, null}-> N1376
N1375 -{%cmp = icmp ne i8* %3, null}-> N1376
N1376 -{[%cmp = icmp ne i8* %3, null]}-> N1420
N1376 -{[!(%cmp = icmp ne i8* %3, null)]}-> N1382
N1376 -{[%cmp = icmp ne i8* %3, null]}-> N1420
N1376 -{[!(%cmp = icmp ne i8* %3, null)]}-> N1382
N1420 -{%4 = load i8*, i8** @vptr_good, align 8}-> N1378
N1378 -{%5 = bitcast i8* %4 to i32*}-> N1379
N1379 -{%add.ptr = getelementptr inbounds i32, i32* %5, i64 1}-> N1380
N1380 -{store i32 10, i32* %add.ptr, align 4}-> N1382
N1382 -{store i32 1, i32* %retval, align 4}-> N1411
N1382 -{store i32 1, i32* %retval, align 4}-> N1411
N1411 -{%13 = load i32, i32* %retval, align 4}-> N1412
N1411 -{%13 = load i32, i32* %retval, align 4}-> N1412
N1412 -{ret i32 %13}-> N1362
N1412 -{ret i32 %13}-> N1362
N1362 -{Return edge from memory_leak_007_func_001_good to memory_leak_007_good}-> N1432
N1362 -{Return edge from memory_leak_007_func_001_good to memory_leak_007_good}-> N1432
N1432 -{store i32 %call1, i32* %ret, align 4}-> N1433
N1432 -{store i32 %call1, i32* %ret, align 4}-> N1433
N1433 -{%0 = load i32, i32* %ret, align 4}-> N1434
N1433 -{%0 = load i32, i32* %ret, align 4}-> N1434
N1434 -{%cmp = icmp sge i32 %0, 0}-> N1435
N1434 -{%cmp = icmp sge i32 %0, 0}-> N1435
N1435 -{[%cmp = icmp sge i32 %0, 0]}-> N1445
N1435 -{[!(%cmp = icmp sge i32 %0, 0)]}-> N1443
N1435 -{[%cmp = icmp sge i32 %0, 0]}-> N1445
N1435 -{[!(%cmp = icmp sge i32 %0, 0)]}-> N1443
N1445 -{%1 = load i8*, i8** @vptr_good, align 8}-> N1437
N1445 -{%1 = load i8*, i8** @vptr_good, align 8}-> N1437
N1437 -{%cmp2 = icmp ne i8* %1, null}-> N1438
N1437 -{%cmp2 = icmp ne i8* %1, null}-> N1438
N1438 -{[%cmp2 = icmp ne i8* %1, null]}-> N1447
N1438 -{[!(%cmp2 = icmp ne i8* %1, null)]}-> N1443
N1438 -{[%cmp2 = icmp ne i8* %1, null]}-> N1447
N1438 -{[!(%cmp2 = icmp ne i8* %1, null)]}-> N1443
N1447 -{%2 = load i8*, i8** @vptr_good, align 8}-> N1440
N1440 -{call void @free(i8* %2, i8* @free)}-> N1443
N1443 -{ret void}-> N1426
N1426 -{Return edge from memory_leak_007_good to main}-> N1272
N1272 -{call memory_leak_007_bad}-> N1276
N1276 -{%ret = alloca i32, align 4}-> N1279
N1279 -{%call = call i32 @rand(i32 ()* @rand)}-> N1280
N1280 -{call memory_leak_007_func_001_bad}-> N1299
N1299 -{%retval = alloca i32, align 4}-> N1301
N1301 -{%flag.addr = alloca i32, align 4}-> N1302
N1302 -{store i32 %flag, i32* %flag.addr, align 4}-> N1304
N1304 -{%0 = load i32, i32* %flag.addr, align 4}-> N1305
N1305 -{[%0 = load i32, i32* %flag.addr, align 4==1]}-> N1350
N1305 -{[%0 = load i32, i32* %flag.addr, align 4!=1]}-> N1351
N1350 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N1307
N1350 -{%call = call i8* @calloc(i64 10, i64 4, i64 @calloc)}-> N1307
N1307 -{%1 = bitcast i8* %call to i32*}-> N1308
N1307 -{%1 = bitcast i8* %call to i32*}-> N1308
N1308 -{%2 = bitcast i32* %1 to i8*}-> N1309
N1308 -{%2 = bitcast i32* %1 to i8*}-> N1309
N1309 -{store i8* %2, i8** @vptr_bad, align 8}-> N1310
N1309 -{store i8* %2, i8** @vptr_bad, align 8}-> N1310
N1310 -{%3 = load i8*, i8** @vptr_bad, align 8}-> N1311
N1310 -{%3 = load i8*, i8** @vptr_bad, align 8}-> N1311
N1311 -{%cmp = icmp ne i8* %3, null}-> N1312
N1311 -{%cmp = icmp ne i8* %3, null}-> N1312
N1312 -{[%cmp = icmp ne i8* %3, null]}-> N1356
N1312 -{[!(%cmp = icmp ne i8* %3, null)]}-> N1318
N1312 -{[%cmp = icmp ne i8* %3, null]}-> N1356
N1312 -{[!(%cmp = icmp ne i8* %3, null)]}-> N1318
N1356 -{%4 = load i8*, i8** @vptr_bad, align 8}-> N1314
N1314 -{%5 = bitcast i8* %4 to i32*}-> N1315
N1315 -{%add.ptr = getelementptr inbounds i32, i32* %5, i64 1}-> N1316
N1316 -{store i32 10, i32* %add.ptr, align 4}-> N1318
N1318 -{store i32 1, i32* %retval, align 4}-> N1347
N1318 -{store i32 1, i32* %retval, align 4}-> N1347
N1347 -{%13 = load i32, i32* %retval, align 4}-> N1348
N1347 -{%13 = load i32, i32* %retval, align 4}-> N1348
N1348 -{ret i32 %13}-> N1298
N1348 -{ret i32 %13}-> N1298
N1298 -{Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad}-> N1281
N1298 -{Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad}-> N1281
N1281 -{store i32 %call1, i32* %ret, align 4}-> N1282
N1281 -{store i32 %call1, i32* %ret, align 4}-> N1282
N1282 -{%0 = load i32, i32* %ret, align 4}-> N1283
N1282 -{%0 = load i32, i32* %ret, align 4}-> N1283
N1283 -{%cmp = icmp eq i32 %0, 0}-> N1284
N1283 -{%cmp = icmp eq i32 %0, 0}-> N1284
N1284 -{[%cmp = icmp eq i32 %0, 0]}-> N1294
N1284 -{[!(%cmp = icmp eq i32 %0, 0)]}-> N1292
N1284 -{[%cmp = icmp eq i32 %0, 0]}-> N1294
N1284 -{[!(%cmp = icmp eq i32 %0, 0)]}-> N1292
N1292 -{ret void}-> N1275
N1292 -{ret void}-> N1275
N1275 -{Return edge from memory_leak_007_bad to main}-> N1273
N1275 -{Return edge from memory_leak_007_bad to main}-> N1273
N1273 -{ret i32 0}-> N1267
N1273 -{ret i32 0}-> N1267
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1273
On edge  : N1273 -{ret i32 0}-> N1267
Message  : the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more
> Start from entry function: main, At N1268 of Function main
> Entering function: memory_leak_007_good, On N1271 -> N1427 (call memory_leak_007_good)
> Entering function: memory_leak_007_func_001_good, On N1431 -> N1363 (call memory_leak_007_func_001_good)
> matches the value of 1, At N1369 of Function memory_leak_007_func_001_good
> takes the false branch, At N1376 of Function memory_leak_007_func_001_good
> Leaving function: memory_leak_007_func_001_good, On N1362 -> N1432 (Return edge from memory_leak_007_func_001_good to memory_leak_007_good)
> takes the true branch, At N1435 of Function memory_leak_007_good
> takes the false branch, At N1438 of Function memory_leak_007_good
> Leaving function: memory_leak_007_good, On N1426 -> N1272 (Return edge from memory_leak_007_good to main)
> Entering function: memory_leak_007_bad, On N1272 -> N1276 (call memory_leak_007_bad)
> Entering function: memory_leak_007_func_001_bad, On N1280 -> N1299 (call memory_leak_007_func_001_bad)
> matches the value of 1, At N1305 of Function memory_leak_007_func_001_bad
> takes the true branch, At N1312 of Function memory_leak_007_func_001_bad
> Leaving function: memory_leak_007_func_001_bad, On N1298 -> N1281 (Return edge from memory_leak_007_func_001_bad to memory_leak_007_bad)
> takes the false branch, At N1284 of Function memory_leak_007_bad
> Leaving function: memory_leak_007_bad, On N1275 -> N1273 (Return edge from memory_leak_007_bad to main)
<Defect> : N1273 -> N1267: [ret i32 0]
N1273 -> N1267: [ret i32 0] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_7.c 129] main 		[N1273 -{ret i32 0}-> N1267]	(the heap object @H(memory_leak_007_func_001_bad::call) is not referenced any more)

Found 1 defects in all (0 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_8.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_008_good]
 +memory_leak_008_good
SCC(1): [memory_leak_008_bad]
 +memory_leak_008_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_008_bad, memory_leak_008_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_008_bad::call), H(memory_leak_008_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_008_bad
P+ = [] 
P- = [H(memory_leak_008_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_008_good
P+ = [] 
P- = [H(memory_leak_008_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.02s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1452): +oo]
> [1/1] entry: main ()
N1452 -{%retval = alloca i32, align 4}-> N1454
N1454 -{store i32 0, i32* %retval, align 4}-> N1455
N1455 -{call memory_leak_008_good}-> N1488
N1488 -{%ptr = alloca i32*, align 8}-> N1490
N1490 -{%p = alloca i32*, align 8}-> N1492
N1492 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1493
N1492 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1493
N1493 -{%0 = bitcast i8* %call to i32*}-> N1494
N1493 -{%0 = bitcast i8* %call to i32*}-> N1494
N1494 -{store i32* %0, i32** %ptr, align 8}-> N1496
N1494 -{store i32* %0, i32** %ptr, align 8}-> N1496
N1496 -{store i32* null, i32** %p, align 8}-> N1497
N1496 -{store i32* null, i32** %p, align 8}-> N1497
N1497 -{%1 = load i32*, i32** %ptr, align 8}-> N1498
N1497 -{%1 = load i32*, i32** %ptr, align 8}-> N1498
N1498 -{%cmp = icmp ne i32* %1, null}-> N1499
N1498 -{%cmp = icmp ne i32* %1, null}-> N1499
N1499 -{[%cmp = icmp ne i32* %1, null]}-> N1512
N1499 -{[!(%cmp = icmp ne i32* %1, null)]}-> N1510
N1499 -{[%cmp = icmp ne i32* %1, null]}-> N1512
N1499 -{[!(%cmp = icmp ne i32* %1, null)]}-> N1510
N1512 -{%2 = load i32*, i32** %ptr, align 8}-> N1501
N1501 -{store i32* %2, i32** %p, align 8}-> N1502
N1502 -{%3 = load i32*, i32** %p, align 8}-> N1503
N1503 -{%add.ptr = getelementptr inbounds i32, i32* %3, i64 1}-> N1504
N1504 -{store i32 1, i32* %add.ptr, align 4}-> N1505
N1505 -{%4 = load i32*, i32** %ptr, align 8}-> N1506
N1506 -{%5 = bitcast i32* %4 to i8*}-> N1507
N1507 -{call void @free(i8* %5, i8* @free)}-> N1508
N1508 -{store i32* null, i32** %ptr, align 8}-> N1510
N1510 -{ret void}-> N1487
N1487 -{Return edge from memory_leak_008_good to main}-> N1456
N1456 -{call memory_leak_008_bad}-> N1460
N1460 -{%ptr = alloca i32*, align 8}-> N1462
N1462 -{%p = alloca i32*, align 8}-> N1464
N1464 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1465
N1464 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1465
N1465 -{%0 = bitcast i8* %call to i32*}-> N1466
N1465 -{%0 = bitcast i8* %call to i32*}-> N1466
N1466 -{store i32* %0, i32** %ptr, align 8}-> N1468
N1466 -{store i32* %0, i32** %ptr, align 8}-> N1468
N1468 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1469
N1468 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1469
N1468 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1469
N1468 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1469
N1469 -{%1 = bitcast i8* %call1 to i32*}-> N1470
N1469 -{%1 = bitcast i8* %call1 to i32*}-> N1470
N1469 -{%1 = bitcast i8* %call1 to i32*}-> N1470
N1469 -{%1 = bitcast i8* %call1 to i32*}-> N1470
N1470 -{store i32* %1, i32** %p, align 8}-> N1471
N1470 -{store i32* %1, i32** %p, align 8}-> N1471
N1470 -{store i32* %1, i32** %p, align 8}-> N1471
N1470 -{store i32* %1, i32** %p, align 8}-> N1471
N1471 -{%2 = load i32*, i32** %ptr, align 8}-> N1472
N1471 -{%2 = load i32*, i32** %ptr, align 8}-> N1472
N1471 -{%2 = load i32*, i32** %ptr, align 8}-> N1472
N1471 -{%2 = load i32*, i32** %ptr, align 8}-> N1472
N1472 -{%cmp = icmp ne i32* %2, null}-> N1473
N1472 -{%cmp = icmp ne i32* %2, null}-> N1473
N1472 -{%cmp = icmp ne i32* %2, null}-> N1473
N1472 -{%cmp = icmp ne i32* %2, null}-> N1473
N1473 -{[%cmp = icmp ne i32* %2, null]}-> N1485
N1473 -{[!(%cmp = icmp ne i32* %2, null)]}-> N1483
N1473 -{[%cmp = icmp ne i32* %2, null]}-> N1485
N1473 -{[!(%cmp = icmp ne i32* %2, null)]}-> N1483
N1473 -{[%cmp = icmp ne i32* %2, null]}-> N1485
N1473 -{[!(%cmp = icmp ne i32* %2, null)]}-> N1483
N1473 -{[%cmp = icmp ne i32* %2, null]}-> N1485
N1473 -{[!(%cmp = icmp ne i32* %2, null)]}-> N1483
N1485 -{%3 = load i32*, i32** %ptr, align 8}-> N1475
N1485 -{%3 = load i32*, i32** %ptr, align 8}-> N1475
N1475 -{store i32* %3, i32** %p, align 8}-> N1476
N1475 -{store i32* %3, i32** %p, align 8}-> N1476
N1476 -{%4 = load i32*, i32** %p, align 8}-> N1477
N1476 -{%4 = load i32*, i32** %p, align 8}-> N1477
N1477 -{%add.ptr = getelementptr inbounds i32, i32* %4, i64 1}-> N1478
N1477 -{%add.ptr = getelementptr inbounds i32, i32* %4, i64 1}-> N1478
N1478 -{store i32 1, i32* %add.ptr, align 4}-> N1479
N1478 -{store i32 1, i32* %add.ptr, align 4}-> N1479
N1479 -{%5 = load i32*, i32** %ptr, align 8}-> N1480
N1479 -{%5 = load i32*, i32** %ptr, align 8}-> N1480
N1480 -{%6 = bitcast i32* %5 to i8*}-> N1481
N1480 -{%6 = bitcast i32* %5 to i8*}-> N1481
N1481 -{call void @free(i8* %6, i8* @free)}-> N1483
N1481 -{call void @free(i8* %6, i8* @free)}-> N1483
N1483 -{ret void}-> N1459
N1483 -{ret void}-> N1459
N1459 -{Return edge from memory_leak_008_bad to main}-> N1457
N1459 -{Return edge from memory_leak_008_bad to main}-> N1457
N1457 -{ret i32 0}-> N1451
N1457 -{ret i32 0}-> N1451
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1459
On edge  : N1459 -{Return edge from memory_leak_008_bad to main}-> N1457
Message  : the heap object @H(memory_leak_008_bad::call1) is not referenced any more
> Start from entry function: main, At N1452 of Function main
> Entering function: memory_leak_008_good, On N1455 -> N1488 (call memory_leak_008_good)
> takes the false branch, At N1499 of Function memory_leak_008_good
> Leaving function: memory_leak_008_good, On N1487 -> N1456 (Return edge from memory_leak_008_good to main)
> Entering function: memory_leak_008_bad, On N1456 -> N1460 (call memory_leak_008_bad)
> takes the false branch, At N1473 of Function memory_leak_008_bad
<Defect> : N1459 -> N1457: [Return edge from memory_leak_008_bad to main]
N1459 -> N1457: [Return edge from memory_leak_008_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_8.c 54] memory_leak_008_bad 		[N1459 -{Return edge from memory_leak_008_bad to main}-> N1457]	(the heap object @H(memory_leak_008_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS

<< Starting CFACreatePhase(cfa) Phase >>
[/home/guzuxing/Documents/benchmark/CWE/itc/401/401_memory_leak_9.ll]
Finish creating ll file
Finish parsing file
Finish parsing to Cfa
Finish inserting global variables
Finish removing unreachable nodes
Finish simplifying
Finish labeling reverse post order id
Finish labeling flood order
Finish inserting fun call return
Finish building
Finish post process
CFA exported to: output/cfa-merged/cfa.dot
Function CFA exported to: output/cfa-separate/
Call graph exported to: output/cfa-merged/call-graph.dot
Used instruction types are exported to: output/cfa-merged/instructions.txt
Phase status: SUCCESS

<< Starting SummaryComputationPhase(summary) Phase >>
Computing summary >>> 
Running summary: cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer
3 SCCs to deal with
SCC(1): [memory_leak_009_good]
 +memory_leak_009_good
SCC(1): [memory_leak_009_bad]
 +memory_leak_009_bad
SCC(1): [main]
 +main
<begin of summary store (POINTER_AP)>
Functions [main, memory_leak_009_bad, memory_leak_009_good]
Loops     []
----
function: main
P+ = [] 
P- = [H(memory_leak_009_bad::call), H(memory_leak_009_good::call)] 
Point-To:

Ret-Value: R
----
function: memory_leak_009_bad
P+ = [] 
P- = [H(memory_leak_009_bad::call)] 
Point-To:

Ret-Value: 
----
function: memory_leak_009_good
P+ = [] 
P- = [H(memory_leak_009_good::call)] 
Point-To:

Ret-Value: 
<end of summary store>
Finish summary: (Configuration: [summary=POINTER_AP, ARGCPA.cpa=cpa.composite.CompositeCPA, computer=cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer, analysis.traversal.controlled.maxWaitingSize=100, cpa=cpa.arg.ARGCPA, analysis.traversal.useDominationOrder=true, analysis.traversal.order=bfs, CompositeCPA.cpas=cpa.location.LocationCPA, cpa.accesspath.AccessPathAnalysisCPA], cn.edu.thu.tsmart.core.summary.computer.PointerAccessSummaryComputer)
Finish summary >>> 
Used time: 0.003s
Phase status: SUCCESS

<< Starting MultiEntryAlgorithmRunPhase(basic) Phase >>
Using 1 entries: [main(N1515): +oo]
> [1/1] entry: main ()
N1515 -{%retval = alloca i32, align 4}-> N1517
N1517 -{store i32 0, i32* %retval, align 4}-> N1518
N1518 -{call memory_leak_009_good}-> N1552
N1552 -{%ptr = alloca float*, align 8}-> N1554
N1554 -{%p = alloca float*, align 8}-> N1556
N1556 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1557
N1556 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1557
N1557 -{%0 = bitcast i8* %call to float*}-> N1558
N1557 -{%0 = bitcast i8* %call to float*}-> N1558
N1558 -{store float* %0, float** %ptr, align 8}-> N1560
N1558 -{store float* %0, float** %ptr, align 8}-> N1560
N1560 -{store float* null, float** %p, align 8}-> N1561
N1560 -{store float* null, float** %p, align 8}-> N1561
N1561 -{%1 = load float*, float** %ptr, align 8}-> N1562
N1561 -{%1 = load float*, float** %ptr, align 8}-> N1562
N1562 -{%cmp = icmp ne float* %1, null}-> N1563
N1562 -{%cmp = icmp ne float* %1, null}-> N1563
N1563 -{[%cmp = icmp ne float* %1, null]}-> N1576
N1563 -{[!(%cmp = icmp ne float* %1, null)]}-> N1574
N1563 -{[%cmp = icmp ne float* %1, null]}-> N1576
N1563 -{[!(%cmp = icmp ne float* %1, null)]}-> N1574
N1576 -{%2 = load float*, float** %ptr, align 8}-> N1565
N1565 -{store float* %2, float** %p, align 8}-> N1566
N1566 -{%3 = load float*, float** %p, align 8}-> N1567
N1567 -{%add.ptr = getelementptr inbounds float, float* %3, i64 1}-> N1568
N1568 -{store float 1.500000e+00, float* %add.ptr, align 4}-> N1569
N1569 -{%4 = load float*, float** %ptr, align 8}-> N1570
N1570 -{%5 = bitcast float* %4 to i8*}-> N1571
N1571 -{call void @free(i8* %5, i8* @free)}-> N1572
N1572 -{store float* null, float** %ptr, align 8}-> N1574
N1574 -{ret void}-> N1551
N1551 -{Return edge from memory_leak_009_good to main}-> N1519
N1519 -{call memory_leak_009_bad}-> N1523
N1523 -{%ptr = alloca float*, align 8}-> N1525
N1525 -{%p = alloca float*, align 8}-> N1527
N1527 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1528
N1527 -{%call = call i8* @malloc(i64 20, i64 @malloc)}-> N1528
N1528 -{%0 = bitcast i8* %call to float*}-> N1529
N1528 -{%0 = bitcast i8* %call to float*}-> N1529
N1529 -{store float* %0, float** %ptr, align 8}-> N1531
N1529 -{store float* %0, float** %ptr, align 8}-> N1531
N1531 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1532
N1531 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1532
N1531 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1532
N1531 -{%call1 = call i8* @malloc(i64 20, i64 @malloc)}-> N1532
N1532 -{%1 = bitcast i8* %call1 to float*}-> N1533
N1532 -{%1 = bitcast i8* %call1 to float*}-> N1533
N1532 -{%1 = bitcast i8* %call1 to float*}-> N1533
N1532 -{%1 = bitcast i8* %call1 to float*}-> N1533
N1533 -{store float* %1, float** %p, align 8}-> N1534
N1533 -{store float* %1, float** %p, align 8}-> N1534
N1533 -{store float* %1, float** %p, align 8}-> N1534
N1533 -{store float* %1, float** %p, align 8}-> N1534
N1534 -{%2 = load float*, float** %ptr, align 8}-> N1535
N1534 -{%2 = load float*, float** %ptr, align 8}-> N1535
N1534 -{%2 = load float*, float** %ptr, align 8}-> N1535
N1534 -{%2 = load float*, float** %ptr, align 8}-> N1535
N1535 -{%cmp = icmp ne float* %2, null}-> N1536
N1535 -{%cmp = icmp ne float* %2, null}-> N1536
N1535 -{%cmp = icmp ne float* %2, null}-> N1536
N1535 -{%cmp = icmp ne float* %2, null}-> N1536
N1536 -{[%cmp = icmp ne float* %2, null]}-> N1549
N1536 -{[!(%cmp = icmp ne float* %2, null)]}-> N1547
N1536 -{[%cmp = icmp ne float* %2, null]}-> N1549
N1536 -{[!(%cmp = icmp ne float* %2, null)]}-> N1547
N1536 -{[%cmp = icmp ne float* %2, null]}-> N1549
N1536 -{[!(%cmp = icmp ne float* %2, null)]}-> N1547
N1536 -{[%cmp = icmp ne float* %2, null]}-> N1549
N1536 -{[!(%cmp = icmp ne float* %2, null)]}-> N1547
N1549 -{%3 = load float*, float** %ptr, align 8}-> N1538
N1549 -{%3 = load float*, float** %ptr, align 8}-> N1538
N1538 -{store float* %3, float** %p, align 8}-> N1539
N1538 -{store float* %3, float** %p, align 8}-> N1539
N1539 -{%4 = load float*, float** %p, align 8}-> N1540
N1539 -{%4 = load float*, float** %p, align 8}-> N1540
N1540 -{%add.ptr = getelementptr inbounds float, float* %4, i64 1}-> N1541
N1540 -{%add.ptr = getelementptr inbounds float, float* %4, i64 1}-> N1541
N1541 -{store float 1.000000e+00, float* %add.ptr, align 4}-> N1542
N1541 -{store float 1.000000e+00, float* %add.ptr, align 4}-> N1542
N1542 -{%5 = load float*, float** %ptr, align 8}-> N1543
N1542 -{%5 = load float*, float** %ptr, align 8}-> N1543
N1543 -{%6 = bitcast float* %5 to i8*}-> N1544
N1543 -{%6 = bitcast float* %5 to i8*}-> N1544
N1544 -{call void @free(i8* %6, i8* @free)}-> N1545
N1544 -{call void @free(i8* %6, i8* @free)}-> N1545
N1545 -{store float* null, float** %ptr, align 8}-> N1547
N1545 -{store float* null, float** %ptr, align 8}-> N1547
N1547 -{ret void}-> N1522
N1547 -{ret void}-> N1522
N1522 -{Return edge from memory_leak_009_bad to main}-> N1520
N1522 -{Return edge from memory_leak_009_bad to main}-> N1520
N1520 -{ret i32 0}-> N1514
N1520 -{ret i32 0}-> N1514
finish entry: main
Phase status: SUCCESS

<< Starting AnalyzingResultPhase(result) Phase >>
== Reports ==
-- start of trace --
Weakness : Memory Leak
At node  : N1522
On edge  : N1522 -{Return edge from memory_leak_009_bad to main}-> N1520
Message  : the heap object @H(memory_leak_009_bad::call1) is not referenced any more
> Start from entry function: main, At N1515 of Function main
> Entering function: memory_leak_009_good, On N1518 -> N1552 (call memory_leak_009_good)
> takes the false branch, At N1563 of Function memory_leak_009_good
> Leaving function: memory_leak_009_good, On N1551 -> N1519 (Return edge from memory_leak_009_good to main)
> Entering function: memory_leak_009_bad, On N1519 -> N1523 (call memory_leak_009_bad)
> takes the false branch, At N1536 of Function memory_leak_009_bad
<Defect> : N1522 -> N1520: [Return edge from memory_leak_009_bad to main]
N1522 -> N1520: [Return edge from memory_leak_009_bad to main] <--
-- end of trace --
=====================================================
CWE_401(Memory Leak): 1
	[./401_memory_leak_9.c 55] memory_leak_009_bad 		[N1522 -{Return edge from memory_leak_009_bad to main}-> N1520]	(the heap object @H(memory_leak_009_bad::call1) is not referenced any more)

Found 1 defects in all (2 duplicates ignored).
=====================================================
Phase status: SUCCESS


Process finished with exit code 255
